<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v5.2.3-pre: API docs</title><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel="stylesheet" href="/docs/css/github.css"><link rel="stylesheet" href="/docs/css/mongoose5.css"><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="manifest" href="images/favicon/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/docs/css/api.css"></head><body><div id="layout"><div id="mobile-menu"><a id="menuLink" href="#menu" class="menu-link"><span></span></a><div id="mobile-logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><div class="pure-menu"><div id="logo-container" class="pure-menu-heading"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list"><li class="pure-menu-horizontal pure-menu-item pure-menu-has-children pure-menu-allow-hover version"><a href="#" class="pure-menu-link">Version 5.2.3-pre</a><ul class="pure-menu-children"><li class="pure-menu-item"><a href="/docs/4.x" class="pure-menu-link">Version 4.13.14</a></li><li class="pure-menu-item"><a href="/docs/3.8.x" class="pure-menu-link">Version 3.8.40</a></li></ul></li><li class="pure-menu-item"><a href="/docs/index.html" class="pure-menu-link">Quick Start</a></li><li class="pure-menu-item"><a href="/docs/guides.html" class="pure-menu-link">Guides</a></li><li class="pure-menu-item sub-item"><a href="/docs/guide.html" class="pure-menu-link">Schemas</a></li><li class="pure-menu-item sub-item"><a href="/docs/schematypes.html" class="pure-menu-link">SchemaTypes</a></li><li class="pure-menu-item sub-item"><a href="/docs/connections.html" class="pure-menu-link">Connections</a></li><li class="pure-menu-item sub-item"><a href="/docs/models.html" class="pure-menu-link">Models</a></li><li class="pure-menu-item sub-item"><a href="/docs/documents.html" class="pure-menu-link">Documents</a></li><li class="pure-menu-item sub-item"><a href="/docs/subdocs.html" class="pure-menu-link">Subdocuments</a></li><li class="pure-menu-item sub-item"><a href="/docs/queries.html" class="pure-menu-link">Queries</a></li><li class="pure-menu-item sub-item"><a href="/docs/validation.html" class="pure-menu-link">Validation</a></li><li class="pure-menu-item sub-item"><a href="/docs/middleware.html" class="pure-menu-link">Middleware</a></li><li class="pure-menu-item sub-item"><a href="/docs/populate.html" class="pure-menu-link">Populate</a></li><li class="pure-menu-item sub-item"><a href="/docs/discriminators.html" class="pure-menu-link">Discriminators</a></li><li class="pure-menu-item sub-item"><a href="/docs/plugins.html" class="pure-menu-link">Plugins</a></li><li class="pure-menu-item"><a href="/docs/api.html" class="pure-menu-link">API</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#mongoose_Mongoose" class="pure-menu-link">Mongoose</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schema" class="pure-menu-link">Schema</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Connection" class="pure-menu-link">Connection</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Document" class="pure-menu-link">Document</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Model" class="pure-menu-link">Model</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Query" class="pure-menu-link">Query</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Aggregate" class="pure-menu-link">Aggregate</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Schematype" class="pure-menu-link">SchemaType</a></li><li class="pure-menu-item sub-item"><a href="/docs/api.html#Virtualtype" class="pure-menu-link">VirtualType</a></li><li class="pure-menu-item"><a href="/docs/compatibility.html" class="pure-menu-link">Version Compatibility</a></li><li class="pure-menu-item"><a href="/docs/faq.html" class="pure-menu-link">FAQ</a></li><li class="carbon-ad"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=mongoosejscom" id="_carbonads_js"></script></li></ul></div></div><div class="container"><div id="content"><h1>API Docs</h1><hr class="separate-api"><h2 id="Index"><a href="#Index">Index</a></h2><ul><li><a href="#mongoose_Mongoose">Mongoose()</a></li><li><a href="#mongoose_Mongoose-Aggregate">Mongoose.prototype.Aggregate()</a></li><li><a href="#mongoose_Mongoose-CastError">Mongoose.prototype.CastError()</a></li><li><a href="#mongoose_Mongoose-Collection">Mongoose.prototype.Collection()</a></li><li><a href="#mongoose_Mongoose-Connection">Mongoose.prototype.Connection()</a></li><li><a href="#mongoose_Mongoose-Document">Mongoose.prototype.Document()</a></li><li><a href="#mongoose_Mongoose-DocumentProvider">Mongoose.prototype.DocumentProvider()</a></li><li><a href="#mongoose_Mongoose-Error">Mongoose.prototype.Error()</a></li><li><a href="#mongoose_Mongoose-Model">Mongoose.prototype.Model()</a></li><li><a href="#mongoose_Mongoose-Mongoose">Mongoose.prototype.Mongoose()</a></li><li><a href="#mongoose_Mongoose-Promise">Mongoose.prototype.Promise</a></li><li><a href="#mongoose_Mongoose-PromiseProvider">Mongoose.prototype.PromiseProvider()</a></li><li><a href="#mongoose_Mongoose-Query">Mongoose.prototype.Query()</a></li><li><a href="#mongoose_Mongoose-STATES">Mongoose.prototype.STATES</a></li><li><a href="#mongoose_Mongoose-Schema">Mongoose.prototype.Schema()</a></li><li><a href="#mongoose_Mongoose-SchemaType">Mongoose.prototype.SchemaType()</a></li><li><a href="#mongoose_Mongoose-SchemaTypes">Mongoose.prototype.SchemaTypes</a></li><li><a href="#mongoose_Mongoose-Types">Mongoose.prototype.Types</a></li><li><a href="#mongoose_Mongoose-VirtualType">Mongoose.prototype.VirtualType()</a></li><li><a href="#mongoose_Mongoose-connect">Mongoose.prototype.connect()</a></li><li><a href="#mongoose_Mongoose-connection">Mongoose.prototype.connection</a></li><li><a href="#mongoose_Mongoose-createConnection">Mongoose.prototype.createConnection()</a></li><li><a href="#mongoose_Mongoose-disconnect">Mongoose.prototype.disconnect()</a></li><li><a href="#mongoose_Mongoose-get">Mongoose.prototype.get()</a></li><li><a href="#mongoose_Mongoose-model">Mongoose.prototype.model()</a></li><li><a href="#mongoose_Mongoose-modelNames">Mongoose.prototype.modelNames()</a></li><li><a href="#mongoose_Mongoose-mongo">Mongoose.prototype.mongo</a></li><li><a href="#mongoose_Mongoose-mquery">Mongoose.prototype.mquery</a></li><li><a href="#mongoose_Mongoose-plugin">Mongoose.prototype.plugin()</a></li><li><a href="#mongoose_Mongoose-pluralize">Mongoose.prototype.pluralize()</a></li><li><a href="#mongoose_Mongoose-set">Mongoose.prototype.set()</a></li><li><a href="#mongoose_Mongoose-startSession">Mongoose.prototype.startSession()</a></li><li><a href="#mongoose_Mongoose-version">Mongoose.prototype.version</a></li></ul><hr class="separate-api-elements"><h3 id="mongoose_Mongoose"><a href="#mongoose_Mongoose">Mongoose()</a></h3><div><p>Mongoose constructor.</p>

<p>The exports object of the <code>mongoose</code> module is an instance of this class. Most apps will only use this one instance.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Aggregate"><a href="#mongoose_Mongoose-Aggregate">Mongoose.prototype.Aggregate()</a></h3><div><p>The Mongoose Aggregate constructor</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-CastError"><a href="#mongoose_Mongoose-CastError">Mongoose.prototype.CastError()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">type <span class="method-type">&laquo;String&raquo;</span> The name of the type</li><li class="param">value <span class="method-type">&laquo;Any&raquo;</span> The value that failed to cast</li><li class="param">path <span class="method-type">&laquo;String&raquo;</span> The path <code>a.b.c</code> in the doc where this cast error occurred</li><li class="param">[reason] <span class="method-type">&laquo;Error&raquo;</span> The original error that was thrown</li></ul><div><p>The Mongoose CastError constructor</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Collection"><a href="#mongoose_Mongoose-Collection">Mongoose.prototype.Collection()</a></h3><div><p>The Mongoose Collection constructor</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Connection"><a href="#mongoose_Mongoose-Connection">Mongoose.prototype.Connection()</a></h3><div><p>The Mongoose <a href="#connection_Connection">Connection</a> constructor</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Document"><a href="#mongoose_Mongoose-Document">Mongoose.prototype.Document()</a></h3><div><p>The Mongoose <a href="#document-js">Document</a> constructor.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-DocumentProvider"><a href="#mongoose_Mongoose-DocumentProvider">Mongoose.prototype.DocumentProvider()</a></h3><div><p>The Mongoose DocumentProvider constructor.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Error"><a href="#mongoose_Mongoose-Error">Mongoose.prototype.Error()</a></h3><div><p>The <a href="#error_MongooseError">MongooseError</a> constructor.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Model"><a href="#mongoose_Mongoose-Model">Mongoose.prototype.Model()</a></h3><div><p>The Mongoose <a href="#model_Model">Model</a> constructor.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Mongoose"><a href="#mongoose_Mongoose-Mongoose">Mongoose.prototype.Mongoose()</a></h3><div><p>The Mongoose constructor</p>

<p>The exports of the mongoose module is an instance of this class.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">var</span> mongoose2 = <span class="hljs-keyword">new</span> mongoose.Mongoose();</code></pre></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Promise"><a href="#mongoose_Mongoose-Promise">Mongoose.prototype.Promise</a></h3><div><p>The Mongoose <a href="#promise_Promise">Promise</a> constructor.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-PromiseProvider"><a href="#mongoose_Mongoose-PromiseProvider">Mongoose.prototype.PromiseProvider()</a></h3><div><p>Storage layer for mongoose promises</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Query"><a href="#mongoose_Mongoose-Query">Mongoose.prototype.Query()</a></h3><div><p>The Mongoose <a href="#query_Query">Query</a> constructor.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-STATES"><a href="#mongoose_Mongoose-STATES">Mongoose.prototype.STATES</a></h3><div><p>Expose connection states for user-land</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Schema"><a href="#mongoose_Mongoose-Schema">Mongoose.prototype.Schema()</a></h3><div><p>The Mongoose <a href="#schema_Schema">Schema</a> constructor</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">var</span> Schema = mongoose.Schema;
<span class="hljs-keyword">var</span> CatSchema = <span class="hljs-keyword">new</span> Schema(..);</code></pre></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-SchemaType"><a href="#mongoose_Mongoose-SchemaType">Mongoose.prototype.SchemaType()</a></h3><div><p>The Mongoose <a href="#schematype_SchemaType">SchemaType</a> constructor</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-SchemaTypes"><a href="#mongoose_Mongoose-SchemaTypes">Mongoose.prototype.SchemaTypes</a></h3><div><p>The various Mongoose SchemaTypes.</p>

<h4>Note:</h4>

<p><em>Alias of mongoose.Schema.Types for backwards compatibility.</em></p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-Types"><a href="#mongoose_Mongoose-Types">Mongoose.prototype.Types</a></h3><div><p>The various Mongoose Types.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">var</span> array = mongoose.Types.Array;</code></pre>

<h4>Types:</h4>

<ul>
<li><a href="#types-objectid-js">ObjectId</a></li>
<li><a href="#types-buffer-js">Buffer</a></li>
<li><a href="#types-embedded-js">SubDocument</a></li>
<li><a href="#types-array-js">Array</a></li>
<li><a href="#types-documentarray-js">DocumentArray</a></li>
</ul>

<p>Using this exposed access to the <code>ObjectId</code> type, we can construct ids on demand.</p>

<pre><code><span class="hljs-keyword">var</span> ObjectId = mongoose.Types.ObjectId;
<span class="hljs-keyword">var</span> id1 = <span class="hljs-keyword">new</span> ObjectId;</code></pre></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-VirtualType"><a href="#mongoose_Mongoose-VirtualType">Mongoose.prototype.VirtualType()</a></h3><div><p>The Mongoose <a href="#virtualtype_VirtualType">VirtualType</a> constructor</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-connect"><a href="#mongoose_Mongoose-connect">Mongoose.prototype.connect()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">uri(s) <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> passed down to the <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html">MongoDB driver&#39;s <code>connect()</code> function</a>, except for 4 mongoose-specific options explained below.</li><li class="param">[options.user] <span class="method-type">&laquo;String&raquo;</span> username for authentication, equivalent to <code>options.auth.user</code>. Maintained for backwards compatibility.</li><li class="param">[options.pass] <span class="method-type">&laquo;String&raquo;</span> password for authentication, equivalent to <code>options.auth.password</code>. Maintained for backwards compatibility.</li><li class="param">[options.autoIndex=true] <span class="method-type">&laquo;Boolean&raquo;</span> Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.</li><li class="param">[options.bufferCommands=true] <span class="method-type">&laquo;Boolean&raquo;</span> Mongoose specific option. Set to false to <a href="http://mongoosejs.com/docs/faq.html#callback_never_executes">disable buffering</a> on all models associated with this connection.</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> resolves to `this` if connection succeeded</li></ul><div><p>Opens the default mongoose connection.</p>

<h4>Example:</h4>

<pre><code>mongoose.connect(<span class="hljs-string">'mongodb://user:pass@localhost:port/database'</span>);

<span class="hljs-comment">// replica sets</span>
<span class="hljs-keyword">var</span> uri = <span class="hljs-string">'mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/mydatabase'</span>;
mongoose.connect(uri);

<span class="hljs-comment">// with options</span>
mongoose.connect(uri, options);

<span class="hljs-comment">// optional callback that gets fired when initial connection completed</span>
<span class="hljs-keyword">var</span> uri = <span class="hljs-string">'mongodb://nonexistent.domain:27000'</span>;
mongoose.connect(uri, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// if error is truthy, the initial connection failed.</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-connection"><a href="#mongoose_Mongoose-connection">Mongoose.prototype.connection</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Connection&raquo;</span> </li></ul><div><p>The default connection of the mongoose module.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
mongoose.connect(...);
mongoose.connection.on(<span class="hljs-string">'error'</span>, cb);</code></pre>

<p>This is the connection used by default for every model created using <a href="#index_Mongoose-model">mongoose.model</a>.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-createConnection"><a href="#mongoose_Mongoose-createConnection">Mongoose.prototype.createConnection()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[uri] <span class="method-type">&laquo;String&raquo;</span> a mongodb:// URI</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> passed down to the <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html">MongoDB driver&#39;s <code>connect()</code> function</a>, except for 4 mongoose-specific options explained below.</li><li class="param">[options.user] <span class="method-type">&laquo;String&raquo;</span> username for authentication, equivalent to <code>options.auth.user</code>. Maintained for backwards compatibility.</li><li class="param">[options.pass] <span class="method-type">&laquo;String&raquo;</span> password for authentication, equivalent to <code>options.auth.password</code>. Maintained for backwards compatibility.</li><li class="param">[options.autoIndex=true] <span class="method-type">&laquo;Boolean&raquo;</span> Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.</li><li class="param">[options.bufferCommands=true] <span class="method-type">&laquo;Boolean&raquo;</span> Mongoose specific option. Set to false to <a href="http://mongoosejs.com/docs/faq.html#callback_never_executes">disable buffering</a> on all models associated with this connection.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Connection&raquo;</span> the created Connection object. Connections are thenable, so you can do `await mongoose.createConnection()`</li></ul><div><p>Creates a Connection instance.</p>

<p>Each <code>connection</code> instance maps to a single database. This method is helpful when mangaging multiple db connections.</p>

<p>If arguments are passed, they are proxied to either <a href="#connection_Connection-open">Connection#open</a> or <a href="#connection_Connection-openSet">Connection#openSet</a> appropriately. This means we can pass <code>db</code>, <code>server</code>, and <code>replset</code> options to the driver. <em>Note that the <code>safe</code> option specified in your schema will overwrite the <code>safe</code> db option specified here unless you set your schemas <code>safe</code> option to <code>undefined</code>. See <a href="/docs/guide.html#safe">this</a> for more information.</em></p>

<p><em>Options passed take precedence over options included in connection strings.</em></p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// with mongodb:// URI</span>
db = mongoose.createConnection(<span class="hljs-string">'mongodb://user:pass@localhost:port/database'</span>);

<span class="hljs-comment">// and options</span>
<span class="hljs-keyword">var</span> opts = { db: { native_parser: <span class="hljs-literal">true</span> }}
db = mongoose.createConnection(<span class="hljs-string">'mongodb://user:pass@localhost:port/database'</span>, opts);

<span class="hljs-comment">// replica sets</span>
db = mongoose.createConnection(<span class="hljs-string">'mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/database'</span>);

<span class="hljs-comment">// and options</span>
<span class="hljs-keyword">var</span> opts = { replset: { strategy: <span class="hljs-string">'ping'</span>, rs_name: <span class="hljs-string">'testSet'</span> }}
db = mongoose.createConnection(<span class="hljs-string">'mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/database'</span>, opts);

<span class="hljs-comment">// with [host, database_name[, port] signature</span>
db = mongoose.createConnection(<span class="hljs-string">'localhost'</span>, <span class="hljs-string">'database'</span>, port)

<span class="hljs-comment">// and options</span>
<span class="hljs-keyword">var</span> opts = { server: { auto_reconnect: <span class="hljs-literal">false</span> }, user: <span class="hljs-string">'username'</span>, pass: <span class="hljs-string">'mypassword'</span> }
db = mongoose.createConnection(<span class="hljs-string">'localhost'</span>, <span class="hljs-string">'database'</span>, port, opts)

<span class="hljs-comment">// initialize now, connect later</span>
db = mongoose.createConnection();
db.open(<span class="hljs-string">'localhost'</span>, <span class="hljs-string">'database'</span>, port, [opts]);</code></pre></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-disconnect"><a href="#mongoose_Mongoose-disconnect">Mongoose.prototype.disconnect()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> called after all connection close, or when first error occurred.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> resolves when all connections are closed, or rejects with the first error that occurred.</li></ul><div><p>Runs <code>.close()</code> on all connections in parallel.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-get"><a href="#mongoose_Mongoose-get">Mongoose.prototype.get()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">key <span class="method-type">&laquo;String&raquo;</span> </li></ul><div><p>Gets mongoose options</p>

<h4>Example:</h4>

<pre><code>mongoose.get(<span class="hljs-string">'test'</span>) <span class="hljs-comment">// returns the 'test' value</span></code></pre></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-model"><a href="#mongoose_Mongoose-model">Mongoose.prototype.model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String|Function&raquo;</span> model name or class extending Model</li><li class="param">[schema] <span class="method-type">&laquo;Schema&raquo;</span> </li><li class="param">[collection] <span class="method-type">&laquo;String&raquo;</span> name (optional, inferred from model name)</li><li class="param">[skipInit] <span class="method-type">&laquo;Boolean&raquo;</span> whether to skip initialization (defaults to false)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Model&raquo;</span> </li></ul><div><p>Defines a model or retrieves it.</p>

<p>Models defined on the <code>mongoose</code> instance are available to all connection created by the same <code>mongoose</code> instance.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);

<span class="hljs-comment">// define an Actor model with this mongoose instance</span>
mongoose.model(<span class="hljs-string">'Actor'</span>, <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }));

<span class="hljs-comment">// create a new connection</span>
<span class="hljs-keyword">var</span> conn = mongoose.createConnection(..);

<span class="hljs-comment">// retrieve the Actor model</span>
<span class="hljs-keyword">var</span> Actor = conn.model(<span class="hljs-string">'Actor'</span>);</code></pre>

<p><em>When no <code>collection</code> argument is passed, Mongoose uses the model name. If you don't like this behavior, either pass a collection name, use <code>mongoose.pluralize()</code>, or set your schemas collection name option.</em></p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { collection: <span class="hljs-string">'actor'</span> });

<span class="hljs-comment">// or</span>

schema.set(<span class="hljs-string">'collection'</span>, <span class="hljs-string">'actor'</span>);

<span class="hljs-comment">// or</span>

<span class="hljs-keyword">var</span> collectionName = <span class="hljs-string">'actor'</span>
<span class="hljs-keyword">var</span> M = mongoose.model(<span class="hljs-string">'Actor'</span>, schema, collectionName)</code></pre></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-modelNames"><a href="#mongoose_Mongoose-modelNames">Mongoose.prototype.modelNames()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Array&raquo;</span> </li></ul><div><p>Returns an array of model names created on this instance of Mongoose.</p>

<h4>Note:</h4>

<p><em>Does not include names of models created using <code>connection.model()</code>.</em></p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-mongo"><a href="#mongoose_Mongoose-mongo">Mongoose.prototype.mongo</a></h3><div><p>The <a href="https://github.com/mongodb/node-mongodb-native">node-mongodb-native</a> driver Mongoose uses.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-mquery"><a href="#mongoose_Mongoose-mquery">Mongoose.prototype.mquery</a></h3><div><p>The <a href="https://github.com/aheckmann/mquery">mquery</a> query builder Mongoose uses.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-plugin"><a href="#mongoose_Mongoose-plugin">Mongoose.prototype.plugin()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> plugin callback</li><li class="param">[opts] <span class="method-type">&laquo;Object&raquo;</span> optional options</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Mongoose&raquo;</span> this</li></ul><div><p>Declares a global plugin executed on all Schemas.</p>

<p>Equivalent to calling <code>.plugin(fn)</code> on each Schema you create.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-pluralize"><a href="#mongoose_Mongoose-pluralize">Mongoose.prototype.pluralize()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn] <span class="method-type">&laquo;Function|null&raquo;</span> overwrites the function used to pluralize collection names</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Function,null&raquo;</span> the current function used to pluralize collection names, defaults to the legacy function from `mongoose-legacy-pluralize`.</li></ul><div><p>Getter/setter around function for pluralizing collection names.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-set"><a href="#mongoose_Mongoose-set">Mongoose.prototype.set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">key <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">value <span class="method-type">&laquo;String|Function|Boolean&raquo;</span> </li></ul><div><p>Sets mongoose options</p>

<h4>Example:</h4>

<pre><code>mongoose.set(<span class="hljs-string">'test'</span>, value) <span class="hljs-comment">// sets the 'test' option to `value`</span>

mongoose.set(<span class="hljs-string">'debug'</span>, <span class="hljs-literal">true</span>) <span class="hljs-comment">// enable logging collection methods + arguments to the console</span>

mongoose.set(<span class="hljs-string">'debug'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collectionName, methodName, arg1, arg2...</span>) </span>{}); <span class="hljs-comment">// use custom function to log collection methods + arguments</span></code></pre>

<h2>Currently supported options are</h2>

<ul>
<li>'debug': prints the operations mongoose sends to MongoDB to the console</li>
<li>'bufferCommands': enable/disable mongoose's buffering mechanism for all connections and models</li>
<li>'useFindAndModify': true by default. Set to <code>false</code> to make <code>findOneAndUpdate()</code> and <code>findOneAndRemove()</code> use native <code>findOneAndUpdate()</code> rather than <code>findAndModify()</code>.</li>
<li>'cloneSchemas': false by default. Set to <code>true</code> to <code>clone()</code> all schemas before compiling into a model.</li>
<li>'applyPluginsToDiscriminators': false by default. Set to true to apply global plugins to discriminator schemas. This typically isn't necessary because plugins are applied to the base schema and discriminators copy all middleware, methods, statics, and properties from the base schema.</li>
<li>'objectIdGetter': true by default. Mongoose adds a getter to MongoDB ObjectId's called <code>_id</code> that returns <code>this</code> for convenience with populate. Set this to false to remove the getter.</li>
<li>'runValidators': false by default. Set to true to enable <a href="/docs/validation.html#update-validators">update validators</a> for all validators by default.</li>
</ul></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-startSession"><a href="#mongoose_Mongoose-startSession">Mongoose.prototype.startSession()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> see the <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html#startSession">mongodb driver options</a></li><li class="param">[options.causalConsistency=true] <span class="method-type">&laquo;Boolean&raquo;</span> set to false to disable causal consistency</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&lt;ClientSession&gt;&raquo;</span> promise that resolves to a MongoDB driver `ClientSession`</li></ul><div><p><em>Requires MongoDB >= 3.6.0.</em> Starts a <a href="https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions">MongoDB session</a> for benefits like causal consistency, <a href="https://docs.mongodb.com/manual/core/retryable-writes/">retryable writes</a>, and <a href="http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html">transactions</a>.</p>

<p>Calling <code>mongoose.startSession()</code> is equivalent to calling <code>mongoose.connection.startSession()</code>. Sessions are scoped to a connection, so calling <code>mongoose.startSession()</code> starts a session on the <a href="/docs/api.html#mongoose_Mongoose-connection">default mongoose connection</a>.</p></div><hr class="separate-api-elements"><h3 id="mongoose_Mongoose-version"><a href="#mongoose_Mongoose-version">Mongoose.prototype.version</a></h3><div><p>The Mongoose version</p>

<h4>Example</h4>

<pre><code><span class="hljs-built_in">console</span>.log(mongoose.version); <span class="hljs-comment">// '5.x.x'</span></code></pre></div><hr class="separate-api"><h2 id="Schema"><a href="#Schema">Schema</a></h2><ul><li><a href="#schema_Schema">Schema()</a></li><li><a href="#schema_Schema.Types">Schema.Types</a></li><li><a href="#schema_Schema-indexTypes">Schema.indexTypes</a></li><li><a href="#schema_Schema-add">Schema.prototype.add()</a></li><li><a href="#schema_Schema-childSchemas">Schema.prototype.childSchemas</a></li><li><a href="#schema_Schema-clone">Schema.prototype.clone()</a></li><li><a href="#schema_Schema-eachPath">Schema.prototype.eachPath()</a></li><li><a href="#schema_Schema-get">Schema.prototype.get()</a></li><li><a href="#schema_Schema-index">Schema.prototype.index()</a></li><li><a href="#schema_Schema-indexes">Schema.prototype.indexes()</a></li><li><a href="#schema_Schema-loadClass">Schema.prototype.loadClass()</a></li><li><a href="#schema_Schema-method">Schema.prototype.method()</a></li><li><a href="#schema_Schema-obj">Schema.prototype.obj</a></li><li><a href="#schema_Schema-path">Schema.prototype.path()</a></li><li><a href="#schema_Schema-pathType">Schema.prototype.pathType()</a></li><li><a href="#schema_Schema-plugin">Schema.prototype.plugin()</a></li><li><a href="#schema_Schema-post">Schema.prototype.post()</a></li><li><a href="#schema_Schema-pre">Schema.prototype.pre()</a></li><li><a href="#schema_Schema-queue">Schema.prototype.queue()</a></li><li><a href="#schema_Schema-remove">Schema.prototype.remove()</a></li><li><a href="#schema_Schema-requiredPaths">Schema.prototype.requiredPaths()</a></li><li><a href="#schema_Schema-set">Schema.prototype.set()</a></li><li><a href="#schema_Schema-static">Schema.prototype.static()</a></li><li><a href="#schema_Schema-virtual">Schema.prototype.virtual()</a></li><li><a href="#schema_Schema-virtualpath">Schema.prototype.virtualpath()</a></li><li><a href="#schema_Schema.reserved">Schema.reserved</a></li></ul><hr class="separate-api-elements"><h3 id="schema_Schema"><a href="#schema_Schema">Schema()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">definition <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>Schema constructor.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span>, age: <span class="hljs-built_in">Number</span>, children: [child] });
<span class="hljs-keyword">var</span> Tree = mongoose.model(<span class="hljs-string">'Tree'</span>, schema);

<span class="hljs-comment">// setting schema options</span>
<span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { _id: <span class="hljs-literal">false</span>, autoIndex: <span class="hljs-literal">false</span> })</code></pre>

<h4>Options:</h4>

<ul>
<li><a href="/docs/guide.html#autoIndex">autoIndex</a>: bool - defaults to null (which means use the connection's autoIndex option)</li>
<li><a href="/docs/guide.html#bufferCommands">bufferCommands</a>: bool - defaults to true</li>
<li><a href="/docs/guide.html#capped">capped</a>: bool - defaults to false</li>
<li><a href="/docs/guide.html#collection">collection</a>: string - no default</li>
<li><a href="/docs/guide.html#id">id</a>: bool - defaults to true</li>
<li><a href="/docs/guide.html#_id">_id</a>: bool - defaults to true</li>
<li><code>minimize</code>: bool - controls <a href="#document_Document-toObject">document#toObject</a> behavior when called manually - defaults to true</li>
<li><a href="/docs/guide.html#read">read</a>: string</li>
<li><a href="/docs/guide.html#writeConcern">writeConcern</a>: object - defaults to null, use to override <a href="https://docs.mongodb.com/manual/reference/write-concern/">the MongoDB server's default write concern settings</a></li>
<li><a href="/docs/guide.html#shardKey">shardKey</a>: bool - defaults to <code>null</code></li>
<li><a href="/docs/guide.html#strict">strict</a>: bool - defaults to true</li>
<li><a href="/docs/guide.html#toJSON">toJSON</a> - object - no default</li>
<li><a href="/docs/guide.html#toObject">toObject</a> - object - no default</li>
<li><a href="/docs/guide.html#typeKey">typeKey</a> - string - defaults to 'type'</li>
<li><a href="/docs/guide.html#useNestedStrict">useNestedStrict</a> - boolean - defaults to false</li>
<li><a href="/docs/guide.html#validateBeforeSave">validateBeforeSave</a> - bool - defaults to <code>true</code></li>
<li><a href="/docs/guide.html#versionKey">versionKey</a>: string - defaults to "__v"</li>
<li><a href="/docs/guide.html#collation">collation</a>: object - defaults to null (which means use no collation)</li>
</ul>

<h4>Note:</h4>

<p><em>When nesting schemas, (<code>children</code> in the example above), always declare the child schema first before passing it into its parent.</em></p></div><hr class="separate-api-elements"><h3 id="schema_Schema.Types"><a href="#schema_Schema.Types">Schema.Types</a></h3><div><p>The various built-in Mongoose Schema Types.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">var</span> ObjectId = mongoose.Schema.Types.ObjectId;</code></pre>

<h4>Types:</h4>

<ul>
<li><a href="#schema-string-js">String</a></li>
<li><a href="#schema-number-js">Number</a></li>
<li><a href="#schema-boolean-js">Boolean</a> | Bool</li>
<li><a href="#schema-array-js">Array</a></li>
<li><a href="#schema-buffer-js">Buffer</a></li>
<li><a href="#schema-date-js">Date</a></li>
<li><a href="#schema-objectid-js">ObjectId</a> | Oid</li>
<li><a href="#schema-mixed-js">Mixed</a></li>
</ul>

<p>Using this exposed access to the <code>Mixed</code> SchemaType, we can use them in our schema.</p>

<pre><code><span class="hljs-keyword">var</span> Mixed = mongoose.Schema.Types.Mixed;
<span class="hljs-keyword">new</span> mongoose.Schema({ _user: Mixed })</code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-indexTypes"><a href="#schema_Schema-indexTypes">Schema.indexTypes</a></h3><div><p>The allowed index types</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-add"><a href="#schema_Schema-add">Schema.prototype.add()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">obj <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">prefix <span class="method-type">&laquo;String&raquo;</span> </li></ul><div><p>Adds key path / schema type pairs to this schema.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> ToySchema = <span class="hljs-keyword">new</span> Schema;
ToySchema.add({ name: <span class="hljs-string">'string'</span>, color: <span class="hljs-string">'string'</span>, price: <span class="hljs-string">'number'</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-childSchemas"><a href="#schema_Schema-childSchemas">Schema.prototype.childSchemas</a></h3><div><p>Array of child schemas (from document arrays and single nested subdocs) and their corresponding compiled models. Each element of the array is an object with 2 properties: <code>schema</code> and <code>model</code>.</p>

<p>This property is typically only useful for plugin authors and advanced users. You do not need to interact with this property at all to use mongoose.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-clone"><a href="#schema_Schema-clone">Schema.prototype.clone()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Schema&raquo;</span> the cloned schema</li></ul><div><p>Returns a deep copy of the schema</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-eachPath"><a href="#schema_Schema-eachPath">Schema.prototype.eachPath()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> callback function</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Schema&raquo;</span> this</li></ul><div><p>Iterates the schemas paths similar to Array#forEach.</p>

<p>The callback is passed the pathname and schemaType as arguments on each iteration.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-get"><a href="#schema_Schema-get">Schema.prototype.get()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">key <span class="method-type">&laquo;String&raquo;</span> option name</li></ul><div><p>Gets a schema option.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-index"><a href="#schema_Schema-index">Schema.prototype.index()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fields <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> Options to pass to <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex">MongoDB driver&#39;s <code>createIndex()</code> function</a></li><li class="param">[options.expires=null] <span class="method-type">&laquo;String&raquo;</span> Mongoose-specific syntactic sugar, uses <a href="https://www.npmjs.com/package/ms">ms</a> to convert <code>expires</code> option into seconds for the <code>expireAfterSeconds</code> in the above link.</li></ul><div><p>Defines an index (most likely compound) for this schema.</p>

<h4>Example</h4>

<pre><code>schema.index({ first: <span class="hljs-number">1</span>, last: <span class="hljs-number">-1</span> })</code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-indexes"><a href="#schema_Schema-indexes">Schema.prototype.indexes()</a></h3><div><p>Returns a list of indexes that this schema declares, via <code>schema.index()</code> or by <code>index: true</code> in a path's options.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-loadClass"><a href="#schema_Schema-loadClass">Schema.prototype.loadClass()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">model <span class="method-type">&laquo;Function&raquo;</span> </li><li class="param">[virtualsOnly] <span class="method-type">&laquo;Boolean&raquo;</span> if truthy, only pulls virtuals from the class, not methods or statics</li></ul><div><p>Loads an ES6 class into a schema. Maps <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set">setters</a> + <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">getters</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static">static methods</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions">instance methods</a> to schema <a href="http://mongoosejs.com/docs/guide.html#virtuals">virtuals</a>, <a href="http://mongoosejs.com/docs/guide.html#statics">statics</a>, and <a href="http://mongoosejs.com/docs/guide.html#methods">methods</a>.</p>

<h4>Example:</h4>

<div class="highlight"><pre lang="javascript">const md5 = require('md5');
const userSchema = new Schema({ email: String });
class UserClass {
  // `gravatarImage` becomes a virtual
  get gravatarImage() {
    const hash = md5(this.email.toLowerCase());
    return `<a href='https://www.gravatar.com/avatar/${hash}`'>https://www.gravatar.com/avatar/${hash}`</a>;
  }

  // `getProfileUrl()` becomes a document method
  getProfileUrl() {
    return `<a href='https://mysite.com/${this.email}`'>https://mysite.com/${this.email}`</a>;
  }

  // `findByEmail()` becomes a static
  static findByEmail(email) {
    return this.findOne({ email });
  }
}

// `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,
// and a `findByEmail()` static
userSchema.loadClass(UserClass);
</pre></div></div><hr class="separate-api-elements"><h3 id="schema_Schema-method"><a href="#schema_Schema-method">Schema.prototype.method()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">method <span class="method-type">&laquo;String|Object&raquo;</span> name</li><li class="param">[fn] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Adds an instance method to documents constructed from Models compiled from this schema.</p>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> schema = kittySchema = <span class="hljs-keyword">new</span> Schema(..);

schema.method(<span class="hljs-string">'meow'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'meeeeeoooooooooooow'</span>);
})

<span class="hljs-keyword">var</span> Kitty = mongoose.model(<span class="hljs-string">'Kitty'</span>, schema);

<span class="hljs-keyword">var</span> fizz = <span class="hljs-keyword">new</span> Kitty;
fizz.meow(); <span class="hljs-comment">// meeeeeooooooooooooow</span></code></pre>

<p>If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.</p>

<pre><code>schema.method({
    purr: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
  , scratch: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{}
});

<span class="hljs-comment">// later</span>
fizz.purr();
fizz.scratch();</code></pre>

<p>NOTE: <code>Schema.method()</code> adds instance methods to the <code>Schema.methods</code> object. You can also add instance methods directly to the <code>Schema.methods</code> object as seen in the <a href="./guide.html#methods">guide</a></p></div><hr class="separate-api-elements"><h3 id="schema_Schema-obj"><a href="#schema_Schema-obj">Schema.prototype.obj</a></h3><div><p>The original object passed to the schema constructor</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ a: <span class="hljs-built_in">String</span> }).add({ b: <span class="hljs-built_in">String</span> });
schema.obj; <span class="hljs-comment">// { a: String }</span></code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-path"><a href="#schema_Schema-path">Schema.prototype.path()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">constructor <span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>Gets/sets schema paths.</p>

<p>Sets a path (if arity 2) Gets a path (if arity 1)</p>

<h4>Example</h4>

<pre><code>schema.path(<span class="hljs-string">'name'</span>) <span class="hljs-comment">// returns a SchemaType</span>
schema.path(<span class="hljs-string">'name'</span>, <span class="hljs-built_in">Number</span>) <span class="hljs-comment">// changes the schemaType of `name` to Number</span></code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-pathType"><a href="#schema_Schema-pathType">Schema.prototype.pathType()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;String&raquo;</span> </li></ul><div><p>Returns the pathType of <code>path</code> for this schema.</p>

<p>Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-plugin"><a href="#schema_Schema-plugin">Schema.prototype.plugin()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">plugin <span class="method-type">&laquo;Function&raquo;</span> callback</li><li class="param">[opts] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>Registers a plugin for this schema.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-post"><a href="#schema_Schema-post">Schema.prototype.post()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">method <span class="method-type">&laquo;String&raquo;</span> name of the method to hook</li><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><div><p>Defines a post hook for the document</p>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema(..);
schema.post(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this fired after a document was saved'</span>);
});

schema.post(<span class="hljs-string">'find'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">docs</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this fired after you run a find query'</span>);
});

<span class="hljs-keyword">var</span> Model = mongoose.model(<span class="hljs-string">'Model'</span>, schema);

<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> Model(..);
m.save(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this fires after the `post` hook'</span>);
});

m.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, docs</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'this fires after the post find hook'</span>);
});</code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-pre"><a href="#schema_Schema-pre">Schema.prototype.pre()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">method <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Defines a pre hook for the document.</p>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> toySchema = <span class="hljs-keyword">new</span> Schema(..);

toySchema.pre(<span class="hljs-string">'save'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.created) <span class="hljs-keyword">this</span>.created = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;
  next();
})

toySchema.pre(<span class="hljs-string">'validate'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">next</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.name !== <span class="hljs-string">'Woody'</span>) <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'Woody'</span>;
  next();
})</code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-queue"><a href="#schema_Schema-queue">Schema.prototype.queue()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String&raquo;</span> name of the document method to call later</li><li class="param">args <span class="method-type">&laquo;Array&raquo;</span> arguments to pass to the method</li></ul><div><p>Adds a method call to the queue.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-remove"><a href="#schema_Schema-remove">Schema.prototype.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String|Array&raquo;</span> </li></ul><div><p>Removes the given <code>path</code> (or [<code>paths</code>]).</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-requiredPaths"><a href="#schema_Schema-requiredPaths">Schema.prototype.requiredPaths()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">invalidate <span class="method-type">&laquo;Boolean&raquo;</span> refresh the cache</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Array&raquo;</span> </li></ul><div><p>Returns an Array of path strings that are required by this schema.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-set"><a href="#schema_Schema-set">Schema.prototype.set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">key <span class="method-type">&laquo;String&raquo;</span> option name</li><li class="param">[value] <span class="method-type">&laquo;Object&raquo;</span> if not passed, the current option value is returned</li></ul><div><p>Sets/gets a schema option.</p>

<h4>Example</h4>

<pre><code>schema.set(<span class="hljs-string">'strict'</span>); <span class="hljs-comment">// 'true' by default</span>
schema.set(<span class="hljs-string">'strict'</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// Sets 'strict' to false</span>
schema.set(<span class="hljs-string">'strict'</span>); <span class="hljs-comment">// 'false'</span></code></pre></div><hr class="separate-api-elements"><h3 id="schema_Schema-static"><a href="#schema_Schema-static">Schema.prototype.static()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String|Object&raquo;</span> </li><li class="param">[fn] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Adds static "class" methods to Models compiled from this schema.</p>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema(..);
schema.static(<span class="hljs-string">'findByName'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, callback</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.find({ name: name }, callback);
});

<span class="hljs-keyword">var</span> Drink = mongoose.model(<span class="hljs-string">'Drink'</span>, schema);
Drink.findByName(<span class="hljs-string">'sanpellegrino'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, drinks</span>) </span>{
  <span class="hljs-comment">//</span>
});</code></pre>

<p>If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-virtual"><a href="#schema_Schema-virtual">Schema.prototype.virtual()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;VirtualType&raquo;</span> </li></ul><div><p>Creates a virtual type with the given name.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema-virtualpath"><a href="#schema_Schema-virtualpath">Schema.prototype.virtualpath()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;VirtualType&raquo;</span> </li></ul><div><p>Returns the virtual type with the given <code>name</code>.</p></div><hr class="separate-api-elements"><h3 id="schema_Schema.reserved"><a href="#schema_Schema.reserved">Schema.reserved</a></h3><div><p>Reserved document keys.</p>

<p>Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.</p>

<pre><code>on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject</code></pre>

<p><em>NOTE:</em> Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.</p>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema(..);
 schema.methods.init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{} <span class="hljs-comment">// potentially breaking</span></code></pre></div><hr class="separate-api"><h2 id="Connection"><a href="#Connection">Connection</a></h2><ul><li><a href="#connection_Connection">Connection()</a></li><li><a href="#connection_Connection-close">Connection.prototype.close()</a></li><li><a href="#connection_Connection-collection">Connection.prototype.collection()</a></li><li><a href="#connection_Connection-collections">Connection.prototype.collections</a></li><li><a href="#connection_Connection-config">Connection.prototype.config</a></li><li><a href="#connection_Connection-createCollection">Connection.prototype.createCollection()</a></li><li><a href="#connection_Connection-db">Connection.prototype.db</a></li><li><a href="#connection_Connection-dropCollection">Connection.prototype.dropCollection()</a></li><li><a href="#connection_Connection-dropDatabase">Connection.prototype.dropDatabase()</a></li><li><a href="#connection_Connection-host">Connection.prototype.host</a></li><li><a href="#connection_Connection-model">Connection.prototype.model()</a></li><li><a href="#connection_Connection-modelNames">Connection.prototype.modelNames()</a></li><li><a href="#connection_Connection-name">Connection.prototype.name</a></li><li><a href="#connection_Connection-pass">Connection.prototype.pass</a></li><li><a href="#connection_Connection-port">Connection.prototype.port</a></li><li><a href="#connection_Connection-readyState">Connection.prototype.readyState</a></li><li><a href="#connection_Connection-startSession">Connection.prototype.startSession()</a></li><li><a href="#connection_Connection-useDb">Connection.prototype.useDb()</a></li><li><a href="#connection_Connection-user">Connection.prototype.user</a></li></ul><hr class="separate-api-elements"><h3 id="connection_Connection"><a href="#connection_Connection">Connection()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">base <span class="method-type">&laquo;Mongoose&raquo;</span> a mongoose instance</li></ul><div><p>Connection constructor</p>

<p>For practical reasons, a Connection equals a Db.</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-close"><a href="#connection_Connection-close">Connection.prototype.close()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[force] <span class="method-type">&laquo;Boolean&raquo;</span> optional</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Connection&raquo;</span> self</li></ul><div><p>Closes the connection</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-collection"><a href="#connection_Connection-collection">Connection.prototype.collection()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String&raquo;</span> of the collection</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional collection options</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Collection&raquo;</span> collection instance</li></ul><div><p>Retrieves a collection, creating it if not cached.</p>

<p>Not typically needed by applications. Just talk to your collection through your model.</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-collections"><a href="#connection_Connection-collections">Connection.prototype.collections</a></h3><div><p>A hash of the collections associated with this connection</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-config"><a href="#connection_Connection-config">Connection.prototype.config</a></h3><div><p>A hash of the global options that are associated with this connection</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-createCollection"><a href="#connection_Connection-createCollection">Connection.prototype.createCollection()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">collection <span class="method-type">&laquo;string&raquo;</span> The collection to create</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> see <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html#createCollection">MongoDB driver docs</a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Helper for <code>createCollection()</code>. Will explicitly create the given collection with specified options. Used to create <a href="https://docs.mongodb.com/manual/core/capped-collections/">capped collections</a> and <a href="https://docs.mongodb.com/manual/core/views/">views</a> from mongoose.</p>

<p>Options are passed down without modification to the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html#createCollection">MongoDB driver's <code>createCollection()</code> function</a></p></div><hr class="separate-api-elements"><h3 id="connection_Connection-db"><a href="#connection_Connection-db">Connection.prototype.db</a></h3><div><p>The mongodb.Db instance, set when the connection is opened</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-dropCollection"><a href="#connection_Connection-dropCollection">Connection.prototype.dropCollection()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">collection <span class="method-type">&laquo;string&raquo;</span> The collection to delete</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Helper for <code>dropCollection()</code>. Will delete the given collection, including all documents and indexes.</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-dropDatabase"><a href="#connection_Connection-dropDatabase">Connection.prototype.dropDatabase()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Helper for <code>dropDatabase()</code>. Deletes the given database, including all collections, documents, and indexes.</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-host"><a href="#connection_Connection-host">Connection.prototype.host</a></h3><div><p>The host name portion of the URI. If multiple hosts, such as a replica set, this will contain the first host name in the URI</p>

<h4>Example</h4>

<pre><code>mongoose.createConnection(<span class="hljs-string">'mongodb://localhost:27017/mydb'</span>).host; <span class="hljs-comment">// "localhost"</span></code></pre></div><hr class="separate-api-elements"><h3 id="connection_Connection-model"><a href="#connection_Connection-model">Connection.prototype.model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String|Function&raquo;</span> the model name or class extending Model</li><li class="param">[schema] <span class="method-type">&laquo;Schema&raquo;</span> a schema. necessary when defining a model</li><li class="param">[collection] <span class="method-type">&laquo;String&raquo;</span> name of mongodb collection (optional) if not given it will be induced from model name</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Model&raquo;</span> The compiled model</li></ul><div><p>Defines or retrieves a model.</p>

<pre><code><span class="hljs-keyword">var</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">var</span> db = mongoose.createConnection(..);
db.model(<span class="hljs-string">'Venue'</span>, <span class="hljs-keyword">new</span> Schema(..));
<span class="hljs-keyword">var</span> Ticket = db.model(<span class="hljs-string">'Ticket'</span>, <span class="hljs-keyword">new</span> Schema(..));
<span class="hljs-keyword">var</span> Venue = db.model(<span class="hljs-string">'Venue'</span>);</code></pre>

<p><em>When no <code>collection</code> argument is passed, Mongoose produces a collection name by passing the model <code>name</code> to the <a href="#utils_exports.toCollectionName">utils.toCollectionName</a> method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option.</em></p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { collection: <span class="hljs-string">'actor'</span> });

<span class="hljs-comment">// or</span>

schema.set(<span class="hljs-string">'collection'</span>, <span class="hljs-string">'actor'</span>);

<span class="hljs-comment">// or</span>

<span class="hljs-keyword">var</span> collectionName = <span class="hljs-string">'actor'</span>
<span class="hljs-keyword">var</span> M = conn.model(<span class="hljs-string">'Actor'</span>, schema, collectionName)</code></pre></div><hr class="separate-api-elements"><h3 id="connection_Connection-modelNames"><a href="#connection_Connection-modelNames">Connection.prototype.modelNames()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Array&raquo;</span> </li></ul><div><p>Returns an array of model names created on this connection.</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-name"><a href="#connection_Connection-name">Connection.prototype.name</a></h3><div><p>The name of the database this connection points to.</p>

<h4>Example</h4>

<pre><code>mongoose.createConnection(<span class="hljs-string">'mongodb://localhost:27017/mydb'</span>).name; <span class="hljs-comment">// "mydb"</span></code></pre></div><hr class="separate-api-elements"><h3 id="connection_Connection-pass"><a href="#connection_Connection-pass">Connection.prototype.pass</a></h3><div><p>The password specified in the URI</p>

<h4>Example</h4>

<pre><code>mongoose.createConnection(<span class="hljs-string">'mongodb://val:psw@localhost:27017/mydb'</span>).pass; <span class="hljs-comment">// "psw"</span></code></pre></div><hr class="separate-api-elements"><h3 id="connection_Connection-port"><a href="#connection_Connection-port">Connection.prototype.port</a></h3><div><p>The port portion of the URI. If multiple hosts, such as a replica set, this will contain the port from the first host name in the URI.</p>

<h4>Example</h4>

<pre><code>mongoose.createConnection(<span class="hljs-string">'mongodb://localhost:27017/mydb'</span>).port; <span class="hljs-comment">// 27017</span></code></pre></div><hr class="separate-api-elements"><h3 id="connection_Connection-readyState"><a href="#connection_Connection-readyState">Connection.prototype.readyState</a></h3><div><p>Connection ready state</p>

<ul>
<li>0 = disconnected</li>
<li>1 = connected</li>
<li>2 = connecting</li>
<li>3 = disconnecting</li>
</ul>

<p>Each state change emits its associated event name.</p>

<h4>Example</h4>

<pre><code>conn.on(<span class="hljs-string">'connected'</span>, callback);
conn.on(<span class="hljs-string">'disconnected'</span>, callback);</code></pre></div><hr class="separate-api-elements"><h3 id="connection_Connection-startSession"><a href="#connection_Connection-startSession">Connection.prototype.startSession()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> see the <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html#startSession">mongodb driver options</a></li><li class="param">[options.causalConsistency=true] <span class="method-type">&laquo;Boolean&raquo;</span> set to false to disable causal consistency</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&lt;ClientSession&gt;&raquo;</span> promise that resolves to a MongoDB driver `ClientSession`</li></ul><div><p><em>Requires MongoDB >= 3.6.0.</em> Starts a <a href="https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions">MongoDB session</a> for benefits like causal consistency, <a href="https://docs.mongodb.com/manual/core/retryable-writes/">retryable writes</a>, and <a href="http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html">transactions</a>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> conn.startSession();
<span class="hljs-keyword">let</span> doc = <span class="hljs-keyword">await</span> Person.findOne({ name: <span class="hljs-string">'Ned Stark'</span> }, <span class="hljs-literal">null</span>, { session });
<span class="hljs-keyword">await</span> doc.remove();
<span class="hljs-comment">// `doc` will always be null, even if reading from a replica set</span>
<span class="hljs-comment">// secondary. Without causal consistency, it is possible to</span>
<span class="hljs-comment">// get a doc back from the below query if the query reads from a</span>
<span class="hljs-comment">// secondary that is experiencing replication lag.</span>
doc = <span class="hljs-keyword">await</span> Person.findOne({ name: <span class="hljs-string">'Ned Stark'</span> }, <span class="hljs-literal">null</span>, { session, readPreference: <span class="hljs-string">'secondary'</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="connection_Connection-useDb"><a href="#connection_Connection-useDb">Connection.prototype.useDb()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String&raquo;</span> The database name</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Connection&raquo;</span> New Connection Object</li></ul><div><p>Switches to a different database using the same connection pool.</p>

<p>Returns a new connection object, with the new db.</p></div><hr class="separate-api-elements"><h3 id="connection_Connection-user"><a href="#connection_Connection-user">Connection.prototype.user</a></h3><div><p>The username specified in the URI</p>

<h4>Example</h4>

<pre><code>mongoose.createConnection(<span class="hljs-string">'mongodb://val:psw@localhost:27017/mydb'</span>).user; <span class="hljs-comment">// "val"</span></code></pre></div><hr class="separate-api"><h2 id="Document"><a href="#Document">Document</a></h2><ul><li><a href="#document_Document-$ignore">Document.prototype.$ignore()</a></li><li><a href="#document_Document-$isDefault">Document.prototype.$isDefault()</a></li><li><a href="#document_Document-$isDeleted">Document.prototype.$isDeleted()</a></li><li><a href="#document_Document-$markValid">Document.prototype.$markValid()</a></li><li><a href="#document_Document-$session">Document.prototype.$session()</a></li><li><a href="#document_Document-$set">Document.prototype.$set()</a></li><li><a href="#document_Document-depopulate">Document.prototype.depopulate()</a></li><li><a href="#document_Document-equals">Document.prototype.equals()</a></li><li><a href="#document_Document-errors">Document.prototype.errors</a></li><li><a href="#document_Document-execPopulate">Document.prototype.execPopulate()</a></li><li><a href="#document_Document-get">Document.prototype.get()</a></li><li><a href="#document_Document-id">Document.prototype.id</a></li><li><a href="#document_Document-init">Document.prototype.init()</a></li><li><a href="#document_Document-inspect">Document.prototype.inspect()</a></li><li><a href="#document_Document-invalidate">Document.prototype.invalidate()</a></li><li><a href="#document_Document-isDirectModified">Document.prototype.isDirectModified()</a></li><li><a href="#document_Document-isDirectSelected">Document.prototype.isDirectSelected()</a></li><li><a href="#document_Document-isInit">Document.prototype.isInit()</a></li><li><a href="#document_Document-isModified">Document.prototype.isModified()</a></li><li><a href="#document_Document-isNew">Document.prototype.isNew</a></li><li><a href="#document_Document-isSelected">Document.prototype.isSelected()</a></li><li><a href="#document_Document-markModified">Document.prototype.markModified()</a></li><li><a href="#document_Document-modifiedPaths">Document.prototype.modifiedPaths()</a></li><li><a href="#document_Document-populate">Document.prototype.populate()</a></li><li><a href="#document_Document-populated">Document.prototype.populated()</a></li><li><a href="#document_Document-save">Document.prototype.save()</a></li><li><a href="#document_Document-schema">Document.prototype.schema</a></li><li><a href="#document_Document-set">Document.prototype.set()</a></li><li><a href="#document_Document-toJSON">Document.prototype.toJSON()</a></li><li><a href="#document_Document-toObject">Document.prototype.toObject()</a></li><li><a href="#document_Document-toString">Document.prototype.toString()</a></li><li><a href="#document_Document-unmarkModified">Document.prototype.unmarkModified()</a></li><li><a href="#document_Document-update">Document.prototype.update()</a></li><li><a href="#document_Document-validate">Document.prototype.validate()</a></li><li><a href="#document_Document-validateSync">Document.prototype.validateSync()</a></li></ul><hr class="separate-api-elements"><h3 id="document_Document-$ignore"><a href="#document_Document-$ignore">Document.prototype.$ignore()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> the path to ignore</li></ul><div><p>Don't run validation on this path or persist changes to this path.</p>

<h4>Example:</h4>

<pre><code>doc.foo = <span class="hljs-literal">null</span>;
doc.$ignore(<span class="hljs-string">'foo'</span>);
doc.save() <span class="hljs-comment">// changes to foo will not be persisted and validators won't be run</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-$isDefault"><a href="#document_Document-$isDefault">Document.prototype.$isDefault()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Checks if a path is set to its default.</p>

<h4>Example</h4>

<pre><code>MyModel = mongoose.model(<span class="hljs-string">'test'</span>, { name: { type: <span class="hljs-built_in">String</span>, <span class="hljs-keyword">default</span>: <span class="hljs-string">'Val '</span>} });
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> MyModel();
m.$isDefault(<span class="hljs-string">'name'</span>); <span class="hljs-comment">// true</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-$isDeleted"><a href="#document_Document-$isDeleted">Document.prototype.$isDeleted()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[val] <span class="method-type">&laquo;Boolean&raquo;</span> optional, overrides whether mongoose thinks the doc is deleted</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> whether mongoose thinks this doc is deleted.</li></ul><div><p>Getter/setter, determines whether the document was removed or not.</p>

<h4>Example:</h4>

<pre><code>product.remove(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
  product.isDeleted(); <span class="hljs-comment">// true</span>
  product.remove(); <span class="hljs-comment">// no-op, doesn't send anything to the db</span>

  product.isDeleted(<span class="hljs-literal">false</span>);
  product.isDeleted(); <span class="hljs-comment">// false</span>
  product.remove(); <span class="hljs-comment">// will execute a remove against the db</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-$markValid"><a href="#document_Document-$markValid">Document.prototype.$markValid()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> the field to mark as valid</li></ul><div><p>Marks a path as valid, removing existing validation errors.</p></div><hr class="separate-api-elements"><h3 id="document_Document-$session"><a href="#document_Document-$session">Document.prototype.$session()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[session] <span class="method-type">&laquo;ClientSession&raquo;</span> overwrite the current session</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;ClientSession&raquo;</span> </li></ul><div><p>Getter/setter around the session associated with this document. Used to automatically set <code>session</code> if you <code>save()</code> a doc that you got from a query with an associated session.</p></div><hr class="separate-api-elements"><h3 id="document_Document-$set"><a href="#document_Document-$set">Document.prototype.$set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String|Object&raquo;</span> path or object of key/vals to set</li><li class="param">val <span class="method-type">&laquo;Any&raquo;</span> the value to set</li><li class="param">[type] <span class="method-type">&laquo;Schema|String|Number|Buffer|*&raquo;</span> optionally specify a type for &quot;on-the-fly&quot; attributes</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optionally specify options that modify the behavior of the set</li></ul><div><p>Alias for <code>set()</code>, used internally to avoid conflicts</p></div><hr class="separate-api-elements"><h3 id="document_Document-depopulate"><a href="#document_Document-depopulate">Document.prototype.depopulate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Document&raquo;</span> this</li></ul><div><p>Takes a populated field and returns it to its unpopulated state.</p>

<h4>Example:</h4>

<pre><code>Model.findOne().populate(<span class="hljs-string">'author'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(doc.author.name); <span class="hljs-comment">// Dr.Seuss</span>
  <span class="hljs-built_in">console</span>.log(doc.depopulate(<span class="hljs-string">'author'</span>));
  <span class="hljs-built_in">console</span>.log(doc.author); <span class="hljs-comment">// '5144cf8050f071d979c118a7'</span>
})</code></pre>

<p>If the path was not populated, this is a no-op.</p></div><hr class="separate-api-elements"><h3 id="document_Document-equals"><a href="#document_Document-equals">Document.prototype.equals()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc <span class="method-type">&laquo;Document&raquo;</span> a document to compare</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Returns true if the Document stores the same data as doc.</p>

<p>Documents are considered equal when they have matching <code>_id</code>s, unless neither document has an <code>_id</code>, in which case this function falls back to using <code>deepEqual()</code>.</p></div><hr class="separate-api-elements"><h3 id="document_Document-errors"><a href="#document_Document-errors">Document.prototype.errors</a></h3><div><p>Hash containing current validation errors.</p></div><hr class="separate-api-elements"><h3 id="document_Document-execPopulate"><a href="#document_Document-execPopulate">Document.prototype.execPopulate()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> promise that resolves to the document when population is done</li></ul><div><p>Explicitly executes population and returns a promise. Useful for ES2015 integration.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> promise = doc.
  populate(<span class="hljs-string">'company'</span>).
  populate({
    path: <span class="hljs-string">'notes'</span>,
    match: <span class="hljs-regexp">/airline/</span>,
    select: <span class="hljs-string">'text'</span>,
    model: <span class="hljs-string">'modelName'</span>
    options: opts
  }).
  execPopulate();

<span class="hljs-comment">// summary</span>
doc.execPopulate().then(resolve, reject);</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-get"><a href="#document_Document-get">Document.prototype.get()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">[type] <span class="method-type">&laquo;Schema|String|Number|Buffer|*&raquo;</span> optionally specify a type for on-the-fly attributes</li></ul><div><p>Returns the value of a path.</p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// path</span>
doc.get(<span class="hljs-string">'age'</span>) <span class="hljs-comment">// 47</span>

<span class="hljs-comment">// dynamic casting to a string</span>
doc.get(<span class="hljs-string">'age'</span>, <span class="hljs-built_in">String</span>) <span class="hljs-comment">// "47"</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-id"><a href="#document_Document-id">Document.prototype.id</a></h3><div><p>The string version of this documents _id.</p>

<h4>Note:</h4>

<p>This getter exists on all documents by default. The getter can be disabled by setting the <code>id</code> <a href="/docs/guide.html#id">option</a> of its <code>Schema</code> to false at construction time.</p>

<pre><code><span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }, { id: <span class="hljs-literal">false</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-init"><a href="#document_Document-init">Document.prototype.init()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc <span class="method-type">&laquo;Object&raquo;</span> document returned by mongo</li></ul><div><p>Initializes the document without setters or marking anything modified.</p>

<p>Called internally after a document is returned from mongodb.</p></div><hr class="separate-api-elements"><h3 id="document_Document-inspect"><a href="#document_Document-inspect">Document.prototype.inspect()</a></h3><div><p>Helper for console.log</p></div><hr class="separate-api-elements"><h3 id="document_Document-invalidate"><a href="#document_Document-invalidate">Document.prototype.invalidate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> the field to invalidate</li><li class="param">errorMsg <span class="method-type">&laquo;String|Error&raquo;</span> the error which states the reason <code>path</code> was invalid</li><li class="param">value <span class="method-type">&laquo;Object|String|Number|any&raquo;</span> optional invalid value</li><li class="param">[kind] <span class="method-type">&laquo;String&raquo;</span> optional <code>kind</code> property for the error</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;ValidationError&raquo;</span> the current ValidationError, with all currently invalidated paths</li></ul><div><p>Marks a path as invalid, causing validation to fail.</p>

<p>The <code>errorMsg</code> argument will become the message of the <code>ValidationError</code>.</p>

<p>The <code>value</code> argument (if passed) will be available through the <code>ValidationError.value</code> property.</p>

<pre><code>doc.invalidate(<span class="hljs-string">'size'</span>, <span class="hljs-string">'must be less than 20'</span>, <span class="hljs-number">14</span>);

doc.validate(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-built_in">console</span>.log(err)
  <span class="hljs-comment">// prints</span>
  { message: <span class="hljs-string">'Validation failed'</span>,
    name: <span class="hljs-string">'ValidationError'</span>,
    errors:
     { size:
        { message: <span class="hljs-string">'must be less than 20'</span>,
          name: <span class="hljs-string">'ValidatorError'</span>,
          path: <span class="hljs-string">'size'</span>,
          type: <span class="hljs-string">'user defined'</span>,
          value: <span class="hljs-number">14</span> } } }
})</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-isDirectModified"><a href="#document_Document-isDirectModified">Document.prototype.isDirectModified()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Returns true if <code>path</code> was directly set and modified, else false.</p>

<h4>Example</h4>

<pre><code>doc.set(<span class="hljs-string">'documents.0.title'</span>, <span class="hljs-string">'changed'</span>);
doc.isDirectModified(<span class="hljs-string">'documents.0.title'</span>) <span class="hljs-comment">// true</span>
doc.isDirectModified(<span class="hljs-string">'documents'</span>) <span class="hljs-comment">// false</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-isDirectSelected"><a href="#document_Document-isDirectSelected">Document.prototype.isDirectSelected()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Checks if <code>path</code> was explicitly selected. If no projection, always returns true.</p>

<h4>Example</h4>

<pre><code>Thing.findOne().select(<span class="hljs-string">'nested.name'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
   doc.isDirectSelected(<span class="hljs-string">'nested.name'</span>) <span class="hljs-comment">// true</span>
   doc.isDirectSelected(<span class="hljs-string">'nested.otherName'</span>) <span class="hljs-comment">// false</span>
   doc.isDirectSelected(<span class="hljs-string">'nested'</span>)  <span class="hljs-comment">// false</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-isInit"><a href="#document_Document-isInit">Document.prototype.isInit()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Checks if <code>path</code> was initialized.</p></div><hr class="separate-api-elements"><h3 id="document_Document-isModified"><a href="#document_Document-isModified">Document.prototype.isModified()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> optional</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Returns true if this document was modified, else false.</p>

<p>If <code>path</code> is given, checks if a path or any full path containing <code>path</code> as part of its path chain has been modified.</p>

<h4>Example</h4>

<pre><code>doc.set(<span class="hljs-string">'documents.0.title'</span>, <span class="hljs-string">'changed'</span>);
doc.isModified()                      <span class="hljs-comment">// true</span>
doc.isModified(<span class="hljs-string">'documents'</span>)           <span class="hljs-comment">// true</span>
doc.isModified(<span class="hljs-string">'documents.0.title'</span>)   <span class="hljs-comment">// true</span>
doc.isModified(<span class="hljs-string">'documents otherProp'</span>) <span class="hljs-comment">// true</span>
doc.isDirectModified(<span class="hljs-string">'documents'</span>)     <span class="hljs-comment">// false</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-isNew"><a href="#document_Document-isNew">Document.prototype.isNew</a></h3><div><p>Boolean flag specifying if the document is new.</p></div><hr class="separate-api-elements"><h3 id="document_Document-isSelected"><a href="#document_Document-isSelected">Document.prototype.isSelected()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Checks if <code>path</code> was selected in the source query which initialized this document.</p>

<h4>Example</h4>

<pre><code>Thing.findOne().select(<span class="hljs-string">'name'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
   doc.isSelected(<span class="hljs-string">'name'</span>) <span class="hljs-comment">// true</span>
   doc.isSelected(<span class="hljs-string">'age'</span>)  <span class="hljs-comment">// false</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-markModified"><a href="#document_Document-markModified">Document.prototype.markModified()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> the path to mark modified</li><li class="param">[scope] <span class="method-type">&laquo;Document&raquo;</span> the scope to run validators with</li></ul><div><p>Marks the path as having pending changes to write to the db.</p>

<p><em>Very helpful when using <a href="./schematypes.html#mixed">Mixed</a> types.</em></p>

<h4>Example:</h4>

<pre><code>doc.mixed.type = <span class="hljs-string">'changed'</span>;
doc.markModified(<span class="hljs-string">'mixed.type'</span>);
doc.save() <span class="hljs-comment">// changes to mixed.type are now persisted</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-modifiedPaths"><a href="#document_Document-modifiedPaths">Document.prototype.modifiedPaths()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options.includeChildren=false] <span class="method-type">&laquo;Boolean&raquo;</span> if true, returns children of modified paths as well. For example, if false, the list of modified paths for <code>doc.colors = { primary: &#39;blue&#39; };</code> will <strong>not</strong> contain <code>colors.primary</code>. If true, <code>modifiedPaths()</code> will return an array that contains <code>colors.primary</code>.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Array&raquo;</span> </li></ul><div><p>Returns the list of paths that have been modified.</p></div><hr class="separate-api-elements"><h3 id="document_Document-populate"><a href="#document_Document-populate">Document.prototype.populate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String|Object&raquo;</span> The path to populate or an options object</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> When passed, population is invoked</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Document&raquo;</span> this</li></ul><div><p>Populates document references, executing the <code>callback</code> when complete. If you want to use promises instead, use this function with <a href="#document_Document-execPopulate"><code>execPopulate()</code></a></p>

<h4>Example:</h4>

<pre><code>doc
.populate(<span class="hljs-string">'company'</span>)
.populate({
  path: <span class="hljs-string">'notes'</span>,
  match: <span class="hljs-regexp">/airline/</span>,
  select: <span class="hljs-string">'text'</span>,
  model: <span class="hljs-string">'modelName'</span>
  options: opts
}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
  assert(doc._id === user._id) <span class="hljs-comment">// the document itself is passed</span>
})

<span class="hljs-comment">// summary</span>
doc.populate(path)                   <span class="hljs-comment">// not executed</span>
doc.populate(options);               <span class="hljs-comment">// not executed</span>
doc.populate(path, callback)         <span class="hljs-comment">// executed</span>
doc.populate(options, callback);     <span class="hljs-comment">// executed</span>
doc.populate(callback);              <span class="hljs-comment">// executed</span>
doc.populate(options).execPopulate() <span class="hljs-comment">// executed, returns promise</span></code></pre>

<h4>NOTE:</h4>

<p>Population does not occur unless a <code>callback</code> is passed <em>or</em> you explicitly call <code>execPopulate()</code>. Passing the same path a second time will overwrite the previous path options. See <a href="#model_Model.populate">Model.populate()</a> for explaination of options.</p></div><hr class="separate-api-elements"><h3 id="document_Document-populated"><a href="#document_Document-populated">Document.prototype.populated()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Array,ObjectId,Number,Buffer,String,undefined&raquo;</span> </li></ul><div><p>Gets _id(s) used during population of the given <code>path</code>.</p>

<h4>Example:</h4>

<pre><code>Model.findOne().populate(<span class="hljs-string">'author'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(doc.author.name)         <span class="hljs-comment">// Dr.Seuss</span>
  <span class="hljs-built_in">console</span>.log(doc.populated(<span class="hljs-string">'author'</span>)) <span class="hljs-comment">// '5144cf8050f071d979c118a7'</span>
})</code></pre>

<p>If the path was not populated, undefined is returned.</p></div><hr class="separate-api-elements"><h3 id="document_Document-save"><a href="#document_Document-save">Document.prototype.save()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> options optional options</li><li class="param">[options.safe] <span class="method-type">&laquo;Object&raquo;</span> overrides <a href="http://mongoosejs.com//docs/guide.html#safe">schema&#39;s safe option</a></li><li class="param">[options.validateBeforeSave] <span class="method-type">&laquo;Boolean&raquo;</span> set to false to save without validating.</li><li class="param">[fn] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise,undefined&raquo;</span> Returns undefined if used with callback or a Promise otherwise.</li></ul><div><p>Saves this document.</p>

<h4>Example:</h4>

<pre><code>product.sold = <span class="hljs-built_in">Date</span>.now();
product.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
})</code></pre>

<p>The callback will receive three parameters</p>

<ol>
<li><code>err</code> if an error occurred</li>
<li><code>product</code> which is the saved <code>product</code></li>
</ol>

<p>As an extra measure of flow control, save will return a Promise.</p>

<h4>Example:</h4>

<pre><code>product.save().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">product</span>) </span>{
   ...
});</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-schema"><a href="#document_Document-schema">Document.prototype.schema</a></h3><div><p>The documents schema.</p></div><hr class="separate-api-elements"><h3 id="document_Document-set"><a href="#document_Document-set">Document.prototype.set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String|Object&raquo;</span> path or object of key/vals to set</li><li class="param">val <span class="method-type">&laquo;Any&raquo;</span> the value to set</li><li class="param">[type] <span class="method-type">&laquo;Schema|String|Number|Buffer|*&raquo;</span> optionally specify a type for &quot;on-the-fly&quot; attributes</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optionally specify options that modify the behavior of the set</li></ul><div><p>Sets the value of a path, or many paths.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// path, value</span>
doc.set(path, value)

<span class="hljs-comment">// object</span>
doc.set({
    path  : value
  , path2 : {
       path  : value
    }
})

<span class="hljs-comment">// on-the-fly cast to number</span>
doc.set(path, value, <span class="hljs-built_in">Number</span>)

<span class="hljs-comment">// on-the-fly cast to string</span>
doc.set(path, value, <span class="hljs-built_in">String</span>)

<span class="hljs-comment">// changing strict mode behavior</span>
doc.set(path, value, { strict: <span class="hljs-literal">false</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-toJSON"><a href="#document_Document-toJSON">Document.prototype.toJSON()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>The return value of this method is used in calls to JSON.stringify(doc).</p>

<p>This method accepts the same options as <a href="#document_Document-toObject">Document#toObject</a>. To apply the options to every document of your schema by default, set your <a href="#schema_Schema">schemas</a> <code>toJSON</code> option to the same argument.</p>

<pre><code>schema.set(<span class="hljs-string">'toJSON'</span>, { virtuals: <span class="hljs-literal">true</span> })</code></pre>

<p>See <a href="/docs/guide.html#toJSON">schema options</a> for details.</p></div><hr class="separate-api-elements"><h3 id="document_Document-toObject"><a href="#document_Document-toObject">Document.prototype.toObject()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> js object</li></ul><div><p>Converts this document into a plain javascript object, ready for storage in MongoDB.</p>

<p>Buffers are converted to instances of <a href="http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html">mongodb.Binary</a> for proper storage.</p>

<h4>Options:</h4>

<ul>
<li><code>getters</code> apply all getters (path and virtual getters)</li>
<li><code>virtuals</code> apply virtual getters (can override <code>getters</code> option)</li>
<li><code>minimize</code> remove empty objects (defaults to true)</li>
<li><code>transform</code> a transform function to apply to the resulting document before returning</li>
<li><code>depopulate</code> depopulate any populated paths, replacing them with their original refs (defaults to false)</li>
<li><code>versionKey</code> whether to include the version key (defaults to true)</li>
</ul>

<h4>Getters/Virtuals</h4>

<p>Example of only applying path getters</p>

<pre><code>doc.toObject({ getters: <span class="hljs-literal">true</span>, virtuals: <span class="hljs-literal">false</span> })</code></pre>

<p>Example of only applying virtual getters</p>

<pre><code>doc.toObject({ virtuals: <span class="hljs-literal">true</span> })</code></pre>

<p>Example of applying both path and virtual getters</p>

<pre><code>doc.toObject({ getters: <span class="hljs-literal">true</span> })</code></pre>

<p>To apply these options to every document of your schema by default, set your <a href="#schema_Schema">schemas</a> <code>toObject</code> option to the same argument.</p>

<pre><code>schema.set(<span class="hljs-string">'toObject'</span>, { virtuals: <span class="hljs-literal">true</span> })</code></pre>

<h4>Transform</h4>

<p>We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional <code>transform</code> function.</p>

<p>Transform functions receive three arguments</p>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, ret, options</span>) </span>{}</code></pre>

<ul>
<li><code>doc</code> The mongoose document which is being converted</li>
<li><code>ret</code> The plain object representation which has been converted</li>
<li><code>options</code> The options in use (either schema options or the options passed inline)</li>
</ul>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// specify the transform schema option</span>
<span class="hljs-keyword">if</span> (!schema.options.toObject) schema.options.toObject = {};
schema.options.toObject.transform = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, ret, options</span>) </span>{
  <span class="hljs-comment">// remove the _id of every document before returning the result</span>
  <span class="hljs-keyword">delete</span> ret._id;
  <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-comment">// without the transformation in the schema</span>
doc.toObject(); <span class="hljs-comment">// { _id: 'anId', name: 'Wreck-it Ralph' }</span>

<span class="hljs-comment">// with the transformation</span>
doc.toObject(); <span class="hljs-comment">// { name: 'Wreck-it Ralph' }</span></code></pre>

<p>With transformations we can do a lot more than remove properties. We can even return completely new customized objects:</p>

<pre><code><span class="hljs-keyword">if</span> (!schema.options.toObject) schema.options.toObject = {};
schema.options.toObject.transform = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, ret, options</span>) </span>{
  <span class="hljs-keyword">return</span> { movie: ret.name }
}

<span class="hljs-comment">// without the transformation in the schema</span>
doc.toObject(); <span class="hljs-comment">// { _id: 'anId', name: 'Wreck-it Ralph' }</span>

<span class="hljs-comment">// with the transformation</span>
doc.toObject(); <span class="hljs-comment">// { movie: 'Wreck-it Ralph' }</span></code></pre>

<p><em>Note: if a transform function returns <code>undefined</code>, the return value will be ignored.</em></p>

<p>Transformations may also be applied inline, overridding any transform set in the options:</p>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xform</span> (<span class="hljs-params">doc, ret, options</span>) </span>{
  <span class="hljs-keyword">return</span> { inline: ret.name, custom: <span class="hljs-literal">true</span> }
}

<span class="hljs-comment">// pass the transform as an inline option</span>
doc.toObject({ transform: xform }); <span class="hljs-comment">// { inline: 'Wreck-it Ralph', custom: true }</span></code></pre>

<p>If you want to skip transformations, use <code>transform: false</code>:</p>

<pre><code><span class="hljs-keyword">if</span> (!schema.options.toObject) schema.options.toObject = {};
schema.options.toObject.hide = <span class="hljs-string">'_id'</span>;
schema.options.toObject.transform = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, ret, options</span>) </span>{
  <span class="hljs-keyword">if</span> (options.hide) {
    options.hide.split(<span class="hljs-string">' '</span>).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prop</span>) </span>{
      <span class="hljs-keyword">delete</span> ret[prop];
    });
  }
  <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">new</span> Doc({ _id: <span class="hljs-string">'anId'</span>, secret: <span class="hljs-number">47</span>, name: <span class="hljs-string">'Wreck-it Ralph'</span> });
doc.toObject();                                        <span class="hljs-comment">// { secret: 47, name: 'Wreck-it Ralph' }</span>
doc.toObject({ hide: <span class="hljs-string">'secret _id'</span>, transform: <span class="hljs-literal">false</span> });<span class="hljs-comment">// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }</span>
doc.toObject({ hide: <span class="hljs-string">'secret _id'</span>, transform: <span class="hljs-literal">true</span> }); <span class="hljs-comment">// { name: 'Wreck-it Ralph' }</span></code></pre>

<p>Transforms are applied <em>only to the document and are not applied to sub-documents</em>.</p>

<p>Transforms, like all of these options, are also available for <code>toJSON</code>.</p>

<p>See <a href="/docs/guide.html#toObject">schema options</a> for some more details.</p>

<p><em>During save, no custom options are applied to the document before being sent to the database.</em></p></div><hr class="separate-api-elements"><h3 id="document_Document-toString"><a href="#document_Document-toString">Document.prototype.toString()</a></h3><div><p>Helper for console.log</p></div><hr class="separate-api-elements"><h3 id="document_Document-unmarkModified"><a href="#document_Document-unmarkModified">Document.prototype.unmarkModified()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> the path to unmark modified</li></ul><div><p>Clears the modified state on the specified path.</p>

<h4>Example:</h4>

<pre><code>doc.foo = <span class="hljs-string">'bar'</span>;
doc.unmarkModified(<span class="hljs-string">'foo'</span>);
doc.save() <span class="hljs-comment">// changes to foo will not be persisted</span></code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-update"><a href="#document_Document-update">Document.prototype.update()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Sends an update command with this document <code>_id</code> as the query selector.</p>

<h4>Example:</h4>

<pre><code>weirdCar.update({$inc: {wheels:<span class="hljs-number">1</span>}}, { w: <span class="hljs-number">1</span> }, callback);</code></pre>

<h4>Valid options:</h4>

<ul>
<li>same as in <a href="#model_Model.update">Model.update</a></li>
</ul></div><hr class="separate-api-elements"><h3 id="document_Document-validate"><a href="#document_Document-validate">Document.prototype.validate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">optional <span class="method-type">&laquo;Object&raquo;</span> options internal options</li><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> optional callback called after validation completes, passing an error if one occurred</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> Promise</li></ul><div><p>Executes registered validation rules for this document.</p>

<h4>Note:</h4>

<p>This method is called <code>pre</code> save and if a validation rule is violated, <a href="#model_Model-save">save</a> is aborted and the error is returned to your <code>callback</code>.</p>

<h4>Example:</h4>

<pre><code>doc.validate(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) handleError(err);
  <span class="hljs-keyword">else</span> <span class="hljs-comment">// validation passed</span>
});</code></pre></div><hr class="separate-api-elements"><h3 id="document_Document-validateSync"><a href="#document_Document-validateSync">Document.prototype.validateSync()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">pathsToValidate <span class="method-type">&laquo;Array|string&raquo;</span> only validate the given paths</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;MongooseError,undefined&raquo;</span> MongooseError if there are errors during validation, or undefined if there is no error.</li></ul><div><p>Executes registered validation rules (skipping asynchronous validators) for this document.</p>

<h4>Note:</h4>

<p>This method is useful if you need synchronous validation.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> err = doc.validateSync();
<span class="hljs-keyword">if</span> ( err ){
  handleError( err );
} <span class="hljs-keyword">else</span> {
  <span class="hljs-comment">// validation passed</span>
}</code></pre></div><hr class="separate-api"><h2 id="Model"><a href="#Model">Model</a></h2><ul><li><a href="#model_Model">Model()</a></li><li><a href="#model_Model.aggregate">Model.aggregate()</a></li><li><a href="#model_Model.bulkWrite">Model.bulkWrite()</a></li><li><a href="#model_Model.count">Model.count()</a></li><li><a href="#model_Model.countDocuments">Model.countDocuments()</a></li><li><a href="#model_Model.create">Model.create()</a></li><li><a href="#model_Model.createIndexes">Model.createIndexes()</a></li><li><a href="#model_Model.deleteMany">Model.deleteMany()</a></li><li><a href="#model_Model.deleteOne">Model.deleteOne()</a></li><li><a href="#model_Model.discriminator">Model.discriminator()</a></li><li><a href="#model_Model.distinct">Model.distinct()</a></li><li><a href="#model_Model.ensureIndexes">Model.ensureIndexes()</a></li><li><a href="#model_Model.estimatedDocumentCount">Model.estimatedDocumentCount()</a></li><li><a href="#model_Model.find">Model.find()</a></li><li><a href="#model_Model.findById">Model.findById()</a></li><li><a href="#model_Model.findByIdAndDelete">Model.findByIdAndDelete()</a></li><li><a href="#model_Model.findByIdAndRemove">Model.findByIdAndRemove()</a></li><li><a href="#model_Model.findByIdAndUpdate">Model.findByIdAndUpdate()</a></li><li><a href="#model_Model.findOne">Model.findOne()</a></li><li><a href="#model_Model.findOneAndDelete">Model.findOneAndDelete()</a></li><li><a href="#model_Model.findOneAndRemove">Model.findOneAndRemove()</a></li><li><a href="#model_Model.findOneAndUpdate">Model.findOneAndUpdate()</a></li><li><a href="#model_Model.geoSearch">Model.geoSearch()</a></li><li><a href="#model_Model.hydrate">Model.hydrate()</a></li><li><a href="#model_Model.init">Model.init()</a></li><li><a href="#model_Model.insertMany">Model.insertMany()</a></li><li><a href="#model_Model.listIndexes">Model.listIndexes()</a></li><li><a href="#model_Model.mapReduce">Model.mapReduce()</a></li><li><a href="#model_Model.populate">Model.populate()</a></li><li><a href="#model_Model-$where">Model.prototype.$where</a></li><li><a href="#model_Model-$where">Model.prototype.$where()</a></li><li><a href="#model_Model-base">Model.prototype.base</a></li><li><a href="#model_Model-baseModelName">Model.prototype.baseModelName</a></li><li><a href="#model_Model-collection">Model.prototype.collection</a></li><li><a href="#model_Model-db">Model.prototype.db</a></li><li><a href="#model_Model-discriminators">Model.prototype.discriminators</a></li><li><a href="#model_Model-increment">Model.prototype.increment()</a></li><li><a href="#model_Model-model">Model.prototype.model()</a></li><li><a href="#model_Model-modelName">Model.prototype.modelName</a></li><li><a href="#model_Model-remove">Model.prototype.remove()</a></li><li><a href="#model_Model-save">Model.prototype.save()</a></li><li><a href="#model_Model-schema">Model.prototype.schema</a></li><li><a href="#model_Model.remove">Model.remove()</a></li><li><a href="#model_Model.replaceOne">Model.replaceOne()</a></li><li><a href="#model_Model.startSession">Model.startSession()</a></li><li><a href="#model_Model.syncIndexes">Model.syncIndexes()</a></li><li><a href="#model_Model.translateAliases">Model.translateAliases()</a></li><li><a href="#model_Model.update">Model.update()</a></li><li><a href="#model_Model.updateMany">Model.updateMany()</a></li><li><a href="#model_Model.updateOne">Model.updateOne()</a></li><li><a href="#model_Model.watch">Model.watch()</a></li><li><a href="#model_Model.where">Model.where()</a></li></ul><hr class="separate-api-elements"><h3 id="model_Model"><a href="#model_Model">Model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc <span class="method-type">&laquo;Object&raquo;</span> values with which to create the document</li></ul><div><p>Model constructor</p>

<p>Provides the interface to MongoDB collections as well as creates document instances.</p></div><hr class="separate-api-elements"><h3 id="model_Model.aggregate"><a href="#model_Model.aggregate">Model.aggregate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[pipeline] <span class="method-type">&laquo;Array&raquo;</span> aggregation pipeline as an array of objects</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Performs <a href="http://docs.mongodb.org/manual/applications/aggregation/">aggregations</a> on the models collection.</p>

<p>If a <code>callback</code> is passed, the <code>aggregate</code> is executed and a <code>Promise</code> is returned. If a callback is not passed, the <code>aggregate</code> itself is returned.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Find the max balance of all accounts</span>
Users.aggregate([
  { $group: { _id: <span class="hljs-literal">null</span>, maxBalance: { $max: <span class="hljs-string">'$balance'</span> }}},
  { $project: { _id: <span class="hljs-number">0</span>, maxBalance: <span class="hljs-number">1</span> }}
]).
then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
  <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// [ { maxBalance: 98000 } ]</span>
});

<span class="hljs-comment">// Or use the aggregation pipeline builder.</span>
Users.aggregate().
  group({ _id: <span class="hljs-literal">null</span>, maxBalance: { $max: <span class="hljs-string">'$balance'</span> } }).
  project(<span class="hljs-string">'-id maxBalance'</span>).
  exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, res</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
    <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// [ { maxBalance: 98 } ]</span>
  });</code></pre>

<h4>NOTE:</h4>

<ul>
<li>Arguments are not cast to the model's schema because <code>$project</code> operators allow redefining the "shape" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.</li>
<li>The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).</li>
<li>Requires MongoDB >= 2.1</li>
</ul></div><hr class="separate-api-elements"><h3 id="model_Model.bulkWrite"><a href="#model_Model.bulkWrite">Model.bulkWrite()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">ops <span class="method-type">&laquo;Array&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> callback <code>function(error, bulkWriteOpResult) {}</code></li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> resolves to a `BulkWriteOpResult` if the operation succeeds</li></ul><div><p>Sends multiple <code>insertOne</code>, <code>updateOne</code>, <code>updateMany</code>, <code>replaceOne</code>, <code>deleteOne</code>, and/or <code>deleteMany</code> operations to the MongoDB server in one command. This is faster than sending multiple independent operations (like) if you use <code>create()</code>) because with <code>bulkWrite()</code> there is only one round trip to MongoDB.</p>

<p>Mongoose will perform casting on all operations you provide.</p>

<p>This function does <strong>not</strong> trigger any middleware, not <code>save()</code> nor <code>update()</code>. If you need to trigger <code>save()</code> middleware for every document use <a href="http://mongoosejs.com/docs/api.html#model_Model.create"><code>create()</code></a> instead.</p>

<h4>Example:</h4>

<pre><code>Character.bulkWrite([
  {
    insertOne: {
      <span class="hljs-built_in">document</span>: {
        name: <span class="hljs-string">'Eddard Stark'</span>,
        title: <span class="hljs-string">'Warden of the North'</span>
      }
    }
  },
  {
    updateOne: {
      filter: { name: <span class="hljs-string">'Eddard Stark'</span> },
      <span class="hljs-comment">// If you were using the MongoDB driver directly, you'd need to do</span>
      <span class="hljs-comment">// `update: { $set: { title: ... } }` but mongoose adds $set for</span>
      <span class="hljs-comment">// you.</span>
      update: { title: <span class="hljs-string">'Hand of the King'</span> }
    }
  },
  {
    deleteOne: {
      {
        filter: { name: <span class="hljs-string">'Eddard Stark'</span> }
      }
    }
  }
]).then(handleResult);</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.count"><a href="#model_Model.count">Model.count()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Counts number of matching documents in a database collection. This method is deprecated, use <code>countDocuments()</code> instead.</p>

<h4>Example:</h4>

<pre><code>Adventure.count({ type: <span class="hljs-string">'jungle'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, count</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there are %d jungle adventures'</span>, count);
});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.countDocuments"><a href="#model_Model.countDocuments">Model.countDocuments()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Counts number of matching documents in a database collection.</p>

<h4>Example:</h4>

<pre><code>Adventure.countDocuments({ type: <span class="hljs-string">'jungle'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, count</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there are %d jungle adventures'</span>, count);
});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.create"><a href="#model_Model.create">Model.create()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">docs <span class="method-type">&laquo;Array|Object&raquo;</span> Documents to insert, as a spread or array</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> Options passed down to <code>save()</code>. To specify <code>options</code>, <code>docs</code> <strong>must</strong> be an array, not a spread.</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Shortcut for saving one or more documents to the database. <code>MyModel.create(docs)</code> does <code>new MyModel(doc).save()</code> for every doc in docs.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>save()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// pass a spread of docs and a callback</span>
Candy.create({ type: <span class="hljs-string">'jelly bean'</span> }, { type: <span class="hljs-string">'snickers'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, jellybean, snickers</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-comment">// ...</span>
});

<span class="hljs-comment">// pass an array of docs</span>
<span class="hljs-keyword">var</span> array = [{ type: <span class="hljs-string">'jelly bean'</span> }, { type: <span class="hljs-string">'snickers'</span> }];
Candy.create(array, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, candies</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">var</span> jellybean = candies[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> snickers = candies[<span class="hljs-number">1</span>];
  <span class="hljs-comment">// ...</span>
});

<span class="hljs-comment">// callback is optional; use the returned promise if you like:</span>
<span class="hljs-keyword">var</span> promise = Candy.create({ type: <span class="hljs-string">'jawbreaker'</span> });
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">jawbreaker</span>) </span>{
  <span class="hljs-comment">// ...</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.createIndexes"><a href="#model_Model.createIndexes">Model.createIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> internal options</li><li class="param">[cb] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Similar to <code>ensureIndexes()</code>, except for it uses the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#createIndex"><code>createIndex</code></a> function. The <code>ensureIndex()</code> function checks to see if an index with that name already exists, and, if not, does not attempt to create the index. <code>createIndex()</code> bypasses this check.</p></div><hr class="separate-api-elements"><h3 id="model_Model.deleteMany"><a href="#model_Model.deleteMany">Model.deleteMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Deletes all of the documents that match <code>conditions</code> from the collection. Behaves like <code>remove()</code>, but deletes all documents that match <code>conditions</code> regardless of the <code>single</code> option.</p>

<h4>Example:</h4>

<pre><code>Character.deleteMany({ name: <span class="hljs-regexp">/Stark/</span>, age: { $gte: <span class="hljs-number">18</span> } }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>Like <code>Model.remove()</code>, this function does <strong>not</strong> trigger <code>pre('remove')</code> or <code>post('remove')</code> hooks.</p></div><hr class="separate-api-elements"><h3 id="model_Model.deleteOne"><a href="#model_Model.deleteOne">Model.deleteOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Deletes the first document that matches <code>conditions</code> from the collection. Behaves like <code>remove()</code>, but deletes at most one document regardless of the <code>single</code> option.</p>

<h4>Example:</h4>

<pre><code>Character.deleteOne({ name: <span class="hljs-string">'Eddard Stark'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>Like <code>Model.remove()</code>, this function does <strong>not</strong> trigger <code>pre('remove')</code> or <code>post('remove')</code> hooks.</p></div><hr class="separate-api-elements"><h3 id="model_Model.discriminator"><a href="#model_Model.discriminator">Model.discriminator()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String&raquo;</span> discriminator model name</li><li class="param">schema <span class="method-type">&laquo;Schema&raquo;</span> discriminator model schema</li><li class="param">value <span class="method-type">&laquo;String&raquo;</span> the string stored in the <code>discriminatorKey</code> property</li></ul><div><p>Adds a discriminator type.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BaseSchema</span>(<span class="hljs-params"></span>) </span>{
  Schema.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

  <span class="hljs-keyword">this</span>.add({
    name: <span class="hljs-built_in">String</span>,
    createdAt: <span class="hljs-built_in">Date</span>
  });
}
util.inherits(BaseSchema, Schema);

<span class="hljs-keyword">var</span> PersonSchema = <span class="hljs-keyword">new</span> BaseSchema();
<span class="hljs-keyword">var</span> BossSchema = <span class="hljs-keyword">new</span> BaseSchema({ department: <span class="hljs-built_in">String</span> });

<span class="hljs-keyword">var</span> Person = mongoose.model(<span class="hljs-string">'Person'</span>, PersonSchema);
<span class="hljs-keyword">var</span> Boss = Person.discriminator(<span class="hljs-string">'Boss'</span>, BossSchema);
<span class="hljs-keyword">new</span> Boss().__t; <span class="hljs-comment">// "Boss". `__t` is the default `discriminatorKey`</span>

<span class="hljs-keyword">var</span> employeeSchema = <span class="hljs-keyword">new</span> Schema({ boss: ObjectId });
<span class="hljs-keyword">var</span> Employee = Person.discriminator(<span class="hljs-string">'Employee'</span>, employeeSchema, <span class="hljs-string">'staff'</span>);
<span class="hljs-keyword">new</span> Employee().__t; <span class="hljs-comment">// "staff" because of 3rd argument above</span></code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.distinct"><a href="#model_Model.distinct">Model.distinct()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">field <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">[conditions] <span class="method-type">&laquo;Object&raquo;</span> optional</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a Query for a <code>distinct</code> operation.</p>

<p>Passing a <code>callback</code> immediately executes the query.</p>

<h4>Example</h4>

<pre><code>Link.distinct(<span class="hljs-string">'url'</span>, { clicks: {$gt: <span class="hljs-number">100</span>}}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);

  assert(<span class="hljs-built_in">Array</span>.isArray(result));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'unique urls with more than 100 clicks'</span>, result);
})

<span class="hljs-keyword">var</span> query = Link.distinct(<span class="hljs-string">'url'</span>);
query.exec(callback);</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.ensureIndexes"><a href="#model_Model.ensureIndexes">Model.ensureIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> internal options</li><li class="param">[cb] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Sends <code>createIndex</code> commands to mongo for each index declared in the schema. The <code>createIndex</code> commands are sent in series.</p>

<h4>Example:</h4>

<pre><code>Event.ensureIndexes(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
});</code></pre>

<p>After completion, an <code>index</code> event is emitted on this <code>Model</code> passing an error if one occurred.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> eventSchema = <span class="hljs-keyword">new</span> Schema({ thing: { type: <span class="hljs-string">'string'</span>, unique: <span class="hljs-literal">true</span> }})
<span class="hljs-keyword">var</span> Event = mongoose.model(<span class="hljs-string">'Event'</span>, eventSchema);

Event.on(<span class="hljs-string">'index'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err); <span class="hljs-comment">// error occurred during index creation</span>
})</code></pre>

<p><em>NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.</em></p></div><hr class="separate-api-elements"><h3 id="model_Model.estimatedDocumentCount"><a href="#model_Model.estimatedDocumentCount">Model.estimatedDocumentCount()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Estimates the number of documents in the MongoDB collection. Faster than using <code>countDocuments()</code> for large collections because <code>estimatedDocumentCount()</code> uses collection metadata rather than scanning the entire collection.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> numAdventures = Adventure.estimatedDocumentCount();</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.find"><a href="#model_Model.find">Model.find()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[projection] <span class="method-type">&laquo;Object|String&raquo;</span> optional fields to return, see <a href="#query_Query-select"><code>Query.prototype.select()</code></a></li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds documents</p>

<p>The <code>conditions</code> are cast to their respective SchemaTypes before the command is sent.</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// named john and at least 18</span>
MyModel.find({ name: <span class="hljs-string">'john'</span>, age: { $gte: <span class="hljs-number">18</span> }});

<span class="hljs-comment">// executes immediately, passing results to callback</span>
MyModel.find({ name: <span class="hljs-string">'john'</span>, age: { $gte: <span class="hljs-number">18</span> }}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// name LIKE john and only selecting the "name" and "friends" fields, executing immediately</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-string">'name friends'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{ })

<span class="hljs-comment">// passing options</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> })

<span class="hljs-comment">// passing options and executing immediately</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// executing a query explicitly</span>
<span class="hljs-keyword">var</span> query = MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> })
query.exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// using the promise returned from executing a query</span>
<span class="hljs-keyword">var</span> query = MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> });
<span class="hljs-keyword">var</span> promise = query.exec();
promise.addBack(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.findById"><a href="#model_Model.findById">Model.findById()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">id <span class="method-type">&laquo;Object|String|Number&raquo;</span> value of <code>_id</code> to query by</li><li class="param">[projection] <span class="method-type">&laquo;Object|String&raquo;</span> optional fields to return, see <a href="#query_Query-select"><code>Query.prototype.select()</code></a></li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds a single document by its _id field. <code>findById(id)</code> is almost* equivalent to <code>findOne({ _id: id })</code>. If you want to query by a document's <code>_id</code>, use <code>findById()</code> instead of <code>findOne()</code>.</p>

<p>The <code>id</code> is cast based on the Schema before sending the command.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOne()</code></li>
</ul>

<p>* Except for how it treats <code>undefined</code>. If you use <code>findOne()</code>, you'll see that <code>findOne(undefined)</code> and <code>findOne({ _id: undefined })</code> are equivalent to <code>findOne({})</code> and return arbitrary documents. However, mongoose translates <code>findById(undefined)</code> into <code>findOne({ _id: null })</code>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// find adventure by id and execute immediately</span>
Adventure.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id).exec(callback);

<span class="hljs-comment">// select only the adventures name and length</span>
Adventure.findById(id, <span class="hljs-string">'name length'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id, <span class="hljs-string">'name length'</span>).exec(callback);

<span class="hljs-comment">// include all properties except for `length`</span>
Adventure.findById(id, <span class="hljs-string">'-length'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// passing options (in this case return the raw js objects, not mongoose documents by passing `lean`</span>
Adventure.findById(id, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id, <span class="hljs-string">'name'</span>).lean().exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.findByIdAndDelete"><a href="#model_Model.findByIdAndDelete">Model.findByIdAndDelete()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">id <span class="method-type">&laquo;Object|Number|String&raquo;</span> value of <code>_id</code> to query by</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a MongoDB <code>findOneAndDelete()</code> command by a document's _id field. In other words, <code>findByIdAndDelete(id)</code> is a shorthand for <code>findOneAndDelete({ _id: id })</code>.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndDelete()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="model_Model.findByIdAndRemove"><a href="#model_Model.findByIdAndRemove">Model.findByIdAndRemove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">id <span class="method-type">&laquo;Object|Number|String&raquo;</span> value of <code>_id</code> to query by</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a mongodb findAndModify remove command by a document's _id field. <code>findByIdAndRemove(id, ...)</code> is equivalent to <code>findOneAndRemove({ _id: id }, ...)</code>.</p>

<p>Finds a matching document, removes it, passing the found document (if any) to the callback.</p>

<p>Executes immediately if <code>callback</code> is passed, else a <code>Query</code> object is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndRemove()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findByIdAndRemove(id, options, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndRemove(id, options)  <span class="hljs-comment">// return Query</span>
A.findByIdAndRemove(id, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndRemove(id) <span class="hljs-comment">// returns Query</span>
A.findByIdAndRemove()           <span class="hljs-comment">// returns Query</span></code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.findByIdAndUpdate"><a href="#model_Model.findByIdAndUpdate">Model.findByIdAndUpdate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">id <span class="method-type">&laquo;Object|Number|String&raquo;</span> value of <code>_id</code> to query by</li><li class="param">[update] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[options.lean] <span class="method-type">&laquo;Object&raquo;</span> if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See <a href="http://mongoosejs.com/docs/api.html#query_Query-lean"><code>Query.lean()</code></a>.</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issues a mongodb findAndModify update command by a document's _id field. <code>findByIdAndUpdate(id, ...)</code> is equivalent to <code>findOneAndUpdate({ _id: id }, ...)</code>.</p>

<p>Finds a matching document, updates it according to the <code>update</code> arg, passing any <code>options</code>, and returns the found document (if any) to the callback. The query executes immediately if <code>callback</code> is passed else a Query object is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndUpdate()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>new</code>: bool - true to return the modified document rather than the original. defaults to false</li>
<li><code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findByIdAndUpdate(id, update, options, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndUpdate(id, update, options)  <span class="hljs-comment">// returns Query</span>
A.findByIdAndUpdate(id, update, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndUpdate(id, update)           <span class="hljs-comment">// returns Query</span>
A.findByIdAndUpdate()                     <span class="hljs-comment">// returns Query</span></code></pre>

<h4>Note:</h4>

<p>All top level update keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code>Model.findByIdAndUpdate(id, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.findByIdAndUpdate(id, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)</code></pre>

<p>This helps prevent accidentally overwriting your document with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.findOne"><a href="#model_Model.findOne">Model.findOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[conditions] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[projection] <span class="method-type">&laquo;Object|String&raquo;</span> optional fields to return, see <a href="#query_Query-select"><code>Query.prototype.select()</code></a></li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds one document.</p>

<p>The <code>conditions</code> are cast to their respective SchemaTypes before the command is sent.</p>

<p><em>Note:</em> <code>conditions</code> is optional, and if <code>conditions</code> is null or undefined, mongoose will send an empty <code>findOne</code> command to MongoDB, which will return an arbitrary document. If you're querying by <code>_id</code>, use <code>findById()</code> instead.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// find one iphone adventures - iphone adventures??</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// select only the adventures name</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// specify options, in this case lean</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }, callback);

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }).exec(callback);

<span class="hljs-comment">// chaining findOne queries (same as above)</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }).select(<span class="hljs-string">'name'</span>).lean().exec(callback);</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.findOneAndDelete"><a href="#model_Model.findOneAndDelete">Model.findOneAndDelete()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a MongoDB <code>findOneAndDelete()</code> command.</p>

<p>Finds a matching document, removes it, and passes the found document (if any) to the callback.</p>

<p>Executes immediately if <code>callback</code> is passed else a Query object is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndDelete()</code></li>
</ul>

<p>This function differs slightly from <code>Model.findOneAndRemove()</code> in that <code>findOneAndRemove()</code> becomes a <a href="https://docs.mongodb.com/manual/reference/method/db.collection.findAndModify/">MongoDB <code>findAndModify()</code> command</a>, as opposed to a <code>findOneAndDelete()</code> command. For most mongoose use cases, this distinction is purely pedantic. You should use <code>findOneAndDelete()</code> unless you have a good reason not to.</p>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>projection</code>: like select, it determines which fields to return, ex. <code>{ projection: { _id: 0 } }</code></li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndDelete(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndDelete(conditions, options)  <span class="hljs-comment">// return Query</span>
A.findOneAndDelete(conditions, callback) <span class="hljs-comment">// executes</span>
A.findOneAndDelete(conditions) <span class="hljs-comment">// returns Query</span>
A.findOneAndDelete()           <span class="hljs-comment">// returns Query</span></code></pre>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.findOneAndRemove"><a href="#model_Model.findOneAndRemove">Model.findOneAndRemove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a mongodb findAndModify remove command.</p>

<p>Finds a matching document, removes it, passing the found document (if any) to the callback.</p>

<p>Executes immediately if <code>callback</code> is passed else a Query object is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndRemove()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>projection</code>: like select, it determines which fields to return, ex. <code>{ projection: { _id: 0 } }</code></li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndRemove(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndRemove(conditions, options)  <span class="hljs-comment">// return Query</span>
A.findOneAndRemove(conditions, callback) <span class="hljs-comment">// executes</span>
A.findOneAndRemove(conditions) <span class="hljs-comment">// returns Query</span>
A.findOneAndRemove()           <span class="hljs-comment">// returns Query</span></code></pre>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.findOneAndUpdate"><a href="#model_Model.findOneAndUpdate">Model.findOneAndUpdate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[conditions] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[update] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[options.lean] <span class="method-type">&laquo;Object&raquo;</span> if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See <a href="http://mongoosejs.com/docs/api.html#query_Query-lean"><code>Query.lean()</code></a>.</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issues a mongodb findAndModify update command.</p>

<p>Finds a matching document, updates it according to the <code>update</code> arg, passing any <code>options</code>, and returns the found document (if any) to the callback. The query executes immediately if <code>callback</code> is passed else a Query object is returned.</p>

<h4>Options:</h4>

<ul>
<li><code>new</code>: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)</li>
<li><code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.</li>
<li><code>fields</code>: {Object|String} - Field selection. Equivalent to <code>.select(fields).findOneAndUpdate()</code></li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndUpdate(conditions, update, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndUpdate(conditions, update, options)  <span class="hljs-comment">// returns Query</span>
A.findOneAndUpdate(conditions, update, callback) <span class="hljs-comment">// executes</span>
A.findOneAndUpdate(conditions, update)           <span class="hljs-comment">// returns Query</span>
A.findOneAndUpdate()                             <span class="hljs-comment">// returns Query</span></code></pre>

<h4>Note:</h4>

<p>All top level update keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> query = { name: <span class="hljs-string">'borne'</span> };
Model.findOneAndUpdate(query, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.findOneAndUpdate(query, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)</code></pre>

<p>This helps prevent accidentally overwriting your document with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.geoSearch"><a href="#model_Model.geoSearch">Model.geoSearch()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> an object that specifies the match condition (required)</li><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> for the geoSearch, some (near, maxDistance) are required</li><li class="param">[options.lean] <span class="method-type">&laquo;Object&raquo;</span> if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See <a href="http://mongoosejs.com/docs/api.html#query_Query-lean"><code>Query.lean()</code></a>.</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Implements <code>$geoSearch</code> functionality for Mongoose</p>

<p>This function does not trigger any middleware</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> options = { near: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], maxDistance: <span class="hljs-number">5</span> };
Locations.geoSearch({ type : <span class="hljs-string">"house"</span> }, options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>) </span>{
  <span class="hljs-built_in">console</span>.log(res);
});</code></pre>

<h4>Options:</h4>

<ul>
<li><code>near</code> {Array} x,y point to search for</li>
<li><code>maxDistance</code> {Number} the maximum distance from the point near that a result can be</li>
<li><code>limit</code> {Number} The maximum number of results to return</li>
<li><code>lean</code> {Boolean} return the raw object instead of the Mongoose Model</li>
</ul></div><hr class="separate-api-elements"><h3 id="model_Model.hydrate"><a href="#model_Model.hydrate">Model.hydrate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">obj <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Model&raquo;</span> document instance</li></ul><div><p>Shortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// hydrate previous data into a Mongoose document</span>
<span class="hljs-keyword">var</span> mongooseCandy = Candy.hydrate({ _id: <span class="hljs-string">'54108337212ffb6d459f854c'</span>, type: <span class="hljs-string">'jelly bean'</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.init"><a href="#model_Model.init">Model.init()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Performs any async initialization of this model against MongoDB. Currently, this function is only responsible for building <a href="https://docs.mongodb.com/manual/indexes/">indexes</a>, unless <a href="http://mongoosejs.com/docs/guide.html#autoIndex"><code>autoIndex</code></a> is turned off.</p>

<p>This function is called automatically, so you don't need to call it. This function is also idempotent, so you may call it to get back a promise that will resolve when your indexes are finished building as an alternative to <code>MyModel.on('index')</code></p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> eventSchema = <span class="hljs-keyword">new</span> Schema({ thing: { type: <span class="hljs-string">'string'</span>, unique: <span class="hljs-literal">true</span> }})
<span class="hljs-comment">// This calls `Event.init()` implicitly, so you don't need to call</span>
<span class="hljs-comment">// `Event.init()` on your own.</span>
<span class="hljs-keyword">var</span> Event = mongoose.model(<span class="hljs-string">'Event'</span>, eventSchema);

Event.init().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Event</span>) </span>{
  <span class="hljs-comment">// You can also use `Event.on('index')` if you prefer event emitters</span>
  <span class="hljs-comment">// over promises.</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Indexes are done building!'</span>);
});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.insertMany"><a href="#model_Model.insertMany">Model.insertMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc(s) <span class="method-type">&laquo;Array|Object|*&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> see the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#insertMany">mongodb driver options</a></li><li class="param">[options.ordered <span class="method-type">&laquo;Boolean&raquo;</span> = true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An <code>insertMany()</code> with <code>ordered = false</code> is called an &quot;unordered&quot; <code>insertMany()</code>.</li><li class="param">[options.rawResult <span class="method-type">&laquo;Boolean&raquo;</span> = false] if false, the returned promise resolves to the documents that passed mongoose document validation. If <code>false</code>, will return the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~insertWriteOpCallback">raw result from the MongoDB driver</a> with a <code>mongoose</code> property that contains <code>validationErrors</code> if this is an unordered <code>insertMany</code>.</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Shortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than <code>.create()</code> because it only sends one operation to the server, rather than one for each document.</p>

<p>Mongoose always validates each document <strong>before</strong> sending <code>insertMany</code> to MongoDB. So if one document has a validation error, no documents will be saved, unless you set <a href="https://docs.mongodb.com/manual/reference/method/db.collection.insertMany/#error-handling">the <code>ordered</code> option to false</a>.</p>

<p>This function does <strong>not</strong> trigger save middleware.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>insertMany()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> arr = [{ name: <span class="hljs-string">'Star Wars'</span> }, { name: <span class="hljs-string">'The Empire Strikes Back'</span> }];
Movies.insertMany(arr, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, docs</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.listIndexes"><a href="#model_Model.listIndexes">Model.listIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[cb] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise,undefined&raquo;</span> Returns `undefined` if callback is specified, returns a promise if no callback.</li></ul><div><p>Lists the indexes currently defined in MongoDB. This may or may not be the same as the indexes defined in your schema depending on whether you use the <a href="/docs/guide.html#autoIndex"><code>autoIndex</code> option</a> and if you build indexes manually.</p></div><hr class="separate-api-elements"><h3 id="model_Model.mapReduce"><a href="#model_Model.mapReduce">Model.mapReduce()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">o <span class="method-type">&laquo;Object&raquo;</span> an object specifying map-reduce options</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Executes a mapReduce command.</p>

<p><code>o</code> is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See <a href="http://mongodb.github.io/node-mongodb-native/api-generated/collection.html#mapreduce">node-mongodb-native mapReduce() documentation</a> for more detail about options.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> o = {};
<span class="hljs-comment">// `map()` and `reduce()` are run on the MongoDB server, not Node.js,</span>
<span class="hljs-comment">// these functions are converted to strings</span>
o.map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ emit(<span class="hljs-keyword">this</span>.name, <span class="hljs-number">1</span>) };
o.reduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k, vals</span>) </span>{ <span class="hljs-keyword">return</span> vals.length };
User.mapReduce(o, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, results</span>) </span>{
  <span class="hljs-built_in">console</span>.log(results)
})</code></pre>

<h4>Other options:</h4>

<ul>
<li><code>query</code> {Object} query filter object.</li>
<li><code>sort</code> {Object} sort input objects using this key</li>
<li><code>limit</code> {Number} max number of documents</li>
<li><code>keeptemp</code> {Boolean, default:false} keep temporary data</li>
<li><code>finalize</code> {Function} finalize function</li>
<li><code>scope</code> {Object} scope variables exposed to map/reduce/finalize during execution</li>
<li><code>jsMode</code> {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X</li>
<li><code>verbose</code> {Boolean, default:false} provide statistics on job execution time.</li>
<li><code>readPreference</code> {String}</li>
<li><code>out*</code> {Object, default: {inline:1}} sets the output target for the map reduce job.</li>
</ul>

<h4>* out options:</h4>

<ul>
<li><code>{inline:1}</code> the results are returned in an array</li>
<li><code>{replace: 'collectionName'}</code> add the results to collectionName: the results replace the collection</li>
<li><code>{reduce: 'collectionName'}</code> add the results to collectionName: if dups are detected, uses the reducer / finalize functions</li>
<li><code>{merge: 'collectionName'}</code> add the results to collectionName: if dups exist the new docs overwrite the old</li>
</ul>

<p>If <code>options.out</code> is set to <code>replace</code>, <code>merge</code>, or <code>reduce</code>, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the <code>lean</code> option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> o = {};
<span class="hljs-comment">// You can also define `map()` and `reduce()` as strings if your</span>
<span class="hljs-comment">// linter complains about `emit()` not being defined</span>
o.map = <span class="hljs-string">'function () { emit(this.name, 1) }'</span>;
o.reduce = <span class="hljs-string">'function (k, vals) { return vals.length }'</span>;
o.out = { replace: <span class="hljs-string">'createdCollectionNameForResults'</span> }
o.verbose = <span class="hljs-literal">true</span>;

User.mapReduce(o, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, model, stats</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'map reduce took %d ms'</span>, stats.processtime)
  model.find().where(<span class="hljs-string">'value'</span>).gt(<span class="hljs-number">10</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{
    <span class="hljs-built_in">console</span>.log(docs);
  });
})

<span class="hljs-comment">// `mapReduce()` returns a promise. However, ES6 promises can only</span>
<span class="hljs-comment">// resolve to exactly one value,</span>
o.resolveToObject = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">var</span> promise = User.mapReduce(o);
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
  <span class="hljs-keyword">var</span> model = res.model;
  <span class="hljs-keyword">var</span> stats = res.stats;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'map reduce took %d ms'</span>, stats.processtime)
  <span class="hljs-keyword">return</span> model.find().where(<span class="hljs-string">'value'</span>).gt(<span class="hljs-number">10</span>).exec();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">docs</span>) </span>{
   <span class="hljs-built_in">console</span>.log(docs);
}).then(<span class="hljs-literal">null</span>, handleError).end()</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.populate"><a href="#model_Model.populate">Model.populate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">docs <span class="method-type">&laquo;Document|Array&raquo;</span> Either a single document or array of documents to populate.</li><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> A hash of key/val (path, options) used for population.</li><li class="param">[options.retainNullValues=false] <span class="method-type">&laquo;Boolean&raquo;</span> by default, mongoose removes null and undefined values from populated arrays. Use this option to make <code>populate()</code> retain <code>null</code> and <code>undefined</code> array entries.</li><li class="param">[callback(err,doc)] <span class="method-type">&laquo;Function&raquo;</span> Optional callback, executed upon completion. Receives <code>err</code> and the <code>doc(s)</code>.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Populates document references.</p>

<h4>Available options:</h4>

<ul>
<li>path: space delimited path(s) to populate</li>
<li>select: optional fields to select</li>
<li>match: optional query conditions to match</li>
<li>model: optional name of the model to use for population</li>
<li>options: optional query options like sort, limit, etc</li>
</ul>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// populates a single object</span>
User.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
  <span class="hljs-keyword">var</span> opts = [
      { path: <span class="hljs-string">'company'</span>, match: { x: <span class="hljs-number">1</span> }, select: <span class="hljs-string">'name'</span> }
    , { path: <span class="hljs-string">'notes'</span>, options: { limit: <span class="hljs-number">10</span> }, model: <span class="hljs-string">'override'</span> }
  ]

  User.populate(user, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
    <span class="hljs-built_in">console</span>.log(user);
  });
});

<span class="hljs-comment">// populates an array of objects</span>
User.find(match, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, users</span>) </span>{
  <span class="hljs-keyword">var</span> opts = [{ path: <span class="hljs-string">'company'</span>, match: { x: <span class="hljs-number">1</span> }, select: <span class="hljs-string">'name'</span> }]

  <span class="hljs-keyword">var</span> promise = User.populate(users, opts);
  promise.then(<span class="hljs-built_in">console</span>.log).end();
})

<span class="hljs-comment">// imagine a Weapon model exists with two saved documents:</span>
<span class="hljs-comment">//   { _id: 389, name: 'whip' }</span>
<span class="hljs-comment">//   { _id: 8921, name: 'boomerang' }</span>
<span class="hljs-comment">// and this schema:</span>
<span class="hljs-comment">// new Schema({</span>
<span class="hljs-comment">//   name: String,</span>
<span class="hljs-comment">//   weapon: { type: ObjectId, ref: 'Weapon' }</span>
<span class="hljs-comment">// });</span>

<span class="hljs-keyword">var</span> user = { name: <span class="hljs-string">'Indiana Jones'</span>, weapon: <span class="hljs-number">389</span> }
Weapon.populate(user, { path: <span class="hljs-string">'weapon'</span>, model: <span class="hljs-string">'Weapon'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
  <span class="hljs-built_in">console</span>.log(user.weapon.name) <span class="hljs-comment">// whip</span>
})

<span class="hljs-comment">// populate many plain objects</span>
<span class="hljs-keyword">var</span> users = [{ name: <span class="hljs-string">'Indiana Jones'</span>, weapon: <span class="hljs-number">389</span> }]
users.push({ name: <span class="hljs-string">'Batman'</span>, weapon: <span class="hljs-number">8921</span> })
Weapon.populate(users, { path: <span class="hljs-string">'weapon'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, users</span>) </span>{
  users.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s uses a %s'</span>, users.name, user.weapon.name)
    <span class="hljs-comment">// Indiana Jones uses a whip</span>
    <span class="hljs-comment">// Batman uses a boomerang</span>
  });
});
<span class="hljs-comment">// Note that we didn't need to specify the Weapon model because</span>
<span class="hljs-comment">// it is in the schema's ref</span></code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-$where"><a href="#model_Model-$where">Model.prototype.$where</a></h3><div><p>Additional properties to attach to the query when calling <code>save()</code> and <code>isNew</code> is false.</p></div><hr class="separate-api-elements"><h3 id="model_Model-$where"><a href="#model_Model-$where">Model.prototype.$where()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">argument <span class="method-type">&laquo;String|Function&raquo;</span> is a javascript string or anonymous function</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a <code>Query</code> and specifies a <code>$where</code> condition.</p>

<p>Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via <code>find({ $where: javascript })</code>, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.</p>

<pre><code>Blog.$where(<span class="hljs-string">'this.username.indexOf("val") !== -1'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-base"><a href="#model_Model-base">Model.prototype.base</a></h3><div><p>Base Mongoose instance the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-baseModelName"><a href="#model_Model-baseModelName">Model.prototype.baseModelName</a></h3><div><p>If this is a discriminator model, <code>baseModelName</code> is the name of the base model.</p></div><hr class="separate-api-elements"><h3 id="model_Model-collection"><a href="#model_Model-collection">Model.prototype.collection</a></h3><div><p>Collection the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-db"><a href="#model_Model-db">Model.prototype.db</a></h3><div><p>Connection the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model-discriminators"><a href="#model_Model-discriminators">Model.prototype.discriminators</a></h3><div><p>Registered discriminators for this model.</p></div><hr class="separate-api-elements"><h3 id="model_Model-increment"><a href="#model_Model-increment">Model.prototype.increment()</a></h3><div><p>Signal that we desire an increment of this documents version.</p>

<h4>Example:</h4>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  doc.increment();
  doc.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{ .. })
})</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-model"><a href="#model_Model-model">Model.prototype.model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name <span class="method-type">&laquo;String&raquo;</span> model name</li></ul><div><p>Returns another Model instance.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">new</span> Tank;
doc.model(<span class="hljs-string">'User'</span>).findById(id, callback);</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-modelName"><a href="#model_Model-modelName">Model.prototype.modelName</a></h3><div><p>The name of the model</p></div><hr class="separate-api-elements"><h3 id="model_Model-remove"><a href="#model_Model-remove">Model.prototype.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn] <span class="method-type">&laquo;function(err|product)&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> Promise</li></ul><div><p>Removes this document from the db.</p>

<h4>Example:</h4>

<pre><code>product.remove(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  Product.findById(product._id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
    <span class="hljs-built_in">console</span>.log(product) <span class="hljs-comment">// null</span>
  })
})</code></pre>

<p>As an extra measure of flow control, remove will return a Promise (bound to <code>fn</code> if passed) so it could be chained, or hooked to recieve errors</p>

<h4>Example:</h4>

<pre><code>product.remove().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">product</span>) </span>{
   ...
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
   assert.ok(err)
})</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-save"><a href="#model_Model-save">Model.prototype.save()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> options optional options</li><li class="param">[options.safe] <span class="method-type">&laquo;Object&raquo;</span> overrides <a href="http://mongoosejs.com//docs/guide.html#safe">schema&#39;s safe option</a></li><li class="param">[options.validateBeforeSave] <span class="method-type">&laquo;Boolean&raquo;</span> set to false to save without validating.</li><li class="param">[fn] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise,undefined&raquo;</span> Returns undefined if used with callback or a Promise otherwise.</li></ul><div><p>Saves this document.</p>

<h4>Example:</h4>

<pre><code>product.sold = <span class="hljs-built_in">Date</span>.now();
product.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
})</code></pre>

<p>The callback will receive three parameters</p>

<ol>
<li><code>err</code> if an error occurred</li>
<li><code>product</code> which is the saved <code>product</code></li>
</ol>

<p>As an extra measure of flow control, save will return a Promise.</p>

<h4>Example:</h4>

<pre><code>product.save().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">product</span>) </span>{
   ...
});</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model-schema"><a href="#model_Model-schema">Model.prototype.schema</a></h3><div><p>Schema the model uses.</p></div><hr class="separate-api-elements"><h3 id="model_Model.remove"><a href="#model_Model.remove">Model.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Removes all documents that match <code>conditions</code> from the collection. To remove just the first document that matches <code>conditions</code>, set the <code>single</code> option to true.</p>

<h4>Example:</h4>

<pre><code>Character.remove({ name: <span class="hljs-string">'Eddard Stark'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, <em>no middleware (hooks) are executed</em>.</p></div><hr class="separate-api-elements"><h3 id="model_Model.replaceOne"><a href="#model_Model.replaceOne">Model.replaceOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">doc <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB replace the existing document with the given document (no atomic operators like <code>$set</code>).</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>replaceOne()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="model_Model.startSession"><a href="#model_Model.startSession">Model.startSession()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> see the <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html#startSession">mongodb driver options</a></li><li class="param">[options.causalConsistency=true] <span class="method-type">&laquo;Boolean&raquo;</span> set to false to disable causal consistency</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&lt;ClientSession&gt;&raquo;</span> promise that resolves to a MongoDB driver `ClientSession`</li></ul><div><p><em>Requires MongoDB >= 3.6.0.</em> Starts a <a href="https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions">MongoDB session</a> for benefits like causal consistency, <a href="https://docs.mongodb.com/manual/core/retryable-writes/">retryable writes</a>, and <a href="http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html">transactions</a>.</p>

<p>Calling <code>MyModel.startSession()</code> is equivalent to calling <code>MyModel.db.startSession()</code>.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> Person.startSession();
<span class="hljs-keyword">let</span> doc = <span class="hljs-keyword">await</span> Person.findOne({ name: <span class="hljs-string">'Ned Stark'</span> }, <span class="hljs-literal">null</span>, { session });
<span class="hljs-keyword">await</span> doc.remove();
<span class="hljs-comment">// `doc` will always be null, even if reading from a replica set</span>
<span class="hljs-comment">// secondary. Without causal consistency, it is possible to</span>
<span class="hljs-comment">// get a doc back from the below query if the query reads from a</span>
<span class="hljs-comment">// secondary that is experiencing replication lag.</span>
doc = <span class="hljs-keyword">await</span> Person.findOne({ name: <span class="hljs-string">'Ned Stark'</span> }, <span class="hljs-literal">null</span>, { session, readPreference: <span class="hljs-string">'secondary'</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.syncIndexes"><a href="#model_Model.syncIndexes">Model.syncIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> options to pass to <code>ensureIndexes()</code></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise,undefined&raquo;</span> Returns `undefined` if callback is specified, returns a promise if no callback.</li></ul><div><p>Makes the indexes in MongoDB match the indexes defined in this model's schema. This function will drop any indexes that are not defined in the model's schema except the <code>_id</code> index, and build any indexes that are in your schema but not in MongoDB.</p></div><hr class="separate-api-elements"><h3 id="model_Model.translateAliases"><a href="#model_Model.translateAliases">Model.translateAliases()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">raw <span class="method-type">&laquo;Object&raquo;</span> fields/conditions that may contain aliased keys</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> the translated 'pure' fields/conditions</li></ul><div><p>Translate any aliases fields/conditions so the final query or document object is pure</p>

<h4>Example:</h4>

<pre><code>Character
  .find(Character.translateAliases({
    <span class="hljs-string">''</span>: <span class="hljs-string">'Eddard Stark'</span> <span class="hljs-comment">// Alias for 'name'</span>
  })
  .exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, characters</span>) </span>{})</code></pre>

<h4>Note:</h4>

<p>Only translate arguments of object type anything else is returned raw</p></div><hr class="separate-api-elements"><h3 id="model_Model.update"><a href="#model_Model.update">Model.update()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">doc <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Updates one document in the database without returning it.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>update()</code></li>
</ul>

<h4>Examples:</h4>

<pre><code>MyModel.update({ age: { $gt: <span class="hljs-number">18</span> } }, { oldEnough: <span class="hljs-literal">true</span> }, fn);
MyModel.update({ name: <span class="hljs-string">'Tobi'</span> }, { ferret: <span class="hljs-literal">true</span> }, { multi: <span class="hljs-literal">true</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, raw</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'The raw response from Mongo was '</span>, raw);
});</code></pre>

<h4>Valid options:</h4>

<ul>
<li><code>safe</code> (boolean) safe mode (defaults to value set in schema (true))</li>
<li><code>upsert</code> (boolean) whether to create the doc if it doesn't match (false)</li>
<li><code>multi</code> (boolean) whether multiple documents should be updated (false)</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>strict</code> (boolean) overrides the <code>strict</code> option for this update</li>
<li><code>overwrite</code> (boolean) disables update-only mode, allowing you to overwrite the doc (false)</li>
</ul>

<p>All <code>update</code> values are cast to their appropriate SchemaTypes before being sent.</p>

<p>The <code>callback</code> function receives <code>(err, rawResponse)</code>.</p>

<ul>
<li><code>err</code> is the error if any occurred</li>
<li><code>rawResponse</code> is the full response from Mongo</li>
</ul>

<h4>Note:</h4>

<p>All top level keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> query = { name: <span class="hljs-string">'borne'</span> };
Model.update(query, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.update(query, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)
<span class="hljs-comment">// if overwrite option is false. If overwrite is true, sent without the $set wrapper.</span></code></pre>

<p>This helps prevent accidentally overwriting all documents in your collection with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a "Mod on _id not allowed" error.</p>

<h4>Note:</h4>

<p>To update documents without waiting for a response from MongoDB, do not pass a <code>callback</code>, then call <code>exec</code> on the returned <a href="#query-js">Query</a>:</p>

<pre><code>Comment.update({ _id: id }, { $set: { text: <span class="hljs-string">'changed'</span> }}).exec();</code></pre>

<h4>Note:</h4>

<p>Although values are casted to their appropriate types when using update, the following are <em>not</em> applied:</p>

<ul>
<li>defaults</li>
<li>setters</li>
<li>validators</li>
<li>middleware</li>
</ul>

<p>If you need those features, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findOne({ name: <span class="hljs-string">'borne'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
})</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.updateMany"><a href="#model_Model.updateMany">Model.updateMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">doc <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB will update <em>all</em> documents that match <code>criteria</code> (as opposed to just the first one) regardless of the value of the <code>multi</code> option.</p>

<p><strong>Note</strong> updateMany will <em>not</em> fire update middleware. Use <code>pre('updateMany')</code> and <code>post('updateMany')</code> instead.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>updateMany()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="model_Model.updateOne"><a href="#model_Model.updateOne">Model.updateOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">doc <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB will update <em>only</em> the first document that matches <code>criteria</code> regardless of the value of the <code>multi</code> option.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>updateOne()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="model_Model.watch"><a href="#model_Model.watch">Model.watch()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[pipeline] <span class="method-type">&laquo;Array&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> see the <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/Collection.html#watch">mongodb driver options</a></li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;ChangeStream&raquo;</span> mongoose-specific change stream wrapper, inherits from EventEmitter</li></ul><div><p><em>Requires a replica set running MongoDB >= 3.6.0.</em> Watches the underlying collection for changes using <a href="https://docs.mongodb.com/manual/changeStreams/">MongoDB change streams</a>.</p>

<p>This function does <strong>not</strong> trigger any middleware. In particular, it does <strong>not</strong> trigger aggregate middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> Person.create({ name: <span class="hljs-string">'Ned Stark'</span> });
Person.watch().on(<span class="hljs-string">'change'</span>, change =&gt; <span class="hljs-built_in">console</span>.log(change));
<span class="hljs-comment">// Will print from the above `console.log()`:</span>
<span class="hljs-comment">// { _id: { _data: ... },</span>
<span class="hljs-comment">//   operationType: 'delete',</span>
<span class="hljs-comment">//   ns: { db: 'mydb', coll: 'Person' },</span>
<span class="hljs-comment">//   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }</span>
<span class="hljs-keyword">await</span> doc.remove();</code></pre></div><hr class="separate-api-elements"><h3 id="model_Model.where"><a href="#model_Model.where">Model.where()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">[val] <span class="method-type">&laquo;Object&raquo;</span> optional value</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a Query, applies the passed conditions, and returns the Query.</p>

<p>For example, instead of writing:</p>

<pre><code>User.find({age: {$gte: <span class="hljs-number">21</span>, $lte: <span class="hljs-number">65</span>}}, callback);</code></pre>

<p>we can instead write:</p>

<pre><code>User.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>).exec(callback);</code></pre>

<p>Since the Query class also supports <code>where</code> you can continue chaining</p>

<pre><code>User
.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>)
.where(<span class="hljs-string">'name'</span>, <span class="hljs-regexp">/^b/i</span>)
... etc</code></pre></div><hr class="separate-api"><h2 id="Query"><a href="#Query">Query</a></h2><ul><li><a href="#query_Query">Query()</a></li><li><a href="#query_Query-$where">Query.prototype.$where()</a></li><li><a href="#query_Query-all">Query.prototype.all()</a></li><li><a href="#query_Query-and">Query.prototype.and()</a></li><li><a href="#query_Query-batchSize">Query.prototype.batchSize()</a></li><li><a href="#query_Query-box">Query.prototype.box()</a></li><li><a href="#query_Query-cast">Query.prototype.cast()</a></li><li><a href="#query_Query-catch">Query.prototype.catch()</a></li><li><a href="#query_Query-center">Query.prototype.center()</a></li><li><a href="#query_Query-centerSphere">Query.prototype.centerSphere()</a></li><li><a href="#query_Query-circle">Query.prototype.circle()</a></li><li><a href="#query_Query-collation">Query.prototype.collation()</a></li><li><a href="#query_Query-comment">Query.prototype.comment()</a></li><li><a href="#query_Query-count">Query.prototype.count()</a></li><li><a href="#query_Query-countDocuments">Query.prototype.countDocuments()</a></li><li><a href="#query_Query-cursor">Query.prototype.cursor()</a></li><li><a href="#query_Query-deleteMany">Query.prototype.deleteMany()</a></li><li><a href="#query_Query-deleteOne">Query.prototype.deleteOne()</a></li><li><a href="#query_Query-distinct">Query.prototype.distinct()</a></li><li><a href="#query_Query-elemMatch">Query.prototype.elemMatch()</a></li><li><a href="#query_Query-equals">Query.prototype.equals()</a></li><li><a href="#query_Query-error">Query.prototype.error()</a></li><li><a href="#query_Query-estimatedDocumentCount">Query.prototype.estimatedDocumentCount()</a></li><li><a href="#query_Query-exec">Query.prototype.exec()</a></li><li><a href="#query_Query-exists">Query.prototype.exists()</a></li><li><a href="#query_Query-explain">Query.prototype.explain()</a></li><li><a href="#query_Query-find">Query.prototype.find()</a></li><li><a href="#query_Query-findOne">Query.prototype.findOne()</a></li><li><a href="#query_Query-findOneAndDelete">Query.prototype.findOneAndDelete()</a></li><li><a href="#query_Query-findOneAndRemove">Query.prototype.findOneAndRemove()</a></li><li><a href="#query_Query-findOneAndUpdate">Query.prototype.findOneAndUpdate()</a></li><li><a href="#query_Query-geometry">Query.prototype.geometry()</a></li><li><a href="#query_Query-getQuery">Query.prototype.getQuery()</a></li><li><a href="#query_Query-getUpdate">Query.prototype.getUpdate()</a></li><li><a href="#query_Query-gt">Query.prototype.gt()</a></li><li><a href="#query_Query-gte">Query.prototype.gte()</a></li><li><a href="#query_Query-hint">Query.prototype.hint()</a></li><li><a href="#query_Query-in">Query.prototype.in()</a></li><li><a href="#query_Query-intersects">Query.prototype.intersects()</a></li><li><a href="#query_Query-j">Query.prototype.j()</a></li><li><a href="#query_Query-lean">Query.prototype.lean()</a></li><li><a href="#query_Query-limit">Query.prototype.limit()</a></li><li><a href="#query_Query-lt">Query.prototype.lt()</a></li><li><a href="#query_Query-lte">Query.prototype.lte()</a></li><li><a href="#query_Query-maxDistance">Query.prototype.maxDistance()</a></li><li><a href="#query_Query-maxScan">Query.prototype.maxScan()</a></li><li><a href="#query_Query-maxscan">Query.prototype.maxscan()</a></li><li><a href="#query_Query-merge">Query.prototype.merge()</a></li><li><a href="#query_Query-merge">Query.prototype.merge()</a></li><li><a href="#query_Query-mod">Query.prototype.mod()</a></li><li><a href="#query_Query-mongooseOptions">Query.prototype.mongooseOptions()</a></li><li><a href="#query_Query-ne">Query.prototype.ne()</a></li><li><a href="#query_Query-near">Query.prototype.near()</a></li><li><a href="#query_Query-nearSphere">Query.prototype.nearSphere()</a></li><li><a href="#query_Query-nin">Query.prototype.nin()</a></li><li><a href="#query_Query-nor">Query.prototype.nor()</a></li><li><a href="#query_Query-or">Query.prototype.or()</a></li><li><a href="#query_Query-polygon">Query.prototype.polygon()</a></li><li><a href="#query_Query-populate">Query.prototype.populate()</a></li><li><a href="#query_Query-read">Query.prototype.read()</a></li><li><a href="#query_Query-regex">Query.prototype.regex()</a></li><li><a href="#query_Query-remove">Query.prototype.remove()</a></li><li><a href="#query_Query-replaceOne">Query.prototype.replaceOne()</a></li><li><a href="#query_Query-select">Query.prototype.select()</a></li><li><a href="#query_Query-selected">Query.prototype.selected()</a></li><li><a href="#query_Query-selectedExclusively">Query.prototype.selectedExclusively()</a></li><li><a href="#query_Query-selectedInclusively">Query.prototype.selectedInclusively()</a></li><li><a href="#query_Query-session">Query.prototype.session()</a></li><li><a href="#query_Query-set">Query.prototype.set()</a></li><li><a href="#query_Query-setOptions">Query.prototype.setOptions()</a></li><li><a href="#query_Query-size">Query.prototype.size()</a></li><li><a href="#query_Query-skip">Query.prototype.skip()</a></li><li><a href="#query_Query-slaveOk">Query.prototype.slaveOk()</a></li><li><a href="#query_Query-slice">Query.prototype.slice()</a></li><li><a href="#query_Query-snapshot">Query.prototype.snapshot()</a></li><li><a href="#query_Query-sort">Query.prototype.sort()</a></li><li><a href="#query_Query-tailable">Query.prototype.tailable()</a></li><li><a href="#query_Query-then">Query.prototype.then()</a></li><li><a href="#query_Query-toConstructor">Query.prototype.toConstructor()</a></li><li><a href="#query_Query-update">Query.prototype.update()</a></li><li><a href="#query_Query-updateMany">Query.prototype.updateMany()</a></li><li><a href="#query_Query-updateOne">Query.prototype.updateOne()</a></li><li><a href="#query_Query-use$geoWithin">Query.prototype.use$geoWithin</a></li><li><a href="#query_Query-w">Query.prototype.w()</a></li><li><a href="#query_Query-where">Query.prototype.where()</a></li><li><a href="#query_Query-within">Query.prototype.within()</a></li><li><a href="#query_Query-wtimeout">Query.prototype.wtimeout()</a></li></ul><hr class="separate-api-elements"><h3 id="query_Query"><a href="#query_Query">Query()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[model] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[conditions] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[collection] <span class="method-type">&laquo;Object&raquo;</span> Mongoose collection</li></ul><div><p>Query constructor used for building queries. You do not need to instantiate a <code>Query</code> directly. Instead use Model functions like <a href="/docs/api.html#find_find"><code>Model.find()</code></a>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> query = MyModel.find(); <span class="hljs-comment">// `query` is an instance of `Query`</span>
query.setOptions({ lean : <span class="hljs-literal">true</span> });
query.collection(MyModel.collection);
query.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).exec(callback);

<span class="hljs-comment">// You can instantiate a query directly. There is no need to do</span>
<span class="hljs-comment">// this unless you're an advanced user with a very good reason to.</span>
<span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> mongoose.Query();</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-$where"><a href="#query_Query-$where">Query.prototype.$where()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">js <span class="method-type">&laquo;String|Function&raquo;</span> javascript string or function</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies a javascript function or expression to pass to MongoDBs query system.</p>

<h4>Example</h4>

<pre><code>query.$where(<span class="hljs-string">'this.comments.length === 10 || this.name.length === 5'</span>)

<span class="hljs-comment">// or</span>

query.$where(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.comments.length === <span class="hljs-number">10</span> || <span class="hljs-keyword">this</span>.name.length === <span class="hljs-number">5</span>;
})</code></pre>

<h4>NOTE:</h4>

<p>Only use <code>$where</code> when you have a condition that cannot be met using other MongoDB operators like <code>$lt</code>. <strong>Be sure to read about all of <a href="http://docs.mongodb.org/manual/reference/operator/where/">its caveats</a> before using.</strong></p></div><hr class="separate-api-elements"><h3 id="query_Query-all"><a href="#query_Query-all">Query.prototype.all()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies an $all query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p></div><hr class="separate-api-elements"><h3 id="query_Query-and"><a href="#query_Query-and">Query.prototype.and()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">array <span class="method-type">&laquo;Array&raquo;</span> array of conditions</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies arguments for a <code>$and</code> condition.</p>

<h4>Example</h4>

<pre><code>query.and([{ color: <span class="hljs-string">'green'</span> }, { status: <span class="hljs-string">'ok'</span> }])</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-batchSize"><a href="#query_Query-batchSize">Query.prototype.batchSize()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies the batchSize option.</p>

<h4>Example</h4>

<pre><code>query.batchSize(<span class="hljs-number">100</span>)</code></pre>

<h4>Note</h4>

<p>Cannot be used with <code>distinct()</code></p></div><hr class="separate-api-elements"><h3 id="query_Query-box"><a href="#query_Query-box">Query.prototype.box()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">Upper <span class="method-type">&laquo;[Array]&raquo;</span> Right Coords</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies a $box condition</p>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> lowerLeft = [<span class="hljs-number">40.73083</span>, <span class="hljs-number">-73.99756</span>]
<span class="hljs-keyword">var</span> upperRight= [<span class="hljs-number">40.741404</span>,  <span class="hljs-number">-73.988135</span>]

query.where(<span class="hljs-string">'loc'</span>).within().box(lowerLeft, upperRight)
query.box({ ll : lowerLeft, ur : upperRight })</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-cast"><a href="#query_Query-cast">Query.prototype.cast()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">model <span class="method-type">&laquo;Model&raquo;</span> </li><li class="param">[obj] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>Casts this query to the schema of <code>model</code></p>

<h4>Note</h4>

<p>If <code>obj</code> is present, it is cast instead of this query.</p></div><hr class="separate-api-elements"><h3 id="query_Query-catch"><a href="#query_Query-catch">Query.prototype.catch()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[reject] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Executes the query returning a <code>Promise</code> which will be resolved with either the doc(s) or rejected with the error. Like <code>.then()</code>, but only takes a rejection handler.</p></div><hr class="separate-api-elements"><h3 id="query_Query-center"><a href="#query_Query-center">Query.prototype.center()</a></h3><div><p><em>DEPRECATED</em> Alias for <a href="#query_Query-circle">circle</a></p>

<p><strong>Deprecated.</strong> Use <a href="#query_Query-circle">circle</a> instead.</p></div><hr class="separate-api-elements"><h3 id="query_Query-centerSphere"><a href="#query_Query-centerSphere">Query.prototype.centerSphere()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p><em>DEPRECATED</em> Specifies a $centerSphere condition</p>

<p><strong>Deprecated.</strong> Use <a href="#query_Query-circle">circle</a> instead.</p>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> area = { center: [<span class="hljs-number">50</span>, <span class="hljs-number">50</span>], radius: <span class="hljs-number">10</span> };
query.where(<span class="hljs-string">'loc'</span>).within().centerSphere(area);</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-circle"><a href="#query_Query-circle">Query.prototype.circle()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">area <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies a $center or $centerSphere condition.</p>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> area = { center: [<span class="hljs-number">50</span>, <span class="hljs-number">50</span>], radius: <span class="hljs-number">10</span>, unique: <span class="hljs-literal">true</span> }
query.where(<span class="hljs-string">'loc'</span>).within().circle(area)
<span class="hljs-comment">// alternatively</span>
query.circle(<span class="hljs-string">'loc'</span>, area);

<span class="hljs-comment">// spherical calculations</span>
<span class="hljs-keyword">var</span> area = { center: [<span class="hljs-number">50</span>, <span class="hljs-number">50</span>], radius: <span class="hljs-number">10</span>, unique: <span class="hljs-literal">true</span>, spherical: <span class="hljs-literal">true</span> }
query.where(<span class="hljs-string">'loc'</span>).within().circle(area)
<span class="hljs-comment">// alternatively</span>
query.circle(<span class="hljs-string">'loc'</span>, area);</code></pre>

<p>New in 3.7.0</p></div><hr class="separate-api-elements"><h3 id="query_Query-collation"><a href="#query_Query-collation">Query.prototype.collation()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">value <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Adds a collation to this op (MongoDB 3.4 and up)</p></div><hr class="separate-api-elements"><h3 id="query_Query-comment"><a href="#query_Query-comment">Query.prototype.comment()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies the <code>comment</code> option.</p>

<h4>Example</h4>

<pre><code>query.comment(<span class="hljs-string">'login query'</span>)</code></pre>

<h4>Note</h4>

<p>Cannot be used with <code>distinct()</code></p></div><hr class="separate-api-elements"><h3 id="query_Query-count"><a href="#query_Query-count">Query.prototype.count()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[criteria] <span class="method-type">&laquo;Object&raquo;</span> mongodb selector</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, count)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies this query as a <code>count</code> query. This method is deprecated, use <code>countDocuments()</code> instead.</p>

<p>Passing a <code>callback</code> executes the query.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>count()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> countQuery = model.where({ <span class="hljs-string">'color'</span>: <span class="hljs-string">'black'</span> }).count();

query.count({ color: <span class="hljs-string">'black'</span> }).count(callback)

query.count({ color: <span class="hljs-string">'black'</span> }, callback)

query.where(<span class="hljs-string">'color'</span>, <span class="hljs-string">'black'</span>).count(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, count</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there are %d kittens'</span>, count);
})</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-countDocuments"><a href="#query_Query-countDocuments">Query.prototype.countDocuments()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[criteria] <span class="method-type">&laquo;Object&raquo;</span> mongodb selector</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, count)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies this query as a <code>countDocuments()</code> query. Behaves like <code>count()</code>, except for <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#countDocuments"><code>$where</code> and a couple geospatial operators</a>.</p>

<p>Passing a <code>callback</code> executes the query.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>countDocuments()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> countQuery = model.where({ <span class="hljs-string">'color'</span>: <span class="hljs-string">'black'</span> }).countDocuments();

query.countDocuments({ color: <span class="hljs-string">'black'</span> }).count(callback);

query.countDocuments({ color: <span class="hljs-string">'black'</span> }, callback);

query.where(<span class="hljs-string">'color'</span>, <span class="hljs-string">'black'</span>).countDocuments(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, count</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there are %d kittens'</span>, count);
});</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-cursor"><a href="#query_Query-cursor">Query.prototype.cursor()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;QueryCursor&raquo;</span> </li></ul><div><p>Returns a wrapper around a <a href="http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html">mongodb driver cursor</a>. A QueryCursor exposes a Streams3 interface, as well as a <code>.next()</code> function.</p>

<p>The <code>.cursor()</code> function triggers pre find hooks, but <strong>not</strong> post find hooks.</p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// There are 2 ways to use a cursor. First, as a stream:</span>
Thing.
  find({ name: <span class="hljs-regexp">/^hello/</span> }).
  cursor().
  on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{ <span class="hljs-built_in">console</span>.log(doc); }).
  on(<span class="hljs-string">'end'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Done!'</span>); });

<span class="hljs-comment">// Or you can use `.next()` to manually get the next doc in the stream.</span>
<span class="hljs-comment">// `.next()` returns a promise, so you can use promises or callbacks.</span>
<span class="hljs-keyword">var</span> cursor = Thing.find({ name: <span class="hljs-regexp">/^hello/</span> }).cursor();
cursor.next(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(doc);
});

<span class="hljs-comment">// Because `.next()` returns a promise, you can use co</span>
<span class="hljs-comment">// to easily iterate through all documents without loading them</span>
<span class="hljs-comment">// all into memory.</span>
co(<span class="hljs-function"><span class="hljs-keyword">function</span>*(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> cursor = Thing.find({ name: <span class="hljs-regexp">/^hello/</span> }).cursor();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> doc = <span class="hljs-keyword">yield</span> cursor.next(); doc != <span class="hljs-literal">null</span>; doc = <span class="hljs-keyword">yield</span> cursor.next()) {
    <span class="hljs-built_in">console</span>.log(doc);
  }
});</code></pre>

<h4>Valid options</h4>

<ul>
<li><code>transform</code>: optional function which accepts a mongoose document. The return value of the function will be emitted on <code>data</code> and returned by <code>.next()</code>.</li>
</ul></div><hr class="separate-api-elements"><h3 id="query_Query-deleteMany"><a href="#query_Query-deleteMany">Query.prototype.deleteMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[filter] <span class="method-type">&laquo;Object|Query&raquo;</span> mongodb selector</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, writeOpResult)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Declare and/or execute this query as a <code>deleteMany()</code> operation. Works like remove, except it deletes <em>every</em> document that matches <code>criteria</code> in the collection, regardless of the value of <code>single</code>.</p>

<p>This function does not trigger any middleware</p>

<h4>Example</h4>

<pre><code>Character.deleteMany({ name: <span class="hljs-regexp">/Stark/</span>, age: { $gte: <span class="hljs-number">18</span> } }, callback)
Character.deleteMany({ name: <span class="hljs-regexp">/Stark/</span>, age: { $gte: <span class="hljs-number">18</span> } }).then(next)</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-deleteOne"><a href="#query_Query-deleteOne">Query.prototype.deleteOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[filter] <span class="method-type">&laquo;Object|Query&raquo;</span> mongodb selector</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, writeOpResult)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Declare and/or execute this query as a <code>deleteOne()</code> operation. Works like remove, except it deletes at most one document regardless of the <code>single</code> option.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example</h4>

<pre><code>Character.deleteOne({ name: <span class="hljs-string">'Eddard Stark'</span> }, callback)
Character.deleteOne({ name: <span class="hljs-string">'Eddard Stark'</span> }).then(next)</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-distinct"><a href="#query_Query-distinct">Query.prototype.distinct()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[field] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">[filter] <span class="method-type">&laquo;Object|Query&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, arr)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Declares or executes a distict() operation.</p>

<p>Passing a <code>callback</code> executes the query.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example</h4>

<pre><code>distinct(field, conditions, callback)
distinct(field, conditions)
distinct(field, callback)
distinct(field)
distinct(callback)
distinct()</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-elemMatch"><a href="#query_Query-elemMatch">Query.prototype.elemMatch()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String|Object|Function&raquo;</span> </li><li class="param">criteria <span class="method-type">&laquo;Object|Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies an <code>$elemMatch</code> condition</p>

<h4>Example</h4>

<pre><code>query.elemMatch(<span class="hljs-string">'comment'</span>, { author: <span class="hljs-string">'autobot'</span>, votes: {$gte: <span class="hljs-number">5</span>}})

query.where(<span class="hljs-string">'comment'</span>).elemMatch({ author: <span class="hljs-string">'autobot'</span>, votes: {$gte: <span class="hljs-number">5</span>}})

query.elemMatch(<span class="hljs-string">'comment'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
  elem.where(<span class="hljs-string">'author'</span>).equals(<span class="hljs-string">'autobot'</span>);
  elem.where(<span class="hljs-string">'votes'</span>).gte(<span class="hljs-number">5</span>);
})

query.where(<span class="hljs-string">'comment'</span>).elemMatch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>{
  elem.where({ author: <span class="hljs-string">'autobot'</span> });
  elem.where(<span class="hljs-string">'votes'</span>).gte(<span class="hljs-number">5</span>);
})</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-equals"><a href="#query_Query-equals">Query.prototype.equals()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies the complementary comparison value for paths specified with <code>where()</code></p>

<h4>Example</h4>

<pre><code>User.where(<span class="hljs-string">'age'</span>).equals(<span class="hljs-number">49</span>);

<span class="hljs-comment">// is the same as</span>

User.where(<span class="hljs-string">'age'</span>, <span class="hljs-number">49</span>);</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-error"><a href="#query_Query-error">Query.prototype.error()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">err <span class="method-type">&laquo;Error|null&raquo;</span> if set, <code>exec()</code> will fail fast before sending the query to MongoDB</li></ul><div><p>Gets/sets the error flag on this query. If this flag is not null or undefined, the <code>exec()</code> promise will reject without executing.</p>

<h4>Example:</h4>

<pre><code>Query().error(); <span class="hljs-comment">// Get current error value</span>
Query().error(<span class="hljs-literal">null</span>); <span class="hljs-comment">// Unset the current error</span>
Query().error(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'test'</span>)); <span class="hljs-comment">// `exec()` will resolve with test</span>
Schema.pre(<span class="hljs-string">'find'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.getQuery().userId) {
    <span class="hljs-keyword">this</span>.error(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Not allowed to query without setting userId'</span>));
  }
});</code></pre>

<p>Note that query casting runs <strong>after</strong> hooks, so cast errors will override custom errors.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> TestSchema = <span class="hljs-keyword">new</span> Schema({ num: <span class="hljs-built_in">Number</span> });
<span class="hljs-keyword">var</span> TestModel = db.model(<span class="hljs-string">'Test'</span>, TestSchema);
TestModel.find({ num: <span class="hljs-string">'not a number'</span> }).error(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'woops'</span>)).exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>{
  <span class="hljs-comment">// `error` will be a cast error because `num` failed to cast</span>
});</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-estimatedDocumentCount"><a href="#query_Query-estimatedDocumentCount">Query.prototype.estimatedDocumentCount()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> passed transparently to the <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#estimatedDocumentCount">MongoDB driver</a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, count)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies this query as a <code>estimatedDocumentCount()</code> query. Faster than using <code>countDocuments()</code> for large collections because <code>estimatedDocumentCount()</code> uses collection metadata rather than scanning the entire collection.</p>

<p><code>estimatedDocumentCount()</code> does <strong>not</strong> accept a filter. <code>Model.find({ foo: bar }).estimatedDocumentCount()</code> is equivalent to <code>Model.find().estimatedDocumentCount()</code></p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>estimatedDocumentCount()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">await</span> Model.find().estimatedDocumentCount();</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-exec"><a href="#query_Query-exec">Query.prototype.exec()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[operation] <span class="method-type">&laquo;String|Function&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params depend on the function being called</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Executes the query</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-keyword">var</span> promise = query.exec();
<span class="hljs-keyword">var</span> promise = query.exec(<span class="hljs-string">'update'</span>);

query.exec(callback);
query.exec(<span class="hljs-string">'find'</span>, callback);</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-exists"><a href="#query_Query-exists">Query.prototype.exists()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies an <code>$exists</code> condition</p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// { name: { $exists: true }}</span>
Thing.where(<span class="hljs-string">'name'</span>).exists()
Thing.where(<span class="hljs-string">'name'</span>).exists(<span class="hljs-literal">true</span>)
Thing.find().exists(<span class="hljs-string">'name'</span>)

<span class="hljs-comment">// { name: { $exists: false }}</span>
Thing.where(<span class="hljs-string">'name'</span>).exists(<span class="hljs-literal">false</span>);
Thing.find().exists(<span class="hljs-string">'name'</span>, <span class="hljs-literal">false</span>);</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-explain"><a href="#query_Query-explain">Query.prototype.explain()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[verbose] <span class="method-type">&laquo;String&raquo;</span> The verbosity mode. Either &#39;queryPlanner&#39;, &#39;executionStats&#39;, or &#39;allPlansExecution&#39;. The default is &#39;queryPlanner&#39;</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Sets the <a href="https://docs.mongodb.com/manual/reference/method/cursor.explain/"><code>explain</code> option</a>, which makes this query return detailed execution stats instead of the actual query result. This method is useful for determining what index your queries use.</p>

<p>Calling <code>query.explain(v)</code> is equivalent to <code>query.setOption({ explain: v })</code></p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> query = <span class="hljs-keyword">new</span> Query();
<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> query.find({ a: <span class="hljs-number">1</span> }).explain(<span class="hljs-string">'queryPlanner'</span>);
<span class="hljs-built_in">console</span>.log(res);</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-find"><a href="#query_Query-find">Query.prototype.find()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[filter] <span class="method-type">&laquo;Object&raquo;</span> mongodb selector</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Finds documents.</p>

<p>When no <code>callback</code> is passed, the query is not executed. When the query is executed, the result will be an array of documents.</p>

<h4>Example</h4>

<pre><code>query.find({ name: <span class="hljs-string">'Los Pollos Hermanos'</span> }).find(callback)</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-findOne"><a href="#query_Query-findOne">Query.prototype.findOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[filter] <span class="method-type">&laquo;Object&raquo;</span> mongodb selector</li><li class="param">[projection] <span class="method-type">&laquo;Object&raquo;</span> optional fields to return</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>setOptions()</code></a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, document)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Declares the query a findOne operation. When executed, the first found document is passed to the callback.</p>

<p>Passing a <code>callback</code> executes the query. The result of the query is a single document.</p>

<ul>
<li><em>Note:</em> <code>conditions</code> is optional, and if <code>conditions</code> is null or undefined,
mongoose will send an empty <code>findOne</code> command to MongoDB, which will return
an arbitrary document. If you're querying by <code>_id</code>, use <code>Model.findById()</code>
instead.</li>
</ul>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOne()</code></li>
</ul>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> query  = Kitten.where({ color: <span class="hljs-string">'white'</span> });
query.findOne(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, kitten</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  <span class="hljs-keyword">if</span> (kitten) {
    <span class="hljs-comment">// doc may be null if no document matched</span>
  }
});</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-findOneAndDelete"><a href="#query_Query-findOneAndDelete">Query.prototype.findOneAndDelete()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[conditions] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options.rawResult] <span class="method-type">&laquo;Boolean&raquo;</span> if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li><li class="param">[options.strict] <span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, document)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Issues a MongoDB <a href="https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndDelete/">findOneAndDelete</a> command.</p>

<p>Finds a matching document, removes it, and passes the found document (if any) to the callback. Executes immediately if <code>callback</code> is passed.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndDelete()</code></li>
</ul>

<p>This function differs slightly from <code>Model.findOneAndRemove()</code> in that <code>findOneAndRemove()</code> becomes a <a href="https://docs.mongodb.com/manual/reference/method/db.collection.findAndModify/">MongoDB <code>findAndModify()</code> command</a>, as opposed to a <code>findOneAndDelete()</code> command. For most mongoose use cases, this distinction is purely pedantic. You should use <code>findOneAndDelete()</code> unless you have a good reason not to.</p>

<h4>Available options</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>rawResult</code>: if true, resolves to the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
</ul>

<h4>Callback Signature</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// error: any errors that occurred</span>
  <span class="hljs-comment">// doc: the document before updates are applied if `new: false`, or after updates if `new = true`</span>
}</code></pre>

<h4>Examples</h4>

<pre><code>A.where().findOneAndDelete(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.where().findOneAndDelete(conditions, options)  <span class="hljs-comment">// return Query</span>
A.where().findOneAndDelete(conditions, callback) <span class="hljs-comment">// executes</span>
A.where().findOneAndDelete(conditions) <span class="hljs-comment">// returns Query</span>
A.where().findOneAndDelete(callback)   <span class="hljs-comment">// executes</span>
A.where().findOneAndDelete()           <span class="hljs-comment">// returns Query</span></code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-findOneAndRemove"><a href="#query_Query-findOneAndRemove">Query.prototype.findOneAndRemove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[conditions] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options.rawResult] <span class="method-type">&laquo;Boolean&raquo;</span> if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li><li class="param">[options.strict] <span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, document)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Issues a mongodb <a href="http://www.mongodb.org/display/DOCS/findAndModify+Command">findAndModify</a> remove command.</p>

<p>Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if <code>callback</code> is passed.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndRemove()</code></li>
</ul>

<h4>Available options</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>rawResult</code>: if true, resolves to the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
</ul>

<h4>Callback Signature</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// error: any errors that occurred</span>
  <span class="hljs-comment">// doc: the document before updates are applied if `new: false`, or after updates if `new = true`</span>
}</code></pre>

<h4>Examples</h4>

<pre><code>A.where().findOneAndRemove(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.where().findOneAndRemove(conditions, options)  <span class="hljs-comment">// return Query</span>
A.where().findOneAndRemove(conditions, callback) <span class="hljs-comment">// executes</span>
A.where().findOneAndRemove(conditions) <span class="hljs-comment">// returns Query</span>
A.where().findOneAndRemove(callback)   <span class="hljs-comment">// executes</span>
A.where().findOneAndRemove()           <span class="hljs-comment">// returns Query</span></code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-findOneAndUpdate"><a href="#query_Query-findOneAndUpdate">Query.prototype.findOneAndUpdate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[query] <span class="method-type">&laquo;Object|Query&raquo;</span> </li><li class="param">[doc] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options.rawResult] <span class="method-type">&laquo;Boolean&raquo;</span> if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li><li class="param">[options.strict] <span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li><li class="param">[options.multipleCastError] <span class="method-type">&laquo;Boolean&raquo;</span> by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.</li><li class="param">[options.lean] <span class="method-type">&laquo;Object&raquo;</span> if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See <a href="http://mongoosejs.com/docs/api.html#query_Query-lean"><code>Query.lean()</code></a>.</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, doc), <em>unless</em> <code>rawResult</code> is used, in which case params are (error, writeOpResult)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Issues a mongodb <a href="http://www.mongodb.org/display/DOCS/findAndModify+Command">findAndModify</a> update command.</p>

<p>Finds a matching document, updates it according to the <code>update</code> arg, passing any <code>options</code>, and returns the found document (if any) to the callback. The query executes immediately if <code>callback</code> is passed.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndUpdate()</code></li>
</ul>

<h4>Available options</h4>

<ul>
<li><code>new</code>: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)</li>
<li><code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.</li>
<li><code>fields</code>: {Object|String} - Field selection. Equivalent to <code>.select(fields).findOneAndUpdate()</code></li>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>context</code> (string) if set to 'query' and <code>runValidators</code> is on, <code>this</code> will refer to the query in custom validator functions that update validation runs. Does nothing if <code>runValidators</code> is false.</li>
</ul>

<h4>Callback Signature</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// error: any errors that occurred</span>
  <span class="hljs-comment">// doc: the document before updates are applied if `new: false`, or after updates if `new = true`</span>
}</code></pre>

<h4>Examples</h4>

<pre><code>query.findOneAndUpdate(conditions, update, options, callback) <span class="hljs-comment">// executes</span>
query.findOneAndUpdate(conditions, update, options)  <span class="hljs-comment">// returns Query</span>
query.findOneAndUpdate(conditions, update, callback) <span class="hljs-comment">// executes</span>
query.findOneAndUpdate(conditions, update)           <span class="hljs-comment">// returns Query</span>
query.findOneAndUpdate(update, callback)             <span class="hljs-comment">// returns Query</span>
query.findOneAndUpdate(update)                       <span class="hljs-comment">// returns Query</span>
query.findOneAndUpdate(callback)                     <span class="hljs-comment">// executes</span>
query.findOneAndUpdate()                             <span class="hljs-comment">// returns Query</span></code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-geometry"><a href="#query_Query-geometry">Query.prototype.geometry()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">object <span class="method-type">&laquo;Object&raquo;</span> Must contain a <code>type</code> property which is a String and a <code>coordinates</code> property which is an Array. See the examples.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies a <code>$geometry</code> condition</p>

<h4>Example</h4>

<pre><code><span class="hljs-keyword">var</span> polyA = [[[ <span class="hljs-number">10</span>, <span class="hljs-number">20</span> ], [ <span class="hljs-number">10</span>, <span class="hljs-number">40</span> ], [ <span class="hljs-number">30</span>, <span class="hljs-number">40</span> ], [ <span class="hljs-number">30</span>, <span class="hljs-number">20</span> ]]]
query.where(<span class="hljs-string">'loc'</span>).within().geometry({ type: <span class="hljs-string">'Polygon'</span>, coordinates: polyA })

<span class="hljs-comment">// or</span>
<span class="hljs-keyword">var</span> polyB = [[ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ], [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span> ]]
query.where(<span class="hljs-string">'loc'</span>).within().geometry({ type: <span class="hljs-string">'LineString'</span>, coordinates: polyB })

<span class="hljs-comment">// or</span>
<span class="hljs-keyword">var</span> polyC = [ <span class="hljs-number">0</span>, <span class="hljs-number">0</span> ]
query.where(<span class="hljs-string">'loc'</span>).within().geometry({ type: <span class="hljs-string">'Point'</span>, coordinates: polyC })

<span class="hljs-comment">// or</span>
query.where(<span class="hljs-string">'loc'</span>).intersects().geometry({ type: <span class="hljs-string">'Point'</span>, coordinates: polyC })</code></pre>

<p>The argument is assigned to the most recent path passed to <code>where()</code>.</p>

<h4>NOTE:</h4>

<p><code>geometry()</code> <strong>must</strong> come after either <code>intersects()</code> or <code>within()</code>.</p>

<p>The <code>object</code> argument must contain <code>type</code> and <code>coordinates</code> properties. - type {String} - coordinates {Array}</p></div><hr class="separate-api-elements"><h3 id="query_Query-getQuery"><a href="#query_Query-getQuery">Query.prototype.getQuery()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> current query conditions</li></ul><div><p>Returns the current query conditions as a JSON object.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> query = <span class="hljs-keyword">new</span> Query();
query.find({ a: <span class="hljs-number">1</span> }).where(<span class="hljs-string">'b'</span>).gt(<span class="hljs-number">2</span>);
query.getQuery(); <span class="hljs-comment">// { a: 1, b: { $gt: 2 } }</span></code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-getUpdate"><a href="#query_Query-getUpdate">Query.prototype.getUpdate()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> current update operations</li></ul><div><p>Returns the current update operations as a JSON object.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> query = <span class="hljs-keyword">new</span> Query();
query.update({}, { $set: { a: <span class="hljs-number">5</span> } });
query.getUpdate(); <span class="hljs-comment">// { $set: { a: 5 } }</span></code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-gt"><a href="#query_Query-gt">Query.prototype.gt()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies a $gt query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p>

<h4>Example</h4>

<pre><code>Thing.find().where(<span class="hljs-string">'age'</span>).gt(<span class="hljs-number">21</span>)

<span class="hljs-comment">// or</span>
Thing.find().gt(<span class="hljs-string">'age'</span>, <span class="hljs-number">21</span>)</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-gte"><a href="#query_Query-gte">Query.prototype.gte()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies a $gte query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p></div><hr class="separate-api-elements"><h3 id="query_Query-hint"><a href="#query_Query-hint">Query.prototype.hint()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;Object&raquo;</span> a hint object</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Sets query hints.</p>

<h4>Example</h4>

<pre><code>query.hint({ indexA: <span class="hljs-number">1</span>, indexB: <span class="hljs-number">-1</span>})</code></pre>

<h4>Note</h4>

<p>Cannot be used with <code>distinct()</code></p></div><hr class="separate-api-elements"><h3 id="query_Query-in"><a href="#query_Query-in">Query.prototype.in()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies an $in query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p></div><hr class="separate-api-elements"><h3 id="query_Query-intersects"><a href="#query_Query-intersects">Query.prototype.intersects()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[arg] <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Declares an intersects query for <code>geometry()</code>.</p>

<h4>Example</h4>

<pre><code>query.where(<span class="hljs-string">'path'</span>).intersects().geometry({
    type: <span class="hljs-string">'LineString'</span>
  , coordinates: [[<span class="hljs-number">180.0</span>, <span class="hljs-number">11.0</span>], [<span class="hljs-number">180</span>, <span class="hljs-number">9.0</span>]]
})

query.where(<span class="hljs-string">'path'</span>).intersects({
    type: <span class="hljs-string">'LineString'</span>
  , coordinates: [[<span class="hljs-number">180.0</span>, <span class="hljs-number">11.0</span>], [<span class="hljs-number">180</span>, <span class="hljs-number">9.0</span>]]
})</code></pre>

<h4>NOTE:</h4>

<p><strong>MUST</strong> be used after <code>where()</code>.</p>

<h4>NOTE:</h4>

<p>In Mongoose 3.7, <code>intersects</code> changed from a getter to a function. If you need the old syntax, use <a href="https://github.com/ebensing/mongoose-within">this</a>.</p></div><hr class="separate-api-elements"><h3 id="query_Query-j"><a href="#query_Query-j">Query.prototype.j()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Requests acknowledgement that this operation has been persisted to MongoDB's on-disk journal.</p>

<h2>This option is only valid for operations that write to the database</h2>

<ul>
<li><code>deleteOne()</code></li>
<li><code>deleteMany()</code></li>
<li><code>findOneAndDelete()</code></li>
<li><code>findOneAndUpdate()</code></li>
<li><code>remove()</code></li>
<li><code>update()</code></li>
<li><code>updateOne()</code></li>
<li><code>updateMany()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="query_Query-lean"><a href="#query_Query-lean">Query.prototype.lean()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">bool <span class="method-type">&laquo;Boolean|Object&raquo;</span> defaults to true</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Sets the lean option.</p>

<p>Documents returned from queries with the <code>lean</code> option enabled are plain javascript objects, not <a href="#document-js">MongooseDocuments</a>. They have no <code>save</code> method, getters/setters or other Mongoose magic applied.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">new</span> Query().lean() <span class="hljs-comment">// true</span>
<span class="hljs-keyword">new</span> Query().lean(<span class="hljs-literal">true</span>)
<span class="hljs-keyword">new</span> Query().lean(<span class="hljs-literal">false</span>)

Model.find().lean().exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{
  docs[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> mongoose.Document <span class="hljs-comment">// false</span>
});</code></pre>

<p>This is a <a href="https://groups.google.com/forum/#!topic/mongoose-orm/u2_DzDydcnA/discussion">great</a> option in high-performance read-only scenarios, especially when combined with <a href="#query_Query-stream">stream</a>.</p></div><hr class="separate-api-elements"><h3 id="query_Query-limit"><a href="#query_Query-limit">Query.prototype.limit()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies the maximum number of documents the query will return.</p>

<h4>Example</h4>

<pre><code>query.limit(<span class="hljs-number">20</span>)</code></pre>

<h4>Note</h4>

<p>Cannot be used with <code>distinct()</code></p></div><hr class="separate-api-elements"><h3 id="query_Query-lt"><a href="#query_Query-lt">Query.prototype.lt()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies a $lt query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p></div><hr class="separate-api-elements"><h3 id="query_Query-lte"><a href="#query_Query-lte">Query.prototype.lte()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies a $lte query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p></div><hr class="separate-api-elements"><h3 id="query_Query-maxDistance"><a href="#query_Query-maxDistance">Query.prototype.maxDistance()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies a $maxDistance query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p></div><hr class="separate-api-elements"><h3 id="query_Query-maxScan"><a href="#query_Query-maxScan">Query.prototype.maxScan()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies the maxScan option.</p>

<h4>Example</h4>

<pre><code>query.maxScan(<span class="hljs-number">100</span>)</code></pre>

<h4>Note</h4>

<p>Cannot be used with <code>distinct()</code></p></div><hr class="separate-api-elements"><h3 id="query_Query-maxscan"><a href="#query_Query-maxscan">Query.prototype.maxscan()</a></h3><div><p><em>DEPRECATED</em> Alias of <code>maxScan</code></p></div><hr class="separate-api-elements"><h3 id="query_Query-merge"><a href="#query_Query-merge">Query.prototype.merge()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">source <span class="method-type">&laquo;Query|Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Merges another Query or conditions object into this one.</p>

<p>When a Query is passed, conditions, field selection and options are merged.</p>

<p>New in 3.7.0</p></div><hr class="separate-api-elements"><h3 id="query_Query-merge"><a href="#query_Query-merge">Query.prototype.merge()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">source <span class="method-type">&laquo;Query|Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Merges another Query or conditions object into this one.</p>

<p>When a Query is passed, conditions, field selection and options are merged.</p></div><hr class="separate-api-elements"><h3 id="query_Query-mod"><a href="#query_Query-mod">Query.prototype.mod()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Array&raquo;</span> must be of length 2, first element is <code>divisor</code>, 2nd element is <code>remainder</code>.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies a <code>$mod</code> condition, filters documents for documents whose <code>path</code> property is a number that is equal to <code>remainder</code> modulo <code>divisor</code>.</p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// All find products whose inventory is odd</span>
Product.find().mod(<span class="hljs-string">'inventory'</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);
Product.find().where(<span class="hljs-string">'inventory'</span>).mod([<span class="hljs-number">2</span>, <span class="hljs-number">1</span>]);
<span class="hljs-comment">// This syntax is a little strange, but supported.</span>
Product.find().where(<span class="hljs-string">'inventory'</span>).mod(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-mongooseOptions"><a href="#query_Query-mongooseOptions">Query.prototype.mongooseOptions()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> if specified, overwrites the current options</li></ul><div><p>Getter/setter around the current mongoose-specific options for this query (populate, lean, etc.)</p></div><hr class="separate-api-elements"><h3 id="query_Query-ne"><a href="#query_Query-ne">Query.prototype.ne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies a $ne query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p></div><hr class="separate-api-elements"><h3 id="query_Query-near"><a href="#query_Query-near">Query.prototype.near()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies a <code>$near</code> or <code>$nearSphere</code> condition</p>

<p>These operators return documents sorted by distance.</p>

<h4>Example</h4>

<pre><code>query.where(<span class="hljs-string">'loc'</span>).near({ center: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>] });
query.where(<span class="hljs-string">'loc'</span>).near({ center: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], maxDistance: <span class="hljs-number">5</span> });
query.where(<span class="hljs-string">'loc'</span>).near({ center: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], maxDistance: <span class="hljs-number">5</span>, spherical: <span class="hljs-literal">true</span> });
query.near(<span class="hljs-string">'loc'</span>, { center: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], maxDistance: <span class="hljs-number">5</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-nearSphere"><a href="#query_Query-nearSphere">Query.prototype.nearSphere()</a></h3><div><p><em>DEPRECATED</em> Specifies a <code>$nearSphere</code> condition</p>

<h4>Example</h4>

<pre><code>query.where(<span class="hljs-string">'loc'</span>).nearSphere({ center: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], maxDistance: <span class="hljs-number">5</span> });</code></pre>

<p><strong>Deprecated.</strong> Use <code>query.near()</code> instead with the <code>spherical</code> option set to <code>true</code>.</p>

<h4>Example</h4>

<pre><code>query.where(<span class="hljs-string">'loc'</span>).near({ center: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], spherical: <span class="hljs-literal">true</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-nin"><a href="#query_Query-nin">Query.prototype.nin()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies an $nin query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p></div><hr class="separate-api-elements"><h3 id="query_Query-nor"><a href="#query_Query-nor">Query.prototype.nor()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">array <span class="method-type">&laquo;Array&raquo;</span> array of conditions</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies arguments for a <code>$nor</code> condition.</p>

<h4>Example</h4>

<pre><code>query.nor([{ color: <span class="hljs-string">'green'</span> }, { status: <span class="hljs-string">'ok'</span> }])</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-or"><a href="#query_Query-or">Query.prototype.or()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">array <span class="method-type">&laquo;Array&raquo;</span> array of conditions</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies arguments for an <code>$or</code> condition.</p>

<h4>Example</h4>

<pre><code>query.or([{ color: <span class="hljs-string">'red'</span> }, { status: <span class="hljs-string">'emergency'</span> }])</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-polygon"><a href="#query_Query-polygon">Query.prototype.polygon()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String|Array&raquo;</span> </li><li class="param">[coordinatePairs...] <span class="method-type">&laquo;Array|Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies a $polygon condition</p>

<h4>Example</h4>

<pre><code>query.where(<span class="hljs-string">'loc'</span>).within().polygon([<span class="hljs-number">10</span>,<span class="hljs-number">20</span>], [<span class="hljs-number">13</span>, <span class="hljs-number">25</span>], [<span class="hljs-number">7</span>,<span class="hljs-number">15</span>])
query.polygon(<span class="hljs-string">'loc'</span>, [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>], [<span class="hljs-number">13</span>, <span class="hljs-number">25</span>], [<span class="hljs-number">7</span>,<span class="hljs-number">15</span>])</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-populate"><a href="#query_Query-populate">Query.prototype.populate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;Object|String&raquo;</span> either the path to populate or an object specifying all parameters</li><li class="param">[select] <span class="method-type">&laquo;Object|String&raquo;</span> Field selection for the population query</li><li class="param">[model] <span class="method-type">&laquo;Model&raquo;</span> The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema&#39;s <code>ref</code> field.</li><li class="param">[match] <span class="method-type">&laquo;Object&raquo;</span> Conditions for the population query</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> Options for the population query (sort, etc)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies paths which should be populated with other documents.</p>

<h4>Example:</h4>

<pre><code>Kitten.findOne().populate(<span class="hljs-string">'owner'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, kitten</span>) </span>{
  <span class="hljs-built_in">console</span>.log(kitten.owner.name) <span class="hljs-comment">// Max</span>
})

Kitten.find().populate({
    path: <span class="hljs-string">'owner'</span>
  , select: <span class="hljs-string">'name'</span>
  , match: { color: <span class="hljs-string">'black'</span> }
  , options: { sort: { name: <span class="hljs-number">-1</span> }}
}).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, kittens</span>) </span>{
  <span class="hljs-built_in">console</span>.log(kittens[<span class="hljs-number">0</span>].owner.name) <span class="hljs-comment">// Zoopa</span>
})

<span class="hljs-comment">// alternatively</span>
Kitten.find().populate(<span class="hljs-string">'owner'</span>, <span class="hljs-string">'name'</span>, <span class="hljs-literal">null</span>, {sort: { name: <span class="hljs-number">-1</span> }}).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, kittens</span>) </span>{
  <span class="hljs-built_in">console</span>.log(kittens[<span class="hljs-number">0</span>].owner.name) <span class="hljs-comment">// Zoopa</span>
})</code></pre>

<p>Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.</p></div><hr class="separate-api-elements"><h3 id="query_Query-read"><a href="#query_Query-read">Query.prototype.read()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">pref <span class="method-type">&laquo;String&raquo;</span> one of the listed preference options or aliases</li><li class="param">[tags] <span class="method-type">&laquo;Array&raquo;</span> optional tags for this query</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Determines the MongoDB nodes from which to read.</p>

<h4>Preferences:</h4>

<pre><code>primary - (<span class="hljs-keyword">default</span>) Read <span class="hljs-keyword">from</span> primary only. Operations will produce an error <span class="hljs-keyword">if</span> primary is unavailable. Cannot be combined <span class="hljs-keyword">with</span> tags.
secondary            Read <span class="hljs-keyword">from</span> secondary <span class="hljs-keyword">if</span> available, otherwise error.
primaryPreferred     Read <span class="hljs-keyword">from</span> primary <span class="hljs-keyword">if</span> available, otherwise a secondary.
secondaryPreferred   Read <span class="hljs-keyword">from</span> a secondary <span class="hljs-keyword">if</span> available, otherwise read <span class="hljs-keyword">from</span> the primary.
nearest              All operations read <span class="hljs-keyword">from</span> among the nearest candidates, but unlike other modes, <span class="hljs-keyword">this</span> option will include both the primary and all secondaries <span class="hljs-keyword">in</span> the random selection.</code></pre>

<p>Aliases</p>

<pre><code>p   primary
pp  primaryPreferred
s   secondary
sp  secondaryPreferred
n   nearest</code></pre>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'primary'</span>)
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'p'</span>)  <span class="hljs-comment">// same as primary</span>

<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'primaryPreferred'</span>)
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'pp'</span>) <span class="hljs-comment">// same as primaryPreferred</span>

<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'secondary'</span>)
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'s'</span>)  <span class="hljs-comment">// same as secondary</span>

<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'secondaryPreferred'</span>)
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'sp'</span>) <span class="hljs-comment">// same as secondaryPreferred</span>

<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'nearest'</span>)
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'n'</span>)  <span class="hljs-comment">// same as nearest</span>

<span class="hljs-comment">// read from secondaries with matching tags</span>
<span class="hljs-keyword">new</span> Query().read(<span class="hljs-string">'s'</span>, [{ dc:<span class="hljs-string">'sf'</span>, s: <span class="hljs-number">1</span> },{ dc:<span class="hljs-string">'ma'</span>, s: <span class="hljs-number">2</span> }])</code></pre>

<p>Read more about how to use read preferrences <a href="http://docs.mongodb.org/manual/applications/replication/#read-preference">here</a> and <a href="http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences">here</a>.</p></div><hr class="separate-api-elements"><h3 id="query_Query-regex"><a href="#query_Query-regex">Query.prototype.regex()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;String|RegExp&raquo;</span> </li></ul><div><p>Specifies a $regex query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p></div><hr class="separate-api-elements"><h3 id="query_Query-remove"><a href="#query_Query-remove">Query.prototype.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[filter] <span class="method-type">&laquo;Object|Query&raquo;</span> mongodb selector</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, writeOpResult)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Declare and/or execute this query as a remove() operation.</p>

<p>This function does not trigger any middleware</p>

<h4>Example</h4>

<pre><code>Model.remove({ artist: <span class="hljs-string">'Anne Murray'</span> }, callback)</code></pre>

<h4>Note</h4>

<p>The operation is only executed when a callback is passed. To force execution without a callback, you must first call <code>remove()</code> and then execute it by using the <code>exec()</code> method.</p>

<pre><code><span class="hljs-comment">// not executed</span>
<span class="hljs-keyword">var</span> query = Model.find().remove({ name: <span class="hljs-string">'Anne Murray'</span> })

<span class="hljs-comment">// executed</span>
query.remove({ name: <span class="hljs-string">'Anne Murray'</span> }, callback)
query.remove({ name: <span class="hljs-string">'Anne Murray'</span> }).remove(callback)

<span class="hljs-comment">// executed without a callback</span>
query.exec()

<span class="hljs-comment">// summary</span>
query.remove(conds, fn); <span class="hljs-comment">// executes</span>
query.remove(conds)
query.remove(fn) <span class="hljs-comment">// executes</span>
query.remove()</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-replaceOne"><a href="#query_Query-replaceOne">Query.prototype.replaceOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[criteria] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[doc] <span class="method-type">&laquo;Object&raquo;</span> the update command</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, writeOpResult)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Declare and/or execute this query as a replaceOne() operation. Same as <code>update()</code>, except MongoDB will replace the existing document and will not accept any atomic operators (<code>$set</code>, etc.)</p>

<p><strong>Note</strong> replaceOne will <em>not</em> fire update middleware. Use <code>pre('replaceOne')</code> and <code>post('replaceOne')</code> instead.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>replaceOne()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="query_Query-select"><a href="#query_Query-select">Query.prototype.select()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">arg <span class="method-type">&laquo;Object|String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies which document fields to include or exclude (also known as the query "projection")</p>

<p>When using string syntax, prefixing a path with <code>-</code> will flag that path as excluded. When a path does not have the <code>-</code> prefix, it is included. Lastly, if a path is prefixed with <code>+</code>, it forces inclusion of the path, which is useful for paths excluded at the <a href="/docs/api.html#schematype_SchemaType-select">schema level</a>.</p>

<p>A projection <em>must</em> be either inclusive or exclusive. In other words, you must either list the fields to include (which excludes all others), or list the fields to exclude (which implies all other fields are included). The <a href="https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/#suppress-id-field"><code>_id</code> field is the only exception because MongoDB includes it by default</a>.</p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// include a and b, exclude other fields</span>
query.select(<span class="hljs-string">'a b'</span>);

<span class="hljs-comment">// exclude c and d, include other fields</span>
query.select(<span class="hljs-string">'-c -d'</span>);

<span class="hljs-comment">// or you may use object notation, useful when</span>
<span class="hljs-comment">// you have keys already prefixed with a "-"</span>
query.select({ a: <span class="hljs-number">1</span>, b: <span class="hljs-number">1</span> });
query.select({ c: <span class="hljs-number">0</span>, d: <span class="hljs-number">0</span> });

<span class="hljs-comment">// force inclusion of field excluded at schema level</span>
query.select(<span class="hljs-string">'+path'</span>)</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-selected"><a href="#query_Query-selected">Query.prototype.selected()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Determines if field selection has been made.</p></div><hr class="separate-api-elements"><h3 id="query_Query-selectedExclusively"><a href="#query_Query-selectedExclusively">Query.prototype.selectedExclusively()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Determines if exclusive field selection has been made.</p>

<pre><code>query.selectedExclusively() <span class="hljs-comment">// false</span>
query.select(<span class="hljs-string">'-name'</span>)
query.selectedExclusively() <span class="hljs-comment">// true</span>
query.selectedInclusively() <span class="hljs-comment">// false</span></code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-selectedInclusively"><a href="#query_Query-selectedInclusively">Query.prototype.selectedInclusively()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Determines if inclusive field selection has been made.</p>

<pre><code>query.selectedInclusively() <span class="hljs-comment">// false</span>
query.select(<span class="hljs-string">'name'</span>)
query.selectedInclusively() <span class="hljs-comment">// true</span></code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-session"><a href="#query_Query-session">Query.prototype.session()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[session] <span class="method-type">&laquo;ClientSession&raquo;</span> from <code>await conn.startSession()</code></li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Sets the <a href="https://docs.mongodb.com/manual/reference/server-sessions/">MongoDB session</a> associated with this query. Sessions are how you mark a query as part of a <a href="/docs/transactions.html">transaction</a>.</p>

<p>Calling <code>session(null)</code> removes the session from this query.</p></div><hr class="separate-api-elements"><h3 id="query_Query-set"><a href="#query_Query-set">Query.prototype.set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String|Object&raquo;</span> path or object of key/value pairs to set</li><li class="param">[val] <span class="method-type">&laquo;Any&raquo;</span> the value to set</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Adds a <code>$set</code> to this query's update without changing the operation. This is useful for query middleware so you can add an update regardless of whether you use <code>updateOne()</code>, <code>updateMany()</code>, <code>findOneAndUpdate()</code>, etc.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Updates `{ $set: { updatedAt: new Date() } }`</span>
<span class="hljs-keyword">new</span> Query().updateOne({}, {}).set(<span class="hljs-string">'updatedAt'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>());
<span class="hljs-keyword">new</span> Query().updateMany({}, {}).set({ updatedAt: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>() });</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-setOptions"><a href="#query_Query-setOptions">Query.prototype.setOptions()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>Sets query options. Some options only make sense for certain operations.</p>

<h4>Options:</h4>

<p>The following options are only for <code>find()</code>:</p>

<ul>
<li><a href="http://www.mongodb.org/display/DOCS/Tailable+Cursors">tailable</a></li>
<li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort()%7D%7D">sort</a></li>
<li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D">limit</a></li>
<li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D">skip</a></li>
<li><a href="https://docs.mongodb.org/v3.2/reference/operator/meta/maxScan/#metaOp._S_maxScan">maxscan</a></li>
<li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D">batchSize</a></li>
<li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment">comment</a></li>
<li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D">snapshot</a></li>
<li><a href="http://docs.mongodb.org/manual/applications/replication/#read-preference">readPreference</a></li>
<li><a href="http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint">hint</a></li>
</ul>

<p>The following options are only for <code>update()</code>, <code>updateOne()</code>, <code>updateMany()</code>, <code>replaceOne()</code>, <code>findOneAndUpdate()</code>, and <code>findByIdAndUpdate()</code>:</p>

<ul>
<li><a href="https://docs.mongodb.com/manual/reference/method/db.collection.update/">upsert</a></li>
<li><a href="https://docs.mongodb.com/manual/reference/method/db.collection.update/">writeConcern</a></li>
</ul>

<p>The following options are only for <code>find()</code>, <code>findOne()</code>, <code>findById()</code>, <code>findOneAndUpdate()</code>, and <code>findByIdAndUpdate()</code>:</p>

<ul>
<li><a href="./api.html#query_Query-lean">lean</a></li>
</ul>

<p>The following options are only for all operations <strong>except</strong> <code>update()</code>, <code>updateOne()</code>, <code>updateMany()</code>, <code>remove()</code>, <code>deleteOne()</code>, and <code>deleteMany()</code>:</p>

<ul>
<li><a href="https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/">maxTimeMS</a></li>
</ul>

<h2>The following options are for all operations</h2>

<ul>
<li><a href="https://docs.mongodb.com/manual/reference/collation/">collation</a></li>
<li><a href="https://docs.mongodb.com/manual/reference/server-sessions/">session</a></li>
</ul></div><hr class="separate-api-elements"><h3 id="query_Query-size"><a href="#query_Query-size">Query.prototype.size()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies a $size query condition.</p>

<p>When called with one argument, the most recent path passed to <code>where()</code> is used.</p>

<h4>Example</h4>

<pre><code>MyModel.where(<span class="hljs-string">'tags'</span>).size(<span class="hljs-number">0</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);

  assert(<span class="hljs-built_in">Array</span>.isArray(docs));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'documents with 0 tags'</span>, docs);
})</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-skip"><a href="#query_Query-skip">Query.prototype.skip()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> </li></ul><div><p>Specifies the number of documents to skip.</p>

<h4>Example</h4>

<pre><code>query.skip(<span class="hljs-number">100</span>).limit(<span class="hljs-number">20</span>)</code></pre>

<h4>Note</h4>

<p>Cannot be used with <code>distinct()</code></p></div><hr class="separate-api-elements"><h3 id="query_Query-slaveOk"><a href="#query_Query-slaveOk">Query.prototype.slaveOk()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">v <span class="method-type">&laquo;Boolean&raquo;</span> defaults to true</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p><em>DEPRECATED</em> Sets the slaveOk option.</p>

<p><strong>Deprecated</strong> in MongoDB 2.2 in favor of <a href="#query_Query-read">read preferences</a>.</p>

<h4>Example:</h4>

<pre><code>query.slaveOk() <span class="hljs-comment">// true</span>
query.slaveOk(<span class="hljs-literal">true</span>)
query.slaveOk(<span class="hljs-literal">false</span>)</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-slice"><a href="#query_Query-slice">Query.prototype.slice()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">val <span class="method-type">&laquo;Number&raquo;</span> number/range of elements to slice</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies a $slice projection for an array.</p>

<h4>Example</h4>

<pre><code>query.slice(<span class="hljs-string">'comments'</span>, <span class="hljs-number">5</span>)
query.slice(<span class="hljs-string">'comments'</span>, <span class="hljs-number">-5</span>)
query.slice(<span class="hljs-string">'comments'</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">5</span>])
query.where(<span class="hljs-string">'comments'</span>).slice(<span class="hljs-number">5</span>)
query.where(<span class="hljs-string">'comments'</span>).slice([<span class="hljs-number">-10</span>, <span class="hljs-number">5</span>])</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-snapshot"><a href="#query_Query-snapshot">Query.prototype.snapshot()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies this query as a <code>snapshot</code> query.</p>

<h4>Example</h4>

<pre><code>query.snapshot() <span class="hljs-comment">// true</span>
query.snapshot(<span class="hljs-literal">true</span>)
query.snapshot(<span class="hljs-literal">false</span>)</code></pre>

<h4>Note</h4>

<p>Cannot be used with <code>distinct()</code></p></div><hr class="separate-api-elements"><h3 id="query_Query-sort"><a href="#query_Query-sort">Query.prototype.sort()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">arg <span class="method-type">&laquo;Object|String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Sets the sort order</p>

<p>If an object is passed, values allowed are <code>asc</code>, <code>desc</code>, <code>ascending</code>, <code>descending</code>, <code>1</code>, and <code>-1</code>.</p>

<p>If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with <code>-</code> which will be treated as descending.</p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// sort by "field" ascending and "test" descending</span>
query.sort({ field: <span class="hljs-string">'asc'</span>, test: <span class="hljs-number">-1</span> });

<span class="hljs-comment">// equivalent</span>
query.sort(<span class="hljs-string">'field -test'</span>);</code></pre>

<h4>Note</h4>

<p>Cannot be used with <code>distinct()</code></p></div><hr class="separate-api-elements"><h3 id="query_Query-tailable"><a href="#query_Query-tailable">Query.prototype.tailable()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">bool <span class="method-type">&laquo;Boolean&raquo;</span> defaults to true</li><li class="param">[opts] <span class="method-type">&laquo;Object&raquo;</span> options to set</li><li class="param">[opts.numberOfRetries] <span class="method-type">&laquo;Number&raquo;</span> if cursor is exhausted, retry this many times before giving up</li><li class="param">[opts.tailableRetryInterval] <span class="method-type">&laquo;Number&raquo;</span> if cursor is exhausted, wait this many milliseconds before retrying</li></ul><div><p>Sets the tailable option (for use with capped collections).</p>

<h4>Example</h4>

<pre><code>query.tailable() <span class="hljs-comment">// true</span>
query.tailable(<span class="hljs-literal">true</span>)
query.tailable(<span class="hljs-literal">false</span>)</code></pre>

<h4>Note</h4>

<p>Cannot be used with <code>distinct()</code></p></div><hr class="separate-api-elements"><h3 id="query_Query-then"><a href="#query_Query-then">Query.prototype.then()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[resolve] <span class="method-type">&laquo;Function&raquo;</span> </li><li class="param">[reject] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Executes the query returning a <code>Promise</code> which will be resolved with either the doc(s) or rejected with the error.</p></div><hr class="separate-api-elements"><h3 id="query_Query-toConstructor"><a href="#query_Query-toConstructor">Query.prototype.toConstructor()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> subclass-of-Query</li></ul><div><p>Converts this query to a customized, reusable query constructor with all arguments and options retained.</p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// Create a query for adventure movies and read from the primary</span>
<span class="hljs-comment">// node in the replica-set unless it is down, in which case we'll</span>
<span class="hljs-comment">// read from a secondary node.</span>
<span class="hljs-keyword">var</span> query = Movie.find({ tags: <span class="hljs-string">'adventure'</span> }).read(<span class="hljs-string">'primaryPreferred'</span>);

<span class="hljs-comment">// create a custom Query constructor based off these settings</span>
<span class="hljs-keyword">var</span> Adventure = query.toConstructor();

<span class="hljs-comment">// Adventure is now a subclass of mongoose.Query and works the same way but with the</span>
<span class="hljs-comment">// default query parameters and options set.</span>
Adventure().exec(callback)

<span class="hljs-comment">// further narrow down our query results while still using the previous settings</span>
Adventure().where({ name: <span class="hljs-regexp">/^Life/</span> }).exec(callback);

<span class="hljs-comment">// since Adventure is a stand-alone constructor we can also add our own</span>
<span class="hljs-comment">// helper methods and getters without impacting global queries</span>
Adventure.prototype.startsWith = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">prefix</span>) </span>{
  <span class="hljs-keyword">this</span>.where({ name: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> + prefix) })
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
<span class="hljs-built_in">Object</span>.defineProperty(Adventure.prototype, <span class="hljs-string">'highlyRated'</span>, {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.where({ rating: { $gt: <span class="hljs-number">4.5</span> }});
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }
})
Adventure().highlyRated.startsWith(<span class="hljs-string">'Life'</span>).exec(callback)</code></pre>

<p>New in 3.7.3</p></div><hr class="separate-api-elements"><h3 id="query_Query-update"><a href="#query_Query-update">Query.prototype.update()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[criteria] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[doc] <span class="method-type">&laquo;Object&raquo;</span> the update command</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options.multipleCastError] <span class="method-type">&laquo;Boolean&raquo;</span> by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional, params are (error, writeOpResult)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Declare and/or execute this query as an update() operation.</p>

<p><em>All paths passed that are not $atomic operations will become $set ops.</em></p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>update()</code></li>
</ul>

<h4>Example</h4>

<pre><code>Model.where({ _id: id }).update({ title: <span class="hljs-string">'words'</span> })

<span class="hljs-comment">// becomes</span>

Model.where({ _id: id }).update({ $set: { title: <span class="hljs-string">'words'</span> }})</code></pre>

<h4>Valid options:</h4>

<ul>
<li><code>upsert</code> (boolean) whether to create the doc if it doesn't match (false)</li>
<li><code>multi</code> (boolean) whether multiple documents should be updated (false)</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>strict</code> (boolean) overrides the <code>strict</code> option for this update</li>
<li><code>overwrite</code> (boolean) disables update-only mode, allowing you to overwrite the doc (false)</li>
<li><code>context</code> (string) if set to 'query' and <code>runValidators</code> is on, <code>this</code> will refer to the query in custom validator functions that update validation runs. Does nothing if <code>runValidators</code> is false.</li>
<li><code>read</code></li>
<li><code>writeConcern</code></li>
</ul>

<h4>Note</h4>

<p>Passing an empty object <code>{}</code> as the doc will result in a no-op unless the <code>overwrite</code> option is passed. Without the <code>overwrite</code> option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.</p>

<h4>Note</h4>

<p>The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the <code>exec()</code> method.</p>

<pre><code>var q = Model.where({ _id: id });
q.update({ $set: { name: 'bob' }}).update(); // not executed

q.update({ $set: { name: 'bob' }}).exec(); // executed

// keys that are not $atomic ops become $set.
// this executes the same command as the previous example.
q.update({ name: 'bob' }).exec();

// overwriting with empty docs
var q = Model.where({ _id: id }).setOptions({ overwrite: true })
q.update({ }, callback); // executes

// multi update with overwrite to empty doc
var q = Model.where({ _id: id });
q.setOptions({ multi: true, overwrite: true })
q.update({ });
q.update(callback); // executed

// multi updates
Model.where()
     .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)

// more multi updates
Model.where()
     .setOptions({ multi: true })
     .update({ $set: { arr: [] }}, callback)

// single update by default
Model.where({ email: '<a href='mailto:address@example.com'>address@example.com</a>' })
     .update({ $inc: { counter: 1 }}, callback)
</code></pre>

<p>API summary</p>

<pre><code>update(criteria, doc, options, cb) <span class="hljs-comment">// executes</span>
update(criteria, doc, options)
update(criteria, doc, cb) <span class="hljs-comment">// executes</span>
update(criteria, doc)
update(doc, cb) <span class="hljs-comment">// executes</span>
update(doc)
update(cb) <span class="hljs-comment">// executes</span>
update(<span class="hljs-literal">true</span>) <span class="hljs-comment">// executes</span>
update()</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-updateMany"><a href="#query_Query-updateMany">Query.prototype.updateMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[criteria] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[doc] <span class="method-type">&laquo;Object&raquo;</span> the update command</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> optional params are (error, writeOpResult)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Declare and/or execute this query as an updateMany() operation. Same as <code>update()</code>, except MongoDB will update <em>all</em> documents that match <code>criteria</code> (as opposed to just the first one) regardless of the value of the <code>multi</code> option.</p>

<p><strong>Note</strong> updateMany will <em>not</em> fire update middleware. Use <code>pre('updateMany')</code> and <code>post('updateMany')</code> instead.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>updateMany()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="query_Query-updateOne"><a href="#query_Query-updateOne">Query.prototype.updateOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[criteria] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[doc] <span class="method-type">&laquo;Object&raquo;</span> the update command</li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> params are (error, writeOpResult)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Declare and/or execute this query as an updateOne() operation. Same as <code>update()</code>, except MongoDB will update <em>only</em> the first document that matches <code>criteria</code> regardless of the value of the <code>multi</code> option.</p>

<p><strong>Note</strong> updateOne will <em>not</em> fire update middleware. Use <code>pre('updateOne')</code> and <code>post('updateOne')</code> instead.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>updateOne()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="query_Query-use$geoWithin"><a href="#query_Query-use$geoWithin">Query.prototype.use$geoWithin</a></h3><div><p>Flag to opt out of using <code>$geoWithin</code>.</p>

<pre><code>mongoose.Query.use$geoWithin = <span class="hljs-literal">false</span>;</code></pre>

<p>MongoDB 2.4 deprecated the use of <code>$within</code>, replacing it with <code>$geoWithin</code>. Mongoose uses <code>$geoWithin</code> by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to <code>false</code> so your <code>within()</code> queries continue to work.</p></div><hr class="separate-api-elements"><h3 id="query_Query-w"><a href="#query_Query-w">Query.prototype.w()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;String|number&raquo;</span> 0 for fire-and-forget, 1 for acknowledged by one server, &#39;majority&#39; for majority of the replica set, or <a href="https://docs.mongodb.com/manual/reference/write-concern/#w-option">any of the more advanced options</a>.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Sets the specified number of <code>mongod</code> servers, or tag set of <code>mongod</code> servers, that must acknowledge this write before this write is considered successful.</p>

<h2>This option is only valid for operations that write to the database</h2>

<ul>
<li><code>deleteOne()</code></li>
<li><code>deleteMany()</code></li>
<li><code>findOneAndDelete()</code></li>
<li><code>findOneAndUpdate()</code></li>
<li><code>remove()</code></li>
<li><code>update()</code></li>
<li><code>updateOne()</code></li>
<li><code>updateMany()</code></li>
</ul></div><hr class="separate-api-elements"><h3 id="query_Query-where"><a href="#query_Query-where">Query.prototype.where()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[path] <span class="method-type">&laquo;String|Object&raquo;</span> </li><li class="param">[val] <span class="method-type">&laquo;any&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Specifies a <code>path</code> for use with chaining.</p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// instead of writing:</span>
User.find({age: {$gte: <span class="hljs-number">21</span>, $lte: <span class="hljs-number">65</span>}}, callback);

<span class="hljs-comment">// we can instead write:</span>
User.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>);

<span class="hljs-comment">// passing query conditions is permitted</span>
User.find().where({ name: <span class="hljs-string">'vonderful'</span> })

<span class="hljs-comment">// chaining</span>
User
.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>)
.where(<span class="hljs-string">'name'</span>, <span class="hljs-regexp">/^vonderful/i</span>)
.where(<span class="hljs-string">'friends'</span>).slice(<span class="hljs-number">10</span>)
.exec(callback)</code></pre></div><hr class="separate-api-elements"><h3 id="query_Query-within"><a href="#query_Query-within">Query.prototype.within()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>Defines a <code>$within</code> or <code>$geoWithin</code> argument for geo-spatial queries.</p>

<h4>Example</h4>

<pre><code>query.where(path).within().box()
query.where(path).within().circle()
query.where(path).within().geometry()

query.where(<span class="hljs-string">'loc'</span>).within({ center: [<span class="hljs-number">50</span>,<span class="hljs-number">50</span>], radius: <span class="hljs-number">10</span>, unique: <span class="hljs-literal">true</span>, spherical: <span class="hljs-literal">true</span> });
query.where(<span class="hljs-string">'loc'</span>).within({ box: [[<span class="hljs-number">40.73</span>, <span class="hljs-number">-73.9</span>], [<span class="hljs-number">40.7</span>, <span class="hljs-number">-73.988</span>]] });
query.where(<span class="hljs-string">'loc'</span>).within({ polygon: [[],[],[],[]] });

query.where(<span class="hljs-string">'loc'</span>).within([], [], []) <span class="hljs-comment">// polygon</span>
query.where(<span class="hljs-string">'loc'</span>).within([], []) <span class="hljs-comment">// box</span>
query.where(<span class="hljs-string">'loc'</span>).within({ type: <span class="hljs-string">'LineString'</span>, coordinates: [...] }); <span class="hljs-comment">// geometry</span></code></pre>

<p><strong>MUST</strong> be used after <code>where()</code>.</p>

<h4>NOTE:</h4>

<p>As of Mongoose 3.7, <code>$geoWithin</code> is always used for queries. To change this behavior, see <a href="#query_Query-use%2524geoWithin">Query.use$geoWithin</a>.</p>

<h4>NOTE:</h4>

<p>In Mongoose 3.7, <code>within</code> changed from a getter to a function. If you need the old syntax, use <a href="https://github.com/ebensing/mongoose-within">this</a>.</p></div><hr class="separate-api-elements"><h3 id="query_Query-wtimeout"><a href="#query_Query-wtimeout">Query.prototype.wtimeout()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;number&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> this</li></ul><div><p>If <code>w > 1</code>, the maximum amount of time to wait for this write to propagate through the replica set before this operation fails. The default is <code>0</code>, which means no timeout.</p>

<h2>This option is only valid for operations that write to the database</h2>

<ul>
<li><code>deleteOne()</code></li>
<li><code>deleteMany()</code></li>
<li><code>findOneAndDelete()</code></li>
<li><code>findOneAndUpdate()</code></li>
<li><code>remove()</code></li>
<li><code>update()</code></li>
<li><code>updateOne()</code></li>
<li><code>updateMany()</code></li>
</ul></div><hr class="separate-api"><h2 id="Cursor/querycursor"><a href="#Cursor/querycursor">Cursor/querycursor</a></h2><ul><li><a href="#querycursor_QueryCursor">QueryCursor()</a></li><li><a href="#querycursor_QueryCursor-addCursorFlag">QueryCursor.prototype.addCursorFlag()</a></li><li><a href="#querycursor_QueryCursor-close">QueryCursor.prototype.close()</a></li><li><a href="#querycursor_QueryCursor-eachAsync">QueryCursor.prototype.eachAsync()</a></li><li><a href="#querycursor_QueryCursor-map">QueryCursor.prototype.map()</a></li><li><a href="#querycursor_QueryCursor-next">QueryCursor.prototype.next()</a></li></ul><hr class="separate-api-elements"><h3 id="querycursor_QueryCursor"><a href="#querycursor_QueryCursor">QueryCursor()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">query <span class="method-type">&laquo;Query&raquo;</span> </li><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> query options passed to <code>.find()</code></li></ul><div><p>A QueryCursor is a concurrency primitive for processing query results one document at a time. A QueryCursor fulfills the Node.js streams3 API, in addition to several other mechanisms for loading documents from MongoDB one at a time.</p>

<p>QueryCursors execute the model's pre find hooks, but <strong>not</strong> the model's post find hooks.</p>

<p>Unless you're an advanced user, do <strong>not</strong> instantiate this class directly. Use <a href="/docs/api.html#query_Query-cursor"><code>Query#cursor()</code></a> instead.</p></div><hr class="separate-api-elements"><h3 id="querycursor_QueryCursor-addCursorFlag"><a href="#querycursor_QueryCursor-addCursorFlag">QueryCursor.prototype.addCursorFlag()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">flag <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">value <span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;AggregationCursor&raquo;</span> this</li></ul><div><p>Adds a <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag">cursor flag</a>. Useful for setting the <code>noCursorTimeout</code> and <code>tailable</code> flags.</p></div><hr class="separate-api-elements"><h3 id="querycursor_QueryCursor-close"><a href="#querycursor_QueryCursor-close">QueryCursor.prototype.close()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Marks this cursor as closed. Will stop streaming and subsequent calls to <code>next()</code> will error.</p></div><hr class="separate-api-elements"><h3 id="querycursor_QueryCursor-eachAsync"><a href="#querycursor_QueryCursor-eachAsync">QueryCursor.prototype.eachAsync()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options.parallel] <span class="method-type">&laquo;Number&raquo;</span> the number of promises to execute in parallel. Defaults to 1.</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> executed when all docs have been processed</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Execute <code>fn</code> for every document in the cursor. If <code>fn</code> returns a promise, will wait for the promise to resolve before iterating on to the next one. Returns a promise that resolves when done.</p></div><hr class="separate-api-elements"><h3 id="querycursor_QueryCursor-map"><a href="#querycursor_QueryCursor-map">QueryCursor.prototype.map()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;QueryCursor&raquo;</span> </li></ul><div><p>Registers a transform function which subsequently maps documents retrieved via the streams interface or <code>.next()</code></p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// Map documents returned by `data` events</span>
Thing.
  find({ name: <span class="hljs-regexp">/^hello/</span> }).
  cursor().
  map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
   doc.foo = <span class="hljs-string">"bar"</span>;
   <span class="hljs-keyword">return</span> doc;
  })
  on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{ <span class="hljs-built_in">console</span>.log(doc.foo); });

<span class="hljs-comment">// Or map documents returned by `.next()`</span>
<span class="hljs-keyword">var</span> cursor = Thing.find({ name: <span class="hljs-regexp">/^hello/</span> }).
  cursor().
  map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
    doc.foo = <span class="hljs-string">"bar"</span>;
    <span class="hljs-keyword">return</span> doc;
  });
cursor.next(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(doc.foo);
});</code></pre></div><hr class="separate-api-elements"><h3 id="querycursor_QueryCursor-next"><a href="#querycursor_QueryCursor-next">QueryCursor.prototype.next()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Get the next document from this cursor. Will return <code>null</code> when there are no documents left.</p></div><hr class="separate-api"><h2 id="Aggregate"><a href="#Aggregate">Aggregate</a></h2><ul><li><a href="#aggregate_Aggregate">Aggregate()</a></li><li><a href="#aggregate_Aggregate-addCursorFlag">Aggregate.prototype.addCursorFlag()</a></li><li><a href="#aggregate_Aggregate-addFields">Aggregate.prototype.addFields()</a></li><li><a href="#aggregate_Aggregate-allowDiskUse">Aggregate.prototype.allowDiskUse()</a></li><li><a href="#aggregate_Aggregate-append">Aggregate.prototype.append()</a></li><li><a href="#aggregate_Aggregate-collation">Aggregate.prototype.collation()</a></li><li><a href="#aggregate_Aggregate-count">Aggregate.prototype.count()</a></li><li><a href="#aggregate_Aggregate-cursor">Aggregate.prototype.cursor()</a></li><li><a href="#aggregate_Aggregate-exec">Aggregate.prototype.exec()</a></li><li><a href="#aggregate_Aggregate-explain">Aggregate.prototype.explain()</a></li><li><a href="#aggregate_Aggregate-facet">Aggregate.prototype.facet()</a></li><li><a href="#aggregate_Aggregate-graphLookup">Aggregate.prototype.graphLookup()</a></li><li><a href="#aggregate_Aggregate-group">Aggregate.prototype.group()</a></li><li><a href="#aggregate_Aggregate-hint">Aggregate.prototype.hint()</a></li><li><a href="#aggregate_Aggregate-limit">Aggregate.prototype.limit()</a></li><li><a href="#aggregate_Aggregate-lookup">Aggregate.prototype.lookup()</a></li><li><a href="#aggregate_Aggregate-match">Aggregate.prototype.match()</a></li><li><a href="#aggregate_Aggregate-model">Aggregate.prototype.model()</a></li><li><a href="#aggregate_Aggregate-near">Aggregate.prototype.near()</a></li><li><a href="#aggregate_Aggregate-option">Aggregate.prototype.option()</a></li><li><a href="#aggregate_Aggregate-pipeline">Aggregate.prototype.pipeline()</a></li><li><a href="#aggregate_Aggregate-project">Aggregate.prototype.project()</a></li><li><a href="#aggregate_Aggregate-read">Aggregate.prototype.read()</a></li><li><a href="#aggregate_Aggregate-replaceRoot">Aggregate.prototype.replaceRoot()</a></li><li><a href="#aggregate_Aggregate-sample">Aggregate.prototype.sample()</a></li><li><a href="#aggregate_Aggregate-skip">Aggregate.prototype.skip()</a></li><li><a href="#aggregate_Aggregate-sort">Aggregate.prototype.sort()</a></li><li><a href="#aggregate_Aggregate-sortByCount">Aggregate.prototype.sortByCount()</a></li><li><a href="#aggregate_Aggregate-then">Aggregate.prototype.then()</a></li><li><a href="#aggregate_Aggregate-unwind">Aggregate.prototype.unwind()</a></li></ul><hr class="separate-api-elements"><h3 id="aggregate_Aggregate"><a href="#aggregate_Aggregate">Aggregate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[pipeline] <span class="method-type">&laquo;Array&raquo;</span> aggregation pipeline as an array of objects</li></ul><div><p>Aggregate constructor used for building aggregation pipelines. Do not instantiate this class directly, use <a href="/docs/api.html#aggregate_aggregate">Model.aggregate()</a> instead.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> aggregate = Model.aggregate([
  { $project: { a: <span class="hljs-number">1</span>, b: <span class="hljs-number">1</span> } },
  { $skip: <span class="hljs-number">5</span> }
]);

Model.
  aggregate([{ $match: { age: { $gte: <span class="hljs-number">21</span> }}}]).
  unwind(<span class="hljs-string">'tags'</span>).
  exec(callback);</code></pre>

<h4>Note:</h4>

<ul>
<li>The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).</li>
<li>Mongoose does <strong>not</strong> cast pipeline stages. The below will <strong>not</strong> work unless <code>_id</code> is a string in the database</li>
</ul>

<div class="highlight"><pre lang="javascript">  new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);
  // Do this instead to cast to an ObjectId
  new Aggregate([{ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } }]);
</pre></div></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-addCursorFlag"><a href="#aggregate_Aggregate-addCursorFlag">Aggregate.prototype.addCursorFlag()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">flag <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">value <span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><div><p>Adds a <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag">cursor flag</a></p>

<h4>Example:</h4>

<pre><code>Model.aggregate(..).addCursorFlag(<span class="hljs-string">'noCursorTimeout'</span>, <span class="hljs-literal">true</span>).exec();</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-addFields"><a href="#aggregate_Aggregate-addFields">Aggregate.prototype.addFields()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">arg <span class="method-type">&laquo;Object&raquo;</span> field specification</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends a new $addFields operator to this aggregate pipeline. Requires MongoDB v3.4+ to work</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// adding new fields based on existing fields</span>
aggregate.addFields({
    newField: <span class="hljs-string">'$b.nested'</span>
  , plusTen: { $add: [<span class="hljs-string">'$val'</span>, <span class="hljs-number">10</span>]}
  , sub: {
       name: <span class="hljs-string">'$a'</span>
    }
})

<span class="hljs-comment">// etc</span>
aggregate.addFields({ salary_k: { $divide: [ <span class="hljs-string">"$salary"</span>, <span class="hljs-number">1000</span> ] } });</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-allowDiskUse"><a href="#aggregate_Aggregate-allowDiskUse">Aggregate.prototype.allowDiskUse()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">value <span class="method-type">&laquo;Boolean&raquo;</span> Should tell server it can use hard drive to store data during aggregation.</li><li class="param">[tags] <span class="method-type">&laquo;Array&raquo;</span> optional tags for this query</li></ul><div><p>Sets the allowDiskUse option for the aggregation query (ignored for &lt; 2.6.0)</p>

<h4>Example:</h4>

<pre><code>Model.aggregate(..).allowDiskUse(<span class="hljs-literal">true</span>).exec(callback)</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-append"><a href="#aggregate_Aggregate-append">Aggregate.prototype.append()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">ops <span class="method-type">&laquo;Object&raquo;</span> operator(s) to append</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends new operators to this aggregate pipeline</p>

<h4>Examples:</h4>

<pre><code>aggregate.append({ $project: { field: <span class="hljs-number">1</span> }}, { $limit: <span class="hljs-number">2</span> });

<span class="hljs-comment">// or pass an array</span>
<span class="hljs-keyword">var</span> pipeline = [{ $match: { daw: <span class="hljs-string">'Logic Audio X'</span> }} ];
aggregate.append(pipeline);</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-collation"><a href="#aggregate_Aggregate-collation">Aggregate.prototype.collation()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">collation <span class="method-type">&laquo;Object&raquo;</span> options</li></ul><div><p>Adds a collation</p>

<h4>Example:</h4>

<pre><code>Model.aggregate(..).collation({ locale: <span class="hljs-string">'en_US'</span>, strength: <span class="hljs-number">1</span> }).exec();</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-count"><a href="#aggregate_Aggregate-count">Aggregate.prototype.count()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">the <span class="method-type">&laquo;String&raquo;</span> name of the count field</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends a new $count operator to this aggregate pipeline.</p>

<h4>Examples:</h4>

<pre><code>aggregate.count(<span class="hljs-string">"userCount"</span>);</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-cursor"><a href="#aggregate_Aggregate-cursor">Aggregate.prototype.cursor()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">options.batchSize <span class="method-type">&laquo;Number&raquo;</span> set the cursor batch size</li><li class="param">[options.useMongooseAggCursor] <span class="method-type">&laquo;Boolean&raquo;</span> use experimental mongoose-specific aggregation cursor (for <code>eachAsync()</code> and other query cursor semantics)</li></ul><div><p>Sets the cursor option option for the aggregation query (ignored for &lt; 2.6.0). Note the different syntax below: .exec() returns a cursor object, and no callback is necessary.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> cursor = Model.aggregate(..).cursor({ batchSize: <span class="hljs-number">1000</span> }).exec();
cursor.each(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-comment">// use doc</span>
});</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-exec"><a href="#aggregate_Aggregate-exec">Aggregate.prototype.exec()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Executes the aggregate pipeline on the currently bound Model.</p>

<h4>Example:</h4>

<pre><code>aggregate.exec(callback);

<span class="hljs-comment">// Because a promise is returned, the `callback` is optional.</span>
<span class="hljs-keyword">var</span> promise = aggregate.exec();
promise.then(..);</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-explain"><a href="#aggregate_Aggregate-explain">Aggregate.prototype.explain()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Execute the aggregation with explain</p>

<h4>Example:</h4>

<pre><code>Model.aggregate(..).explain(callback)</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-facet"><a href="#aggregate_Aggregate-facet">Aggregate.prototype.facet()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">facet <span class="method-type">&laquo;Object&raquo;</span> options</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> this</li></ul><div><p>Combines multiple aggregation pipelines.</p>

<h4>Example:</h4>

<pre><code>Model.aggregate(...)
 .facet({
   books: [{ groupBy: <span class="hljs-string">'$author'</span> }],
   price: [{ $bucketAuto: { groupBy: <span class="hljs-string">'$price'</span>, buckets: <span class="hljs-number">2</span> } }]
 })
 .exec();

<span class="hljs-comment">// Output: { books: [...], price: [{...}, {...}] }</span></code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-graphLookup"><a href="#aggregate_Aggregate-graphLookup">Aggregate.prototype.graphLookup()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> to $graphLookup as described in the above link</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.</p>

<p>Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if <code>{ allowDiskUse: true }</code> is specified.</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`</span>
 aggregate.graphLookup({ <span class="hljs-keyword">from</span>: <span class="hljs-string">'courses'</span>, startWith: <span class="hljs-string">'$prerequisite'</span>, connectFromField: <span class="hljs-string">'prerequisite'</span>, connectToField: <span class="hljs-string">'name'</span>, <span class="hljs-keyword">as</span>: <span class="hljs-string">'prerequisites'</span>, maxDepth: <span class="hljs-number">3</span> }) <span class="hljs-comment">// this will recursively search the 'courses' collection up to 3 prerequisites</span></code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-group"><a href="#aggregate_Aggregate-group">Aggregate.prototype.group()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">arg <span class="method-type">&laquo;Object&raquo;</span> $group operator contents</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends a new custom $group operator to this aggregate pipeline.</p>

<h4>Examples:</h4>

<pre><code>aggregate.group({ _id: <span class="hljs-string">"$department"</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-hint"><a href="#aggregate_Aggregate-hint">Aggregate.prototype.hint()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">value <span class="method-type">&laquo;Object|String&raquo;</span> a hint object or the index name</li></ul><div><p>Sets the hint option for the aggregation query (ignored for &lt; 3.6.0)</p>

<h4>Example:</h4>

<pre><code>Model.aggregate(..).hint({ qty: <span class="hljs-number">1</span>, category: <span class="hljs-number">1</span> } }).exec(callback)</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-limit"><a href="#aggregate_Aggregate-limit">Aggregate.prototype.limit()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">num <span class="method-type">&laquo;Number&raquo;</span> maximum number of records to pass to the next stage</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends a new $limit operator to this aggregate pipeline.</p>

<h4>Examples:</h4>

<pre><code>aggregate.limit(<span class="hljs-number">10</span>);</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-lookup"><a href="#aggregate_Aggregate-lookup">Aggregate.prototype.lookup()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> to $lookup as described in the above link</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends new custom $lookup operator(s) to this aggregate pipeline.</p>

<h4>Examples:</h4>

<pre><code>aggregate.lookup({ <span class="hljs-keyword">from</span>: <span class="hljs-string">'users'</span>, localField: <span class="hljs-string">'userId'</span>, foreignField: <span class="hljs-string">'_id'</span>, <span class="hljs-keyword">as</span>: <span class="hljs-string">'users'</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-match"><a href="#aggregate_Aggregate-match">Aggregate.prototype.match()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">arg <span class="method-type">&laquo;Object&raquo;</span> $match operator contents</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends a new custom $match operator to this aggregate pipeline.</p>

<h4>Examples:</h4>

<pre><code>aggregate.match({ department: { $<span class="hljs-keyword">in</span>: [ <span class="hljs-string">"sales"</span>, <span class="hljs-string">"engineering"</span> ] } });</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-model"><a href="#aggregate_Aggregate-model">Aggregate.prototype.model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">model <span class="method-type">&laquo;Model&raquo;</span> the model to which the aggregate is to be bound</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Binds this aggregate to a model.</p></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-near"><a href="#aggregate_Aggregate-near">Aggregate.prototype.near()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">arg <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends a new $geoNear operator to this aggregate pipeline.</p>

<h4>NOTE:</h4>

<p><strong>MUST</strong> be used as the first operator in the pipeline.</p>

<h4>Examples:</h4>

<pre><code>aggregate.near({
  near: [<span class="hljs-number">40.724</span>, <span class="hljs-number">-73.997</span>],
  distanceField: <span class="hljs-string">"dist.calculated"</span>, <span class="hljs-comment">// required</span>
  maxDistance: <span class="hljs-number">0.008</span>,
  query: { type: <span class="hljs-string">"public"</span> },
  includeLocs: <span class="hljs-string">"dist.location"</span>,
  uniqueDocs: <span class="hljs-literal">true</span>,
  num: <span class="hljs-number">5</span>
});</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-option"><a href="#aggregate_Aggregate-option">Aggregate.prototype.option()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> keys to merge into current options</li><li class="param">number <span class="method-type">&laquo;[options.maxTimeMS]&raquo;</span> limits the time this aggregation will run, see <a href="https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/">MongoDB docs on <code>maxTimeMS</code></a></li><li class="param">boolean <span class="method-type">&laquo;[options.allowDiskUse]&raquo;</span> if true, the MongoDB server will use the hard drive to store data during this aggregation</li><li class="param">object <span class="method-type">&laquo;[options.collation]&raquo;</span> see <a href="./docs/api.html#aggregate_Aggregate-collation"><code>Aggregate.prototype.collation()</code></a></li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> this</li></ul><div><p>Lets you set arbitrary options, for middleware or plugins.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> agg = Model.aggregate(..).option({ allowDiskUse: <span class="hljs-literal">true</span> }); <span class="hljs-comment">// Set the `allowDiskUse` option</span>
agg.options; <span class="hljs-comment">// `{ allowDiskUse: true }`</span></code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-pipeline"><a href="#aggregate_Aggregate-pipeline">Aggregate.prototype.pipeline()</a></h3><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Array&raquo;</span> </li></ul><div><p>Returns the current pipeline</p>

<h4>Example:</h4>

<pre><code>MyModel.aggregate().match({ test: <span class="hljs-number">1</span> }).pipeline(); <span class="hljs-comment">// [{ $match: { test: 1 } }]</span></code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-project"><a href="#aggregate_Aggregate-project">Aggregate.prototype.project()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">arg <span class="method-type">&laquo;Object|String&raquo;</span> field specification</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends a new $project operator to this aggregate pipeline.</p>

<p>Mongoose query <a href="#query_Query-select">selection syntax</a> is also supported.</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// include a, include b, exclude _id</span>
aggregate.project(<span class="hljs-string">"a b -_id"</span>);

<span class="hljs-comment">// or you may use object notation, useful when</span>
<span class="hljs-comment">// you have keys already prefixed with a "-"</span>
aggregate.project({a: <span class="hljs-number">1</span>, b: <span class="hljs-number">1</span>, _id: <span class="hljs-number">0</span>});

<span class="hljs-comment">// reshaping documents</span>
aggregate.project({
    newField: <span class="hljs-string">'$b.nested'</span>
  , plusTen: { $add: [<span class="hljs-string">'$val'</span>, <span class="hljs-number">10</span>]}
  , sub: {
       name: <span class="hljs-string">'$a'</span>
    }
})

<span class="hljs-comment">// etc</span>
aggregate.project({ salary_k: { $divide: [ <span class="hljs-string">"$salary"</span>, <span class="hljs-number">1000</span> ] } });</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-read"><a href="#aggregate_Aggregate-read">Aggregate.prototype.read()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">pref <span class="method-type">&laquo;String&raquo;</span> one of the listed preference options or their aliases</li><li class="param">[tags] <span class="method-type">&laquo;Array&raquo;</span> optional tags for this query</li></ul><div><p>Sets the readPreference option for the aggregation query.</p>

<h4>Example:</h4>

<pre><code>Model.aggregate(..).read(<span class="hljs-string">'primaryPreferred'</span>).exec(callback)</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-replaceRoot"><a href="#aggregate_Aggregate-replaceRoot">Aggregate.prototype.replaceRoot()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">the <span class="method-type">&laquo;String|Object&raquo;</span> field or document which will become the new root document</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends a new $replaceRoot operator to this aggregate pipeline.</p>

<p>Note that the <code>$replaceRoot</code> operator requires field strings to start with '$'. If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'. If you are passing in an object the strings in your expression will not be altered.</p>

<h4>Examples:</h4>

<pre><code>aggregate.replaceRoot(<span class="hljs-string">"user"</span>);

aggregate.replaceRoot({ x: { $concat: [<span class="hljs-string">'$this'</span>, <span class="hljs-string">'$that'</span>] } });</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-sample"><a href="#aggregate_Aggregate-sample">Aggregate.prototype.sample()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">size <span class="method-type">&laquo;Number&raquo;</span> number of random documents to pick</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends new custom $sample operator(s) to this aggregate pipeline.</p>

<h4>Examples:</h4>

<pre><code>aggregate.sample(<span class="hljs-number">3</span>); <span class="hljs-comment">// Add a pipeline that picks 3 random documents</span></code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-skip"><a href="#aggregate_Aggregate-skip">Aggregate.prototype.skip()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">num <span class="method-type">&laquo;Number&raquo;</span> number of records to skip before next stage</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends a new $skip operator to this aggregate pipeline.</p>

<h4>Examples:</h4>

<pre><code>aggregate.skip(<span class="hljs-number">10</span>);</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-sort"><a href="#aggregate_Aggregate-sort">Aggregate.prototype.sort()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">arg <span class="method-type">&laquo;Object|String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> this</li></ul><div><p>Appends a new $sort operator to this aggregate pipeline.</p>

<p>If an object is passed, values allowed are <code>asc</code>, <code>desc</code>, <code>ascending</code>, <code>descending</code>, <code>1</code>, and <code>-1</code>.</p>

<p>If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with <code>-</code> which will be treated as descending.</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// these are equivalent</span>
aggregate.sort({ field: <span class="hljs-string">'asc'</span>, test: <span class="hljs-number">-1</span> });
aggregate.sort(<span class="hljs-string">'field -test'</span>);</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-sortByCount"><a href="#aggregate_Aggregate-sortByCount">Aggregate.prototype.sortByCount()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">arg <span class="method-type">&laquo;Object|String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> this</li></ul><div><p>Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name or a pipeline object.</p>

<p>Note that the <code>$sortByCount</code> operator requires the new root to start with '$'. Mongoose will prepend '$' if the specified field name doesn't start with '$'.</p>

<h4>Examples:</h4>

<pre><code>aggregate.sortByCount(<span class="hljs-string">'users'</span>);
aggregate.sortByCount({ $mergeObjects: [ <span class="hljs-string">"$employee"</span>, <span class="hljs-string">"$business"</span> ] })</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-then"><a href="#aggregate_Aggregate-then">Aggregate.prototype.then()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[resolve] <span class="method-type">&laquo;Function&raquo;</span> successCallback</li><li class="param">[reject] <span class="method-type">&laquo;Function&raquo;</span> errorCallback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Provides promise for aggregate.</p>

<h4>Example:</h4>

<pre><code>Model.aggregate(..).then(successCallback, errorCallback);</code></pre></div><hr class="separate-api-elements"><h3 id="aggregate_Aggregate-unwind"><a href="#aggregate_Aggregate-unwind">Aggregate.prototype.unwind()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fields <span class="method-type">&laquo;String&raquo;</span> the field(s) to unwind</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Appends new custom $unwind operator(s) to this aggregate pipeline.</p>

<p>Note that the <code>$unwind</code> operator requires the path name to start with '$'. Mongoose will prepend '$' if the specified field doesn't start '$'.</p>

<h4>Examples:</h4>

<pre><code>aggregate.unwind(<span class="hljs-string">"tags"</span>);
aggregate.unwind(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>);</code></pre></div><hr class="separate-api"><h2 id="Cursor/aggregationcursor"><a href="#Cursor/aggregationcursor">Cursor/aggregationcursor</a></h2><ul><li><a href="#aggregationcursor_AggregationCursor">AggregationCursor()</a></li><li><a href="#aggregationcursor_AggregationCursor-addCursorFlag">AggregationCursor.prototype.addCursorFlag()</a></li><li><a href="#aggregationcursor_AggregationCursor-close">AggregationCursor.prototype.close()</a></li><li><a href="#aggregationcursor_AggregationCursor-eachAsync">AggregationCursor.prototype.eachAsync()</a></li><li><a href="#aggregationcursor_AggregationCursor-map">AggregationCursor.prototype.map()</a></li><li><a href="#aggregationcursor_AggregationCursor-next">AggregationCursor.prototype.next()</a></li></ul><hr class="separate-api-elements"><h3 id="aggregationcursor_AggregationCursor"><a href="#aggregationcursor_AggregationCursor">AggregationCursor()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">agg <span class="method-type">&laquo;Aggregate&raquo;</span> </li><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> </li></ul><div><p>An AggregationCursor is a concurrency primitive for processing aggregation results one document at a time. It is analogous to QueryCursor.</p>

<p>An AggregationCursor fulfills the Node.js streams3 API, in addition to several other mechanisms for loading documents from MongoDB one at a time.</p>

<p>Creating an AggregationCursor executes the model's pre aggregate hooks, but <strong>not</strong> the model's post aggregate hooks.</p>

<p>Unless you're an advanced user, do <strong>not</strong> instantiate this class directly. Use <a href="/docs/api.html#aggregate_Aggregate-cursor"><code>Aggregate#cursor()</code></a> instead.</p></div><hr class="separate-api-elements"><h3 id="aggregationcursor_AggregationCursor-addCursorFlag"><a href="#aggregationcursor_AggregationCursor-addCursorFlag">AggregationCursor.prototype.addCursorFlag()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">flag <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">value <span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;AggregationCursor&raquo;</span> this</li></ul><div><p>Adds a <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag">cursor flag</a>. Useful for setting the <code>noCursorTimeout</code> and <code>tailable</code> flags.</p></div><hr class="separate-api-elements"><h3 id="aggregationcursor_AggregationCursor-close"><a href="#aggregationcursor_AggregationCursor-close">AggregationCursor.prototype.close()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Marks this cursor as closed. Will stop streaming and subsequent calls to <code>next()</code> will error.</p></div><hr class="separate-api-elements"><h3 id="aggregationcursor_AggregationCursor-eachAsync"><a href="#aggregationcursor_AggregationCursor-eachAsync">AggregationCursor.prototype.eachAsync()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options.parallel] <span class="method-type">&laquo;Number&raquo;</span> the number of promises to execute in parallel. Defaults to 1.</li><li class="param">[callback] <span class="method-type">&laquo;Function&raquo;</span> executed when all docs have been processed</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Execute <code>fn</code> for every document in the cursor. If <code>fn</code> returns a promise, will wait for the promise to resolve before iterating on to the next one. Returns a promise that resolves when done.</p></div><hr class="separate-api-elements"><h3 id="aggregationcursor_AggregationCursor-map"><a href="#aggregationcursor_AggregationCursor-map">AggregationCursor.prototype.map()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;QueryCursor&raquo;</span> </li></ul><div><p>Registers a transform function which subsequently maps documents retrieved via the streams interface or <code>.next()</code></p>

<h4>Example</h4>

<pre><code><span class="hljs-comment">// Map documents returned by `data` events</span>
Thing.
  find({ name: <span class="hljs-regexp">/^hello/</span> }).
  cursor().
  map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
   doc.foo = <span class="hljs-string">"bar"</span>;
   <span class="hljs-keyword">return</span> doc;
  })
  on(<span class="hljs-string">'data'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) </span>{ <span class="hljs-built_in">console</span>.log(doc.foo); });

<span class="hljs-comment">// Or map documents returned by `.next()`</span>
<span class="hljs-keyword">var</span> cursor = Thing.find({ name: <span class="hljs-regexp">/^hello/</span> }).
  cursor().
  map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc</span>) </span>{
    doc.foo = <span class="hljs-string">"bar"</span>;
    <span class="hljs-keyword">return</span> doc;
  });
cursor.next(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, doc</span>) </span>{
  <span class="hljs-built_in">console</span>.log(doc.foo);
});</code></pre></div><hr class="separate-api-elements"><h3 id="aggregationcursor_AggregationCursor-next"><a href="#aggregationcursor_AggregationCursor-next">AggregationCursor.prototype.next()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">callback <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Get the next document from this cursor. Will return <code>null</code> when there are no documents left.</p></div><hr class="separate-api"><h2 id="Schematype"><a href="#Schematype">Schematype</a></h2><ul><li><a href="#schematype_SchemaType">SchemaType()</a></li><li><a href="#schematype_SchemaType-default">SchemaType.prototype.default()</a></li><li><a href="#schematype_SchemaType-get">SchemaType.prototype.get()</a></li><li><a href="#schematype_SchemaType-index">SchemaType.prototype.index()</a></li><li><a href="#schematype_SchemaType-required">SchemaType.prototype.required()</a></li><li><a href="#schematype_SchemaType-select">SchemaType.prototype.select()</a></li><li><a href="#schematype_SchemaType-set">SchemaType.prototype.set()</a></li><li><a href="#schematype_SchemaType-sparse">SchemaType.prototype.sparse()</a></li><li><a href="#schematype_SchemaType-text">SchemaType.prototype.text()</a></li><li><a href="#schematype_SchemaType-unique">SchemaType.prototype.unique()</a></li><li><a href="#schematype_SchemaType-validate">SchemaType.prototype.validate()</a></li></ul><hr class="separate-api-elements"><h3 id="schematype_SchemaType"><a href="#schematype_SchemaType">SchemaType()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path <span class="method-type">&laquo;String&raquo;</span> </li><li class="param">[options] <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[instance] <span class="method-type">&laquo;String&raquo;</span> </li></ul><div><p>SchemaType constructor. Do <strong>not</strong> instantiate <code>SchemaType</code> directly. Mongoose converts your schema paths into SchemaTypes automatically.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> });
schema.path(<span class="hljs-string">'name'</span>) <span class="hljs-keyword">instanceof</span> SchemaType; <span class="hljs-comment">// true</span></code></pre></div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-default"><a href="#schematype_SchemaType-default">SchemaType.prototype.default()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;Function|any&raquo;</span> the default value</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;defaultValue&raquo;</span> </li></ul><div><p>Sets a default value for this SchemaType.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ n: { type: <span class="hljs-built_in">Number</span>, <span class="hljs-keyword">default</span>: <span class="hljs-number">10</span> })
<span class="hljs-keyword">var</span> M = db.model(<span class="hljs-string">'M'</span>, schema)
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M;
<span class="hljs-built_in">console</span>.log(m.n) <span class="hljs-comment">// 10</span></code></pre>

<p>Defaults can be either <code>functions</code> which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// values are cast:</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ aNumber: { type: <span class="hljs-built_in">Number</span>, <span class="hljs-keyword">default</span>: <span class="hljs-number">4.815162342</span> }})
<span class="hljs-keyword">var</span> M = db.model(<span class="hljs-string">'M'</span>, schema)
<span class="hljs-keyword">var</span> m = <span class="hljs-keyword">new</span> M;
<span class="hljs-built_in">console</span>.log(m.aNumber) <span class="hljs-comment">// 4.815162342</span>

<span class="hljs-comment">// default unique objects for Mixed types:</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ mixed: Schema.Types.Mixed });
schema.path(<span class="hljs-string">'mixed'</span>).default(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {};
});

<span class="hljs-comment">// if we don't use a function to return object literals for Mixed defaults,</span>
<span class="hljs-comment">// each document will receive a reference to the same object literal creating</span>
<span class="hljs-comment">// a "shared" object instance:</span>
<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ mixed: Schema.Types.Mixed });
schema.path(<span class="hljs-string">'mixed'</span>).default({});
<span class="hljs-keyword">var</span> M = db.model(<span class="hljs-string">'M'</span>, schema);
<span class="hljs-keyword">var</span> m1 = <span class="hljs-keyword">new</span> M;
m1.mixed.added = <span class="hljs-number">1</span>;
<span class="hljs-built_in">console</span>.log(m1.mixed); <span class="hljs-comment">// { added: 1 }</span>
<span class="hljs-keyword">var</span> m2 = <span class="hljs-keyword">new</span> M;
<span class="hljs-built_in">console</span>.log(m2.mixed); <span class="hljs-comment">// { added: 1 }</span></code></pre></div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-get"><a href="#schematype_SchemaType-get">SchemaType.prototype.get()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</li></ul><div><p>Adds a getter to this schematype.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dob</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">if</span> (!val) <span class="hljs-keyword">return</span> val;
  <span class="hljs-keyword">return</span> (val.getMonth() + <span class="hljs-number">1</span>) + <span class="hljs-string">"/"</span> + val.getDate() + <span class="hljs-string">"/"</span> + val.getFullYear();
}

<span class="hljs-comment">// defining within the schema</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ born: { type: <span class="hljs-built_in">Date</span>, get: dob })

<span class="hljs-comment">// or by retreiving its SchemaType</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ born: <span class="hljs-built_in">Date</span> })
s.path(<span class="hljs-string">'born'</span>).get(dob)</code></pre>

<p>Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.</p>

<p>Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:</p>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">obfuscate</span> (<span class="hljs-params">cc</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-string">'****-****-****-'</span> + cc.slice(cc.length<span class="hljs-number">-4</span>, cc.length);
}

<span class="hljs-keyword">var</span> AccountSchema = <span class="hljs-keyword">new</span> Schema({
  creditCardNumber: { type: <span class="hljs-built_in">String</span>, get: obfuscate }
});

<span class="hljs-keyword">var</span> Account = db.model(<span class="hljs-string">'Account'</span>, AccountSchema);

Account.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, found</span>) </span>{
  <span class="hljs-built_in">console</span>.log(found.creditCardNumber); <span class="hljs-comment">// '****-****-****-1234'</span>
});</code></pre>

<p>Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.</p>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inspector</span> (<span class="hljs-params">val, schematype</span>) </span>{
  <span class="hljs-keyword">if</span> (schematype.options.required) {
    <span class="hljs-keyword">return</span> schematype.path + <span class="hljs-string">' is required'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> schematype.path + <span class="hljs-string">' is not'</span>;
  }
}

<span class="hljs-keyword">var</span> VirusSchema = <span class="hljs-keyword">new</span> Schema({
  name: { type: <span class="hljs-built_in">String</span>, required: <span class="hljs-literal">true</span>, get: inspector },
  taxonomy: { type: <span class="hljs-built_in">String</span>, get: inspector }
})

<span class="hljs-keyword">var</span> Virus = db.model(<span class="hljs-string">'Virus'</span>, VirusSchema);

Virus.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, virus</span>) </span>{
  <span class="hljs-built_in">console</span>.log(virus.name);     <span class="hljs-comment">// name is required</span>
  <span class="hljs-built_in">console</span>.log(virus.taxonomy); <span class="hljs-comment">// taxonomy is not</span>
})</code></pre></div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-index"><a href="#schematype_SchemaType-index">SchemaType.prototype.index()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options <span class="method-type">&laquo;Object|Boolean|String&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</li></ul><div><p>Declares the index options for this schematype.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, index: <span class="hljs-literal">true</span> })
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ loc: { type: [<span class="hljs-built_in">Number</span>], index: <span class="hljs-string">'hashed'</span> })
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ loc: { type: [<span class="hljs-built_in">Number</span>], index: <span class="hljs-string">'2d'</span>, sparse: <span class="hljs-literal">true</span> })
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ loc: { type: [<span class="hljs-built_in">Number</span>], index: { type: <span class="hljs-string">'2dsphere'</span>, sparse: <span class="hljs-literal">true</span> }})
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ date: { type: <span class="hljs-built_in">Date</span>, index: { unique: <span class="hljs-literal">true</span>, expires: <span class="hljs-string">'1d'</span> }})
Schema.path(<span class="hljs-string">'my.path'</span>).index(<span class="hljs-literal">true</span>);
Schema.path(<span class="hljs-string">'my.date'</span>).index({ expires: <span class="hljs-number">60</span> });
Schema.path(<span class="hljs-string">'my.path'</span>).index({ unique: <span class="hljs-literal">true</span>, sparse: <span class="hljs-literal">true</span> });</code></pre>

<h4>NOTE:</h4>

<p><em>Indexes are created in the background by default. Specify <code>background: false</code> to override.</em></p>

<p><a href="http://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeysIndexes">Direction doesn't matter for single key indexes</a></p></div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-required"><a href="#schematype_SchemaType-required">SchemaType.prototype.required()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">required <span class="method-type">&laquo;Boolean|Function|Object&raquo;</span> enable/disable the validator, or function that returns required boolean, or options object</li><li class="param">[options.isRequired] <span class="method-type">&laquo;Boolean|Function&raquo;</span> enable/disable the validator, or function that returns required boolean</li><li class="param">[options.ErrorConstructor] <span class="method-type">&laquo;Function&raquo;</span> custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.</li><li class="param">[message] <span class="method-type">&laquo;String&raquo;</span> optional custom error message</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</li></ul><div><p>Adds a required validator to this SchemaType. The validator gets added to the front of this SchemaType's validators array using <code>unshift()</code>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ born: { type: <span class="hljs-built_in">Date</span>, required: <span class="hljs-literal">true</span> })

<span class="hljs-comment">// or with custom error message</span>

<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ born: { type: <span class="hljs-built_in">Date</span>, required: <span class="hljs-string">'{PATH} is required!'</span> })

<span class="hljs-comment">// or with a function</span>

<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({
  userId: ObjectId,
  username: {
    type: <span class="hljs-built_in">String</span>,
    required: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userId != <span class="hljs-literal">null</span>; }
  }
})

<span class="hljs-comment">// or with a function and a custom message</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({
  userId: ObjectId,
  username: {
    type: <span class="hljs-built_in">String</span>,
    required: [
      <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userId != <span class="hljs-literal">null</span>; },
      <span class="hljs-string">'username is required if id is specified'</span>
    ]
  }
})

<span class="hljs-comment">// or through the path API</span>

Schema.path(<span class="hljs-string">'name'</span>).required(<span class="hljs-literal">true</span>);

<span class="hljs-comment">// with custom error messaging</span>

Schema.path(<span class="hljs-string">'name'</span>).required(<span class="hljs-literal">true</span>, <span class="hljs-string">'grrr :( '</span>);

<span class="hljs-comment">// or make a path conditionally required based on a function</span>
<span class="hljs-keyword">var</span> isOver18 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age &gt;= <span class="hljs-number">18</span>; };
Schema.path(<span class="hljs-string">'voterRegistrationId'</span>).required(isOver18);</code></pre>

<p>The required validator uses the SchemaType's <code>checkRequired</code> function to determine whether a given value satisfies the required validator. By default, a value satisfies the required validator if <code>val != null</code> (that is, if the value is not null nor undefined). However, most built-in mongoose schema types override the default <code>checkRequired</code> function:</p></div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-select"><a href="#schematype_SchemaType-select">SchemaType.prototype.select()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">val <span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</li></ul><div><p>Sets default <code>select()</code> behavior for this path.</p>

<p>Set to <code>true</code> if this path should always be included in the results, <code>false</code> if it should be excluded by default. This setting can be overridden at the query level.</p>

<h4>Example:</h4>

<pre><code>T = db.model(<span class="hljs-string">'T'</span>, <span class="hljs-keyword">new</span> Schema({ x: { type: <span class="hljs-built_in">String</span>, select: <span class="hljs-literal">true</span> }}));
T.find(..); <span class="hljs-comment">// field x will always be selected ..</span>
<span class="hljs-comment">// .. unless overridden;</span>
T.find().select(<span class="hljs-string">'-x'</span>).exec(callback);</code></pre></div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-set"><a href="#schematype_SchemaType-set">SchemaType.prototype.set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</li></ul><div><p>Adds a setter to this schematype.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">capitalize</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val !== <span class="hljs-string">'string'</span>) val = <span class="hljs-string">''</span>;
  <span class="hljs-keyword">return</span> val.charAt(<span class="hljs-number">0</span>).toUpperCase() + val.substring(<span class="hljs-number">1</span>);
}

<span class="hljs-comment">// defining within the schema</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, set: capitalize }});

<span class="hljs-comment">// or with the SchemaType</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> })
s.path(<span class="hljs-string">'name'</span>).set(capitalize);</code></pre>

<p>Setters allow you to transform the data before it gets to the raw mongodb document or query.</p>

<p>Suppose you are implementing user registration for a website. Users provide an email and password, which gets saved to mongodb. The email is a string that you will want to normalize to lower case, in order to avoid one email having more than one account -- e.g., otherwise, <a href='mailto:avenue@q.com'>avenue@q.com</a> can be registered for 2 accounts via <a href='mailto:avenue@q.com'>avenue@q.com</a> and <a href='mailto:AvEnUe@Q.CoM'>AvEnUe@Q.CoM</a>.</p>

<p>You can set up email lower case normalization easily via a Mongoose setter.</p>

<pre><code>function toLower(v) {
  return v.toLowerCase();
}

var UserSchema = new Schema({
  email: { type: String, set: toLower }
});

var User = db.model('User', UserSchema);

var user = new User({email: '<a href='mailto:AVENUE@Q.COM'>AVENUE@Q.COM</a>'});
console.log(user.email); // '<a href='mailto:avenue@q.com'>avenue@q.com</a>'

// or
var user = new User();
user.email = '<a href='mailto:Avenue@Q.com'>Avenue@Q.com</a>';
console.log(user.email); // '<a href='mailto:avenue@q.com'>avenue@q.com</a>'
User.updateOne({ _id: _id }, { $set: { email: '<a href='mailto:AVENUE@Q.COM'>AVENUE@Q.COM</a>' } }); // update to '<a href='mailto:avenue@q.com'>avenue@q.com</a>'
</code></pre>

<p>As you can see above, setters allow you to transform the data before it stored in MongoDB, or before executing a query.</p>

<p><em>NOTE: we could have also just used the built-in <code>lowercase: true</code> SchemaType option instead of defining our own function.</em></p>

<pre><code><span class="hljs-keyword">new</span> Schema({ email: { type: <span class="hljs-built_in">String</span>, lowercase: <span class="hljs-literal">true</span> }})</code></pre>

<p>Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.</p>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inspector</span> (<span class="hljs-params">val, schematype</span>) </span>{
  <span class="hljs-keyword">if</span> (schematype.options.required) {
    <span class="hljs-keyword">return</span> schematype.path + <span class="hljs-string">' is required'</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> val;
  }
}

<span class="hljs-keyword">var</span> VirusSchema = <span class="hljs-keyword">new</span> Schema({
  name: { type: <span class="hljs-built_in">String</span>, required: <span class="hljs-literal">true</span>, set: inspector },
  taxonomy: { type: <span class="hljs-built_in">String</span>, set: inspector }
})

<span class="hljs-keyword">var</span> Virus = db.model(<span class="hljs-string">'Virus'</span>, VirusSchema);
<span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Virus({ name: <span class="hljs-string">'Parvoviridae'</span>, taxonomy: <span class="hljs-string">'Parvovirinae'</span> });

<span class="hljs-built_in">console</span>.log(v.name);     <span class="hljs-comment">// name is required</span>
<span class="hljs-built_in">console</span>.log(v.taxonomy); <span class="hljs-comment">// Parvovirinae</span></code></pre>

<p>You can also use setters to modify other properties on the document. If you're setting a property <code>name</code> on a document, the setter will run with <code>this</code> as the document. Be careful, in mongoose 5 setters will also run when querying by <code>name</code> with <code>this</code> as the query.</p>

<div class="highlight"><pre lang="javascript">const nameSchema = new Schema({ name: String, keywords: [String] });
nameSchema.path('name').set(function(v) {
  // Need to check if `this` is a document, because in mongoose 5
  // setters will also run on queries, in which case `this` will be a
  // mongoose query object.
  if (this instanceof Document && v != null) {
    this.keywords = v.split(' ');
  }
  return v;
});
</pre></div></div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-sparse"><a href="#schematype_SchemaType-sparse">SchemaType.prototype.sparse()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">bool <span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</li></ul><div><p>Declares a sparse index.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, sparse: <span class="hljs-literal">true</span> })
Schema.path(<span class="hljs-string">'name'</span>).index({ sparse: <span class="hljs-literal">true</span> });</code></pre></div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-text"><a href="#schematype_SchemaType-text">SchemaType.prototype.text()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">bool <span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</li></ul><div><p>Declares a full text index.</p>

<h3>Example:</h3>

<pre><code><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({name : {type: <span class="hljs-built_in">String</span>, text : <span class="hljs-literal">true</span> })
 Schema.path(<span class="hljs-string">'name'</span>).index({text : <span class="hljs-literal">true</span>});</code></pre></div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-unique"><a href="#schematype_SchemaType-unique">SchemaType.prototype.unique()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">bool <span class="method-type">&laquo;Boolean&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</li></ul><div><p>Declares an unique index.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, unique: <span class="hljs-literal">true</span> }});
Schema.path(<span class="hljs-string">'name'</span>).index({ unique: <span class="hljs-literal">true</span> });</code></pre>

<p><em>NOTE: violating the constraint returns an <code>E11000</code> error from MongoDB when saving, not a Mongoose validation error.</em></p></div><hr class="separate-api-elements"><h3 id="schematype_SchemaType-validate"><a href="#schematype_SchemaType-validate">SchemaType.prototype.validate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">obj <span class="method-type">&laquo;RegExp|Function|Object&raquo;</span> validator</li><li class="param">[errorMsg] <span class="method-type">&laquo;String&raquo;</span> optional error message</li><li class="param">[type] <span class="method-type">&laquo;String&raquo;</span> optional validator type</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;SchemaType&raquo;</span> this</li></ul><div><p>Adds validator(s) for this document path.</p>

<p>Validators always receive the value to validate as their first argument and must return <code>Boolean</code>. Returning <code>false</code> means validation failed.</p>

<p>The error message argument is optional. If not passed, the <a href="#error_messages_MongooseError-messages">default generic error message template</a> will be used.</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// make sure every value is equal to "something"</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validator</span> (<span class="hljs-params">val</span>) </span>{
  <span class="hljs-keyword">return</span> val == <span class="hljs-string">'something'</span>;
}
<span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, validate: validator }});

<span class="hljs-comment">// with a custom error message</span>

<span class="hljs-keyword">var</span> custom = [validator, <span class="hljs-string">'Uh oh, {PATH} does not equal "something".'</span>]
<span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, validate: custom }});

<span class="hljs-comment">// adding many validators at a time</span>

<span class="hljs-keyword">var</span> many = [
    { validator: validator, msg: <span class="hljs-string">'uh oh'</span> }
  , { validator: anotherValidator, msg: <span class="hljs-string">'failed'</span> }
]
<span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, validate: many }});

<span class="hljs-comment">// or utilizing SchemaType methods directly:</span>

<span class="hljs-keyword">var</span> schema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-string">'string'</span> });
schema.path(<span class="hljs-string">'name'</span>).validate(validator, <span class="hljs-string">'validation of `{PATH}` failed with value `{VALUE}`'</span>);</code></pre>

<h4>Error message templates:</h4>

<p>From the examples above, you may have noticed that error messages support basic templating. There are a few other template keywords besides <code>{PATH}</code> and <code>{VALUE}</code> too. To find out more, details are available <a href="#error_messages_MongooseError.messages">here</a></p>

<h4>Asynchronous validation:</h4>

<p>Passing a validator function that receives two arguments tells mongoose that the validator is an asynchronous validator. The first argument passed to the validator function is the value being validated. The second argument is a callback function that must called when you finish validating the value and passed either <code>true</code> or <code>false</code> to communicate either success or failure respectively.</p>

<pre><code>schema.path(<span class="hljs-string">'name'</span>).validate({
  isAsync: <span class="hljs-literal">true</span>,
  validator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value, respond</span>) </span>{
    doStuff(value, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      ...
      respond(<span class="hljs-literal">false</span>); <span class="hljs-comment">// validation failed</span>
    });
  },
  message: <span class="hljs-string">'Custom error message!'</span> <span class="hljs-comment">// Optional</span>
});

<span class="hljs-comment">// Can also return a promise</span>
schema.path(<span class="hljs-string">'name'</span>).validate({
  validator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
      resolve(<span class="hljs-literal">false</span>); <span class="hljs-comment">// validation failed</span>
    });
  }
});</code></pre>

<p>You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.</p>

<p>Validation occurs <code>pre('save')</code> or whenever you manually execute <a href="#document_Document-validate">document#validate</a>.</p>

<p>If validation fails during <code>pre('save')</code> and no callback was passed to receive the error, an <code>error</code> event will be emitted on your Models associated db <a href="#connection_Connection">connection</a>, passing the validation error object along.</p>

<pre><code><span class="hljs-keyword">var</span> conn = mongoose.createConnection(..);
conn.on(<span class="hljs-string">'error'</span>, handleError);

<span class="hljs-keyword">var</span> Product = conn.model(<span class="hljs-string">'Product'</span>, yourSchema);
<span class="hljs-keyword">var</span> dvd = <span class="hljs-keyword">new</span> Product(..);
dvd.save(); <span class="hljs-comment">// emits error on the `conn` above</span></code></pre>

<p>If you desire handling these errors at the Model level, attach an <code>error</code> listener to your Model and the event will instead be emitted there.</p>

<pre><code><span class="hljs-comment">// registering an error listener on the Model lets us handle errors more locally</span>
Product.on(<span class="hljs-string">'error'</span>, handleError);</code></pre></div><hr class="separate-api"><h2 id="Virtualtype"><a href="#Virtualtype">Virtualtype</a></h2><ul><li><a href="#virtualtype_VirtualType">VirtualType()</a></li><li><a href="#virtualtype_VirtualType-_applyDefaultGetters">VirtualType.prototype._applyDefaultGetters()</a></li><li><a href="#virtualtype_VirtualType-applyGetters">VirtualType.prototype.applyGetters()</a></li><li><a href="#virtualtype_VirtualType-applySetters">VirtualType.prototype.applySetters()</a></li><li><a href="#virtualtype_VirtualType-get">VirtualType.prototype.get()</a></li><li><a href="#virtualtype_VirtualType-set">VirtualType.prototype.set()</a></li></ul><hr class="separate-api-elements"><h3 id="virtualtype_VirtualType"><a href="#virtualtype_VirtualType">VirtualType()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">options <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options.ref] <span class="method-type">&laquo;string|function&raquo;</span> if <code>ref</code> is not nullish, this becomes a <a href="/docs/populate.html#populate-virtuals">populated virtual</a></li><li class="param">[options.localField] <span class="method-type">&laquo;string|function&raquo;</span> the local field to populate on if this is a populated virtual.</li><li class="param">[options.foreignField] <span class="method-type">&laquo;string|function&raquo;</span> the foreign field to populate on if this is a populated virtual.</li><li class="param">[options.justOne=false] <span class="method-type">&laquo;boolean&raquo;</span> by default, a populated virtual is an array. If you set <code>justOne</code>, the populated virtual will be a single doc or <code>null</code>.</li></ul><div><p>VirtualType constructor</p>

<p>This is what mongoose uses to define virtual attributes via <code>Schema.prototype.virtual</code>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> fullname = schema.virtual(<span class="hljs-string">'fullname'</span>);
fullname <span class="hljs-keyword">instanceof</span> mongoose.VirtualType <span class="hljs-comment">// true</span></code></pre></div><hr class="separate-api-elements"><h3 id="virtualtype_VirtualType-_applyDefaultGetters"><a href="#virtualtype_VirtualType-_applyDefaultGetters">VirtualType.prototype._applyDefaultGetters()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;VirtualType&raquo;</span> this</li></ul><div><p>If no getters/getters, add a default</p></div><hr class="separate-api-elements"><h3 id="virtualtype_VirtualType-applyGetters"><a href="#virtualtype_VirtualType-applyGetters">VirtualType.prototype.applyGetters()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">value <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">scope <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;any&raquo;</span> the value after applying all getters</li></ul><div><p>Applies getters to <code>value</code> using optional <code>scope</code>.</p></div><hr class="separate-api-elements"><h3 id="virtualtype_VirtualType-applySetters"><a href="#virtualtype_VirtualType-applySetters">VirtualType.prototype.applySetters()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">value <span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">scope <span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;any&raquo;</span> the value after applying all setters</li></ul><div><p>Applies setters to <code>value</code> using optional <code>scope</code>.</p></div><hr class="separate-api-elements"><h3 id="virtualtype_VirtualType-get"><a href="#virtualtype_VirtualType-get">VirtualType.prototype.get()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;VirtualType&raquo;</span> this</li></ul><div><p>Defines a getter.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> virtual = schema.virtual(<span class="hljs-string">'fullname'</span>);
virtual.get(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name.first + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.name.last;
});</code></pre></div><hr class="separate-api-elements"><h3 id="virtualtype_VirtualType-set"><a href="#virtualtype_VirtualType-set">VirtualType.prototype.set()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">fn <span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;VirtualType&raquo;</span> this</li></ul><div><p>Defines a setter.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> virtual = schema.virtual(<span class="hljs-string">'fullname'</span>);
virtual.set(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>{
  <span class="hljs-keyword">var</span> parts = v.split(<span class="hljs-string">' '</span>);
  <span class="hljs-keyword">this</span>.name.first = parts[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">this</span>.name.last = parts[<span class="hljs-number">1</span>];
});</code></pre></div><hr class="separate-api"><h2 id="Error"><a href="#Error">Error</a></h2><ul><li><a href="#mongooseerror_MongooseError.CastError">MongooseError.CastError</a></li><li><a href="#mongooseerror_MongooseError.DivergentArrayError">MongooseError.DivergentArrayError</a></li><li><a href="#mongooseerror_MongooseError.DocumentNotFoundError">MongooseError.DocumentNotFoundError</a></li><li><a href="#mongooseerror_MongooseError.MissingSchemaError">MongooseError.MissingSchemaError</a></li><li><a href="#mongooseerror_MongooseError.OverwriteModelError">MongooseError.OverwriteModelError</a></li><li><a href="#mongooseerror_MongooseError.ParallelSaveError">MongooseError.ParallelSaveError</a></li><li><a href="#mongooseerror_MongooseError.ValidationError">MongooseError.ValidationError</a></li><li><a href="#mongooseerror_MongooseError.ValidatorError">MongooseError.ValidatorError</a></li><li><a href="#mongooseerror_MongooseError.VersionError">MongooseError.VersionError</a></li><li><a href="#mongooseerror_MongooseError.messages">MongooseError.messages</a></li></ul><hr class="separate-api-elements"><h3 id="mongooseerror_MongooseError.CastError"><a href="#mongooseerror_MongooseError.CastError">MongooseError.CastError</a></h3><div><p>An instance of this error class will be returned when mongoose failed to cast a value.</p></div><hr class="separate-api-elements"><h3 id="mongooseerror_MongooseError.DivergentArrayError"><a href="#mongooseerror_MongooseError.DivergentArrayError">MongooseError.DivergentArrayError</a></h3><div><p>An instance of this error will be returned if you used an array projection and then modified the array in an unsafe way.</p></div><hr class="separate-api-elements"><h3 id="mongooseerror_MongooseError.DocumentNotFoundError"><a href="#mongooseerror_MongooseError.DocumentNotFoundError">MongooseError.DocumentNotFoundError</a></h3><div><p>An instance of this error class will be returned when <code>save()</code> fails because the underlying document was not found. The constructor takes one parameter, the conditions that mongoose passed to <code>update()</code> when trying to update the document.</p></div><hr class="separate-api-elements"><h3 id="mongooseerror_MongooseError.MissingSchemaError"><a href="#mongooseerror_MongooseError.MissingSchemaError">MongooseError.MissingSchemaError</a></h3><div><p>Thrown when you try to access a model that has not been registered yet</p></div><hr class="separate-api-elements"><h3 id="mongooseerror_MongooseError.OverwriteModelError"><a href="#mongooseerror_MongooseError.OverwriteModelError">MongooseError.OverwriteModelError</a></h3><div><p>Thrown when a model with the given name was already registered on the connection. See <a href="/docs/faq.html#overwrite-model-error">the FAQ about <code>OverwriteModelError</code></a>.</p></div><hr class="separate-api-elements"><h3 id="mongooseerror_MongooseError.ParallelSaveError"><a href="#mongooseerror_MongooseError.ParallelSaveError">MongooseError.ParallelSaveError</a></h3><div><p>An instance of this error class will be returned when you call <code>save()</code> multiple times on the same document in parallel. See the <a href="/docs/faq.html">FAQ</a> for more information.</p></div><hr class="separate-api-elements"><h3 id="mongooseerror_MongooseError.ValidationError"><a href="#mongooseerror_MongooseError.ValidationError">MongooseError.ValidationError</a></h3><div><p>An instance of this error class will be returned when <a href="/docs/validation.html">validation</a> failed.</p></div><hr class="separate-api-elements"><h3 id="mongooseerror_MongooseError.ValidatorError"><a href="#mongooseerror_MongooseError.ValidatorError">MongooseError.ValidatorError</a></h3><div><p>A <code>ValidationError</code> has a hash of <code>errors</code> that contain individual <code>ValidatorError</code> instances</p></div><hr class="separate-api-elements"><h3 id="mongooseerror_MongooseError.VersionError"><a href="#mongooseerror_MongooseError.VersionError">MongooseError.VersionError</a></h3><div><p>An instance of this error class will be returned when you call <code>save()</code> after the document in the database was changed in a potentially unsafe way. See the <a href="/docs/guide.html#versionKey"><code>versionKey</code> option</a> for more information.</p></div><hr class="separate-api-elements"><h3 id="mongooseerror_MongooseError.messages"><a href="#mongooseerror_MongooseError.messages">MongooseError.messages</a></h3><div><p>The default built-in validator error messages.</p></div></div></div><script type="text/javascript">!function(name,path,ctx){
  var latest,prev=name!=='Keen'&&window.Keen?window.Keen:false;ctx[name]=ctx[name]||{ready:function(fn){var h=document.getElementsByTagName('head')[0],s=document.createElement('script'),w=window,loaded;s.onload=s.onerror=s.onreadystatechange=function(){if((s.readyState&&!(/^c|loade/.test(s.readyState)))||loaded){return}s.onload=s.onreadystatechange=null;loaded=1;latest=w.Keen;if(prev){w.Keen=prev}else{try{delete w.Keen}catch(e){w.Keen=void 0}}ctx[name]=latest;ctx[name].ready(fn)};s.async=1;s.src=path;h.parentNode.insertBefore(s,h)}}
}('KeenAsync','https://d26b395fwzu5fz.cloudfront.net/keen-tracking-1.1.3.min.js',this);

KeenAsync.ready(function(){
  // Configure a client instance
  var client = new KeenAsync({
    projectId: '59aad9cbc9e77c0001ce1b32',
    writeKey: '4B38B0046086885E425D368BFAEAD8FD0D4F2DC2FA2F936FDE058D79508AEFAD9886BC020B96520823BB9C8241D9D9BCFDC0EF52E6033BD89D06E4B24FC13AE955896BF443406269A84DD009CEB5862DCEC944874DB2107FD648DA91ADC1E6DE'
  });

  client.recordEvent('pageView', {
    host: window.location.host,
    pathname: window.location.pathname,
    hash: window.location.hash
  });
});</script><script type="text/javascript">(function (window, document) {
  var layout   = document.getElementById('layout'),
      menu     = document.getElementById('menu'),
      menuLink = document.getElementById('menuLink'),
      content  = document.getElementById('content');

  function toggleClass(element, className) {
      var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

      for(; i < length; i++) {
        if (classes[i] === className) {
          classes.splice(i, 1);
          break;
        }
      }
      // The className is not found
      if (length === classes.length) {
          classes.push(className);
      }

      element.className = classes.join(' ');
  }

  function toggleAll(e) {
      var active = 'active';

      e.preventDefault();
      toggleClass(layout, active);
      toggleClass(menu, active);
      toggleClass(menuLink, active);
  }

  menuLink.onclick = function (e) {
      toggleAll(e);
  };

  content.onclick = function(e) {
      if (menu.className.indexOf('active') !== -1) {
          toggleAll(e);
      }
  };

}(this, this.document));</script></div></body></html>