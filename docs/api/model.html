<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v5.6.0: </title><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" integrity="sha384-nn4HPE8lTHyVtfCBi5yW9d20FjT8BJwUXyWZT9InLYax14RDjBj46LmSztkmNP9w" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel="stylesheet" href="/docs/css/github.css"><link rel="stylesheet" href="/docs/css/mongoose5.css"><link rel="apple-touch-icon" sizes="57x57" href="images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png"><link rel="manifest" href="images/favicon/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/docs/css/api.css"><link rel="stylesheet" href="/docs/css/inlinecpc.css"><script type="text/javascript" src="/docs/js/native.js"></script><style>.api-nav .nav-item-sub {
  display: block !important;
}

.api-content {
  margin-top: 3em;
}
</style></head><body><div id="layout"><div id="mobile-menu"><a class="menu-link" id="menuLink" href="#menu"><span></span></a><div id="mobile-logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><div class="pure-menu"><div class="pure-menu-heading" id="logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list" id="navbar"><li class="pure-menu-horizontal pure-menu-item pure-menu-has-children pure-menu-allow-hover version"><a class="pure-menu-link" href="#">Version 5.6.0</a><ul class="pure-menu-children"><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/4.x">Version 4.13.18</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/3.8.x">Version 3.8.40</a></li></ul></li><li class="pure-menu-item search"><input id="search-input-nav" type="text" placeholder="Search"><button id="search-button-nav"><img src="/docs/images/search.svg"></button></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/index.html">Quick Start</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/guides.html">Guides</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/guide.html">Schemas</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/schematypes.html">SchemaTypes</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/connections.html">Connections</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/models.html">Models</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/documents.html">Documents</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/subdocs.html">Subdocuments</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/queries.html">Queries</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/validation.html">Validation</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/middleware.html">Middleware</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/populate.html">Populate</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/discriminators.html">Discriminators</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/plugins.html">Plugins</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/api.html">API</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/mongoose.html">Mongoose</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/schema.html">Schema</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/connection.html">Connection</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/document.html">Document</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/model.html">Model</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/query.html">Query</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/aggregate.html">Aggregate</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/schematype.html">SchemaType</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/virtualtype.html">VirtualType</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/compatibility.html">Version Compatibility</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/faq.html">FAQ</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/further_reading.html">Further Reading</a></li></ul><div class="cpc-ad"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?zoneid=1673&serve=C6AILKT&placement=mongoosejscom" id="_carbonads_js"></script></div></div></div><div class="container"><div id="content"><h1>Model</h1><div><div class="native-inline">
  <a href="#native_link#"><span class="sponsor">Sponsor</span> #native_company# â€” #native_desc#</a>
</div>
</div><div class="api-nav"><div class="api-nav-content"><div class="nav-item" id="nav-Mongoose"><div class="nav-item-title"><a href="mongoose.html">Mongoose</a></div></div><div class="nav-item" id="nav-Schema"><div class="nav-item-title"><a href="schema.html">Schema</a></div></div><div class="nav-item" id="nav-Connection"><div class="nav-item-title"><a href="connection.html">Connection</a></div></div><div class="nav-item" id="nav-Document"><div class="nav-item-title"><a href="document.html">Document</a></div></div><div class="nav-item" id="nav-Model"><div class="nav-item-title" style="font-weight: bold"><a href="model.html">Model</a></div><ul class="nav-item-sub"><li><a href="#model_Model">Model()</a></li><li><a href="#model_Model.aggregate">Model.aggregate()</a></li><li><a href="#model_Model.bulkWrite">Model.bulkWrite()</a></li><li><a href="#model_Model.count">Model.count()</a></li><li><a href="#model_Model.countDocuments">Model.countDocuments()</a></li><li><a href="#model_Model.create">Model.create()</a></li><li><a href="#model_Model.createCollection">Model.createCollection()</a></li><li><a href="#model_Model.createIndexes">Model.createIndexes()</a></li><li><a href="#model_Model.deleteMany">Model.deleteMany()</a></li><li><a href="#model_Model.deleteOne">Model.deleteOne()</a></li><li><a href="#model_Model.discriminator">Model.discriminator()</a></li><li><a href="#model_Model.distinct">Model.distinct()</a></li><li><a href="#model_Model.ensureIndexes">Model.ensureIndexes()</a></li><li><a href="#model_Model.estimatedDocumentCount">Model.estimatedDocumentCount()</a></li><li><a href="#model_Model-events">Model.events</a></li><li><a href="#model_Model.exists">Model.exists()</a></li><li><a href="#model_Model.find">Model.find()</a></li><li><a href="#model_Model.findById">Model.findById()</a></li><li><a href="#model_Model.findByIdAndDelete">Model.findByIdAndDelete()</a></li><li><a href="#model_Model.findByIdAndRemove">Model.findByIdAndRemove()</a></li><li><a href="#model_Model.findByIdAndUpdate">Model.findByIdAndUpdate()</a></li><li><a href="#model_Model.findOne">Model.findOne()</a></li><li><a href="#model_Model.findOneAndDelete">Model.findOneAndDelete()</a></li><li><a href="#model_Model.findOneAndRemove">Model.findOneAndRemove()</a></li><li><a href="#model_Model.findOneAndReplace">Model.findOneAndReplace()</a></li><li><a href="#model_Model.findOneAndUpdate">Model.findOneAndUpdate()</a></li><li><a href="#model_Model.geoSearch">Model.geoSearch()</a></li><li><a href="#model_Model.hydrate">Model.hydrate()</a></li><li><a href="#model_Model.init">Model.init()</a></li><li><a href="#model_Model.insertMany">Model.insertMany()</a></li><li><a href="#model_Model.listIndexes">Model.listIndexes()</a></li><li><a href="#model_Model.mapReduce">Model.mapReduce()</a></li><li><a href="#model_Model.populate">Model.populate()</a></li><li><a href="#model_Model-$where">Model.prototype.$where</a></li><li><a href="#model_Model-$where">Model.prototype.$where()</a></li><li><a href="#model_Model-base">Model.prototype.base</a></li><li><a href="#model_Model-baseModelName">Model.prototype.baseModelName</a></li><li><a href="#model_Model-collection">Model.prototype.collection</a></li><li><a href="#model_Model-db">Model.prototype.db</a></li><li><a href="#model_Model-delete">Model.prototype.delete</a></li><li><a href="#model_Model-deleteOne">Model.prototype.deleteOne()</a></li><li><a href="#model_Model-discriminators">Model.prototype.discriminators</a></li><li><a href="#model_Model-increment">Model.prototype.increment()</a></li><li><a href="#model_Model-model">Model.prototype.model()</a></li><li><a href="#model_Model-modelName">Model.prototype.modelName</a></li><li><a href="#model_Model-remove">Model.prototype.remove()</a></li><li><a href="#model_Model-save">Model.prototype.save()</a></li><li><a href="#model_Model-schema">Model.prototype.schema</a></li><li><a href="#model_Model.remove">Model.remove()</a></li><li><a href="#model_Model.replaceOne">Model.replaceOne()</a></li><li><a href="#model_Model.startSession">Model.startSession()</a></li><li><a href="#model_Model.syncIndexes">Model.syncIndexes()</a></li><li><a href="#model_Model.translateAliases">Model.translateAliases()</a></li><li><a href="#model_Model.update">Model.update()</a></li><li><a href="#model_Model.updateMany">Model.updateMany()</a></li><li><a href="#model_Model.updateOne">Model.updateOne()</a></li><li><a href="#model_Model.watch">Model.watch()</a></li><li><a href="#model_Model.where">Model.where()</a></li><li><a href="#model_Model.inspect">function Object() { [native code] }.prototype.inspect()</a></li></ul></div><div class="nav-item" id="nav-Query"><div class="nav-item-title"><a href="query.html">Query</a></div></div><div class="nav-item" id="nav-QueryCursor"><div class="nav-item-title"><a href="querycursor.html">QueryCursor</a></div></div><div class="nav-item" id="nav-Aggregate"><div class="nav-item-title"><a href="aggregate.html">Aggregate</a></div></div><div class="nav-item" id="nav-AggregationCursor"><div class="nav-item-title"><a href="aggregationcursor.html">AggregationCursor</a></div></div><div class="nav-item" id="nav-Schematype"><div class="nav-item-title"><a href="schematype.html">Schematype</a></div></div><div class="nav-item" id="nav-Virtualtype"><div class="nav-item-title"><a href="virtualtype.html">Virtualtype</a></div></div><div class="nav-item" id="nav-Error"><div class="nav-item-title"><a href="error.html">Error</a></div></div><div class="nav-item" id="nav-Array"><div class="nav-item-title"><a href="array.html">Array</a></div></div></div></div><div class="api-content"><ul><li><a href="#model_Model">Model()</a></li><li><a href="#model_Model.aggregate">Model.aggregate()</a></li><li><a href="#model_Model.bulkWrite">Model.bulkWrite()</a></li><li><a href="#model_Model.count">Model.count()</a></li><li><a href="#model_Model.countDocuments">Model.countDocuments()</a></li><li><a href="#model_Model.create">Model.create()</a></li><li><a href="#model_Model.createCollection">Model.createCollection()</a></li><li><a href="#model_Model.createIndexes">Model.createIndexes()</a></li><li><a href="#model_Model.deleteMany">Model.deleteMany()</a></li><li><a href="#model_Model.deleteOne">Model.deleteOne()</a></li><li><a href="#model_Model.discriminator">Model.discriminator()</a></li><li><a href="#model_Model.distinct">Model.distinct()</a></li><li><a href="#model_Model.ensureIndexes">Model.ensureIndexes()</a></li><li><a href="#model_Model.estimatedDocumentCount">Model.estimatedDocumentCount()</a></li><li><a href="#model_Model-events">Model.events</a></li><li><a href="#model_Model.exists">Model.exists()</a></li><li><a href="#model_Model.find">Model.find()</a></li><li><a href="#model_Model.findById">Model.findById()</a></li><li><a href="#model_Model.findByIdAndDelete">Model.findByIdAndDelete()</a></li><li><a href="#model_Model.findByIdAndRemove">Model.findByIdAndRemove()</a></li><li><a href="#model_Model.findByIdAndUpdate">Model.findByIdAndUpdate()</a></li><li><a href="#model_Model.findOne">Model.findOne()</a></li><li><a href="#model_Model.findOneAndDelete">Model.findOneAndDelete()</a></li><li><a href="#model_Model.findOneAndRemove">Model.findOneAndRemove()</a></li><li><a href="#model_Model.findOneAndReplace">Model.findOneAndReplace()</a></li><li><a href="#model_Model.findOneAndUpdate">Model.findOneAndUpdate()</a></li><li><a href="#model_Model.geoSearch">Model.geoSearch()</a></li><li><a href="#model_Model.hydrate">Model.hydrate()</a></li><li><a href="#model_Model.init">Model.init()</a></li><li><a href="#model_Model.insertMany">Model.insertMany()</a></li><li><a href="#model_Model.listIndexes">Model.listIndexes()</a></li><li><a href="#model_Model.mapReduce">Model.mapReduce()</a></li><li><a href="#model_Model.populate">Model.populate()</a></li><li><a href="#model_Model-$where">Model.prototype.$where</a></li><li><a href="#model_Model-$where">Model.prototype.$where()</a></li><li><a href="#model_Model-base">Model.prototype.base</a></li><li><a href="#model_Model-baseModelName">Model.prototype.baseModelName</a></li><li><a href="#model_Model-collection">Model.prototype.collection</a></li><li><a href="#model_Model-db">Model.prototype.db</a></li><li><a href="#model_Model-delete">Model.prototype.delete</a></li><li><a href="#model_Model-deleteOne">Model.prototype.deleteOne()</a></li><li><a href="#model_Model-discriminators">Model.prototype.discriminators</a></li><li><a href="#model_Model-increment">Model.prototype.increment()</a></li><li><a href="#model_Model-model">Model.prototype.model()</a></li><li><a href="#model_Model-modelName">Model.prototype.modelName</a></li><li><a href="#model_Model-remove">Model.prototype.remove()</a></li><li><a href="#model_Model-save">Model.prototype.save()</a></li><li><a href="#model_Model-schema">Model.prototype.schema</a></li><li><a href="#model_Model.remove">Model.remove()</a></li><li><a href="#model_Model.replaceOne">Model.replaceOne()</a></li><li><a href="#model_Model.startSession">Model.startSession()</a></li><li><a href="#model_Model.syncIndexes">Model.syncIndexes()</a></li><li><a href="#model_Model.translateAliases">Model.translateAliases()</a></li><li><a href="#model_Model.update">Model.update()</a></li><li><a href="#model_Model.updateMany">Model.updateMany()</a></li><li><a href="#model_Model.updateOne">Model.updateOne()</a></li><li><a href="#model_Model.watch">Model.watch()</a></li><li><a href="#model_Model.where">Model.where()</a></li><li><a href="#model_Model.inspect">function Object() { [native code] }.prototype.inspect()</a></li></ul><hr class="separate-api-elements"><h3 id="model_Model"><a href="#model_Model">Model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc
<span class="method-type">&laquo;Object&raquo;</span> values for initial set</li><li class="param">optional
<span class="method-type">&laquo;[fields]&raquo;</span> object containing the fields that were selected in the query which returned this document. You do <strong>not</strong> need to set this parameter to ensure Mongoose handles your <a href="./api.html#query_Query-select">query projection</a>.</li></ul><div><p>A Model is a class that's your primary tool for interacting with MongoDB. An instance of a Model is called a <a href="./api.html#Document">Document</a>.</p>

<p>In Mongoose, the term "Model" refers to subclasses of the <code>mongoose.Model</code> class. You should not use the <code>mongoose.Model</code> class directly. The <a href="./api.html#mongoose_Mongoose-model"><code>mongoose.model()</code></a> and <a href="./api.html#connection_Connection-model"><code>connection.model()</code></a> functions create subclasses of <code>mongoose.Model</code> as shown below.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// `UserModel` is a "Model", a subclass of `mongoose.Model`.</span>
<span class="hljs-keyword">const</span> UserModel = mongoose.model(<span class="hljs-string">'User'</span>, <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> }));

<span class="hljs-comment">// You can use a Model to create new documents using `new`:</span>
<span class="hljs-keyword">const</span> userDoc = <span class="hljs-keyword">new</span> UserModel({ name: <span class="hljs-string">'Foo'</span> });
<span class="hljs-keyword">await</span> userDoc.save();

<span class="hljs-comment">// You also use a model to create queries:</span>
<span class="hljs-keyword">const</span> userFromDb = <span class="hljs-keyword">await</span> UserModel.findOne({ name: <span class="hljs-string">'Foo'</span> });</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.aggregate"><a href="#model_Model.aggregate">Model.aggregate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[pipeline]
<span class="method-type">&laquo;Array&raquo;</span> aggregation pipeline as an array of objects</li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Aggregate&raquo;</span> </li></ul><div><p>Performs <a href="http://docs.mongodb.org/manual/applications/aggregation/">aggregations</a> on the models collection.</p>

<p>If a <code>callback</code> is passed, the <code>aggregate</code> is executed and a <code>Promise</code> is returned. If a callback is not passed, the <code>aggregate</code> itself is returned.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>aggregate()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// Find the max balance of all accounts</span>
Users.aggregate([
  { $group: { _id: <span class="hljs-literal">null</span>, maxBalance: { $max: <span class="hljs-string">'$balance'</span> }}},
  { $project: { _id: <span class="hljs-number">0</span>, maxBalance: <span class="hljs-number">1</span> }}
]).
then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
  <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// [ { maxBalance: 98000 } ]</span>
});

<span class="hljs-comment">// Or use the aggregation pipeline builder.</span>
Users.aggregate().
  group({ _id: <span class="hljs-literal">null</span>, maxBalance: { $max: <span class="hljs-string">'$balance'</span> } }).
  project(<span class="hljs-string">'-id maxBalance'</span>).
  exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, res</span>) </span>{
    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
    <span class="hljs-built_in">console</span>.log(res); <span class="hljs-comment">// [ { maxBalance: 98 } ]</span>
  });</code></pre>

<h4>NOTE:</h4>

<ul>
<li>Arguments are not cast to the model's schema because <code>$project</code> operators allow redefining the "shape" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.</li>
<li>The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).</li>
<li>Requires MongoDB >= 2.1</li>
</ul>  </div><hr class="separate-api-elements"><h3 id="model_Model.bulkWrite"><a href="#model_Model.bulkWrite">Model.bulkWrite()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">ops
<span class="method-type">&laquo;Array&raquo;</span> </li><ul style="margin-top: 0.5em"><li>[ops.insertOne.document]
<span class="method-type">&laquo;Object&raquo;</span> The document to insert</li></ul><ul style="margin-top: 0.5em"><li>[opts.updateOne.filter]
<span class="method-type">&laquo;Object&raquo;</span> Update the first document that matches this filter</li></ul><ul style="margin-top: 0.5em"><li>[opts.updateOne.update]
<span class="method-type">&laquo;Object&raquo;</span> An object containing <a href="https://docs.mongodb.com/manual/reference/operator/update/">update operators</a></li></ul><ul style="margin-top: 0.5em"><li>[opts.updateOne.upsert=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, insert a doc if none match</li></ul><ul style="margin-top: 0.5em"><li>[opts.updateOne.collation]
<span class="method-type">&laquo;Object&raquo;</span> The <a href="https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations">MongoDB collation</a> to use</li></ul><ul style="margin-top: 0.5em"><li>[opts.updateOne.arrayFilters]
<span class="method-type">&laquo;Array&raquo;</span> The <a href="https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html">array filters</a> used in <code>update</code></li></ul><ul style="margin-top: 0.5em"><li>[opts.updateMany.filter]
<span class="method-type">&laquo;Object&raquo;</span> Update all the documents that match this filter</li></ul><ul style="margin-top: 0.5em"><li>[opts.updateMany.update]
<span class="method-type">&laquo;Object&raquo;</span> An object containing <a href="https://docs.mongodb.com/manual/reference/operator/update/">update operators</a></li></ul><ul style="margin-top: 0.5em"><li>[opts.updateMany.upsert=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, insert a doc if no documents match <code>filter</code></li></ul><ul style="margin-top: 0.5em"><li>[opts.updateMany.collation]
<span class="method-type">&laquo;Object&raquo;</span> The <a href="https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations">MongoDB collation</a> to use</li></ul><ul style="margin-top: 0.5em"><li>[opts.updateMany.arrayFilters]
<span class="method-type">&laquo;Array&raquo;</span> The <a href="https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html">array filters</a> used in <code>update</code></li></ul><ul style="margin-top: 0.5em"><li>[opts.deleteOne.filter]
<span class="method-type">&laquo;Object&raquo;</span> Delete the first document that matches this filter</li></ul><ul style="margin-top: 0.5em"><li>[opts.deleteMany.filter]
<span class="method-type">&laquo;Object&raquo;</span> Delete all documents that match this filter</li></ul><ul style="margin-top: 0.5em"><li>[opts.replaceOne.filter]
<span class="method-type">&laquo;Object&raquo;</span> Replace the first document that matches this filter</li></ul><ul style="margin-top: 0.5em"><li>[opts.replaceOne.replacement]
<span class="method-type">&laquo;Object&raquo;</span> The replacement document</li></ul><ul style="margin-top: 0.5em"><li>[opts.replaceOne.upsert=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, insert a doc if no documents match <code>filter</code></li></ul><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> </li><ul style="margin-top: 0.5em"><li>[options.ordered=true]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.</li></ul><ul style="margin-top: 0.5em"><li>[options.session=null]
<span class="method-type">&laquo;ClientSession&raquo;</span> The session associated with this bulk write. See <a href="/docs/transactions.html">transactions docs</a>.</li></ul><ul style="margin-top: 0.5em"><li>[options.w=1]
<span class="method-type">&laquo;String|number&raquo;</span> The <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a>. See <a href="/docs/api.html#query_Query-w"><code>Query#w()</code></a> for more information.</li></ul><ul style="margin-top: 0.5em"><li>[options.wtimeout=null]
<span class="method-type">&laquo;number&raquo;</span> The <a href="https://docs.mongodb.com/manual/reference/write-concern/#wtimeout">write concern timeout</a>.</li></ul><ul style="margin-top: 0.5em"><li>[options.j=true]
<span class="method-type">&laquo;Boolean&raquo;</span> If false, disable <a href="https://docs.mongodb.com/manual/reference/write-concern/#j-option">journal acknowledgement</a></li></ul><ul style="margin-top: 0.5em"><li>[options.bypassDocumentValidation=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, disable <a href="https://docs.mongodb.com/manual/core/schema-validation/">MongoDB server-side schema validation</a> for all writes in this bulk.</li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> callback <code>function(error, bulkWriteOpResult) {}</code></li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> resolves to a <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#~BulkWriteOpResult"><code>BulkWriteOpResult</code></a> if the operation succeeds</li></ul><div><p>Sends multiple <code>insertOne</code>, <code>updateOne</code>, <code>updateMany</code>, <code>replaceOne</code>, <code>deleteOne</code>, and/or <code>deleteMany</code> operations to the MongoDB server in one command. This is faster than sending multiple independent operations (like) if you use <code>create()</code>) because with <code>bulkWrite()</code> there is only one round trip to MongoDB.</p>

<p>Mongoose will perform casting on all operations you provide.</p>

<p>This function does <strong>not</strong> trigger any middleware, not <code>save()</code> nor <code>update()</code>. If you need to trigger <code>save()</code> middleware for every document use <a href="http://mongoosejs.com/docs/api.html#model_Model.create"><code>create()</code></a> instead.</p>

<h4>Example:</h4>

<pre><code>Character.bulkWrite([
  {
    insertOne: {
      <span class="hljs-built_in">document</span>: {
        name: <span class="hljs-string">'Eddard Stark'</span>,
        title: <span class="hljs-string">'Warden of the North'</span>
      }
    }
  },
  {
    updateOne: {
      filter: { name: <span class="hljs-string">'Eddard Stark'</span> },
      <span class="hljs-comment">// If you were using the MongoDB driver directly, you'd need to do</span>
      <span class="hljs-comment">// `update: { $set: { title: ... } }` but mongoose adds $set for</span>
      <span class="hljs-comment">// you.</span>
      update: { title: <span class="hljs-string">'Hand of the King'</span> }
    }
  },
  {
    deleteOne: {
      {
        filter: { name: <span class="hljs-string">'Eddard Stark'</span> }
      }
    }
  }
]).then(res =&gt; {
 <span class="hljs-comment">// Prints "1 1 1"</span>
 <span class="hljs-built_in">console</span>.log(res.insertedCount, res.modifiedCount, res.deletedCount);
});</code></pre>

<p>The <a href="https://docs.mongodb.com/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite">supported operations</a> are:</p>

<ul>
<li><code>insertOne</code></li>
<li><code>updateOne</code></li>
<li><code>updateMany</code></li>
<li><code>deleteOne</code></li>
<li><code>deleteMany</code></li>
<li><code>replaceOne</code></li>
</ul>  </div><hr class="separate-api-elements"><h3 id="model_Model.count"><a href="#model_Model.count">Model.count()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">filter
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Counts number of documents that match <code>filter</code> in a database collection.</p>

<p>This method is deprecated. If you want to count the number of documents in a collection, e.g. <code>count({})</code>, use the <a href="/docs/api.html#model_Model.estimatedDocumentCount"><code>estimatedDocumentCount()</code> function</a> instead. Otherwise, use the <a href="/docs/api.html#model_Model.countDocuments"><code>countDocuments()</code></a> function instead.</p>

<h4>Example:</h4>

<pre><code>Adventure.count({ type: <span class="hljs-string">'jungle'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, count</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there are %d jungle adventures'</span>, count);
});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.countDocuments"><a href="#model_Model.countDocuments">Model.countDocuments()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">filter
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Counts number of documents matching <code>filter</code> in a database collection.</p>

<h4>Example:</h4>

<pre><code>Adventure.countDocuments({ type: <span class="hljs-string">'jungle'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, count</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'there are %d jungle adventures'</span>, count);
});</code></pre>

<p>If you want to count all documents in a large collection, use the <a href="/docs/api.html#model_Model.estimatedDocumentCount"><code>estimatedDocumentCount()</code> function</a> instead. If you call <code>countDocuments({})</code>, MongoDB will always execute a full collection scan and <strong>not</strong> use any indexes.</p>

<p>The <code>countDocuments()</code> function is similar to <code>count()</code>, but there are a <a href="https://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#countDocuments">few operators that <code>countDocuments()</code> does not support</a>. Below are the operators that <code>count()</code> supports but <code>countDocuments()</code> does not, and the suggested replacement:</p>

<ul>
<li><code>$where</code>: <a href="https://docs.mongodb.com/manual/reference/operator/query/expr/"><code>$expr</code></a></li>
<li><code>$near</code>: <a href="https://docs.mongodb.com/manual/reference/operator/query/geoWithin/"><code>$geoWithin</code></a> with <a href="https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center"><code>$center</code></a></li>
<li><code>$nearSphere</code>: <a href="https://docs.mongodb.com/manual/reference/operator/query/geoWithin/"><code>$geoWithin</code></a> with <a href="https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere"><code>$centerSphere</code></a></li>
</ul>  </div><hr class="separate-api-elements"><h3 id="model_Model.create"><a href="#model_Model.create">Model.create()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">docs
<span class="method-type">&laquo;Array|Object&raquo;</span> Documents to insert, as a spread or array</li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> Options passed down to <code>save()</code>. To specify <code>options</code>, <code>docs</code> <strong>must</strong> be an array, not a spread.</li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Shortcut for saving one or more documents to the database. <code>MyModel.create(docs)</code> does <code>new MyModel(doc).save()</code> for every doc in docs.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>save()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// pass a spread of docs and a callback</span>
Candy.create({ type: <span class="hljs-string">'jelly bean'</span> }, { type: <span class="hljs-string">'snickers'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, jellybean, snickers</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-comment">// ...</span>
});

<span class="hljs-comment">// pass an array of docs</span>
<span class="hljs-keyword">var</span> array = [{ type: <span class="hljs-string">'jelly bean'</span> }, { type: <span class="hljs-string">'snickers'</span> }];
Candy.create(array, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, candies</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-comment">// ...</span>

  <span class="hljs-keyword">var</span> jellybean = candies[<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> snickers = candies[<span class="hljs-number">1</span>];
  <span class="hljs-comment">// ...</span>
});

<span class="hljs-comment">// callback is optional; use the returned promise if you like:</span>
<span class="hljs-keyword">var</span> promise = Candy.create({ type: <span class="hljs-string">'jawbreaker'</span> });
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">jawbreaker</span>) </span>{
  <span class="hljs-comment">// ...</span>
})</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.createCollection"><a href="#model_Model.createCollection">Model.createCollection()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> see <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/Db.html#createCollection">MongoDB driver docs</a></li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>Create the collection for this model. By default, if no indexes are specified, mongoose will not create the collection for the model until any documents are created. Use this method to create the collection explicitly.</p>

<p>Note 1: You may need to call this before starting a transaction See <a href='https://docs.mongodb.com/manual/core/transactions/#transactions-and-operations'>https://docs.mongodb.com/manual/core/transactions/#transactions-and-operations</a></p>

<p>Note 2: You don't have to call this if your schema contains index or unique field. In that case, just use <code>Model.init()</code></p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> userSchema = <span class="hljs-keyword">new</span> Schema({ name: <span class="hljs-built_in">String</span> })
<span class="hljs-keyword">var</span> User = mongoose.model(<span class="hljs-string">'User'</span>, userSchema);

User.createCollection().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">collection</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Collection is created!'</span>);
});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.createIndexes"><a href="#model_Model.createIndexes">Model.createIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> internal options</li><li class="param">[cb]
<span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Similar to <code>ensureIndexes()</code>, except for it uses the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#createIndex"><code>createIndex</code></a> function.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model.deleteMany"><a href="#model_Model.deleteMany">Model.deleteMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Deletes all of the documents that match <code>conditions</code> from the collection. Behaves like <code>remove()</code>, but deletes all documents that match <code>conditions</code> regardless of the <code>single</code> option.</p>

<h4>Example:</h4>

<pre><code>Character.deleteMany({ name: <span class="hljs-regexp">/Stark/</span>, age: { $gte: <span class="hljs-number">18</span> } }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>Like <code>Model.remove()</code>, this function does <strong>not</strong> trigger <code>pre('remove')</code> or <code>post('remove')</code> hooks.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model.deleteOne"><a href="#model_Model.deleteOne">Model.deleteOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Deletes the first document that matches <code>conditions</code> from the collection. Behaves like <code>remove()</code>, but deletes at most one document regardless of the <code>single</code> option.</p>

<h4>Example:</h4>

<pre><code>Character.deleteOne({ name: <span class="hljs-string">'Eddard Stark'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{});</code></pre>

<h4>Note:</h4>

<p>Like <code>Model.remove()</code>, this function does <strong>not</strong> trigger <code>pre('remove')</code> or <code>post('remove')</code> hooks.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model.discriminator"><a href="#model_Model.discriminator">Model.discriminator()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name
<span class="method-type">&laquo;String&raquo;</span> discriminator model name</li><li class="param">schema
<span class="method-type">&laquo;Schema&raquo;</span> discriminator model schema</li><li class="param">value
<span class="method-type">&laquo;String&raquo;</span> the string stored in the <code>discriminatorKey</code> property</li></ul><div><p>Adds a discriminator type.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BaseSchema</span>(<span class="hljs-params"></span>) </span>{
  Schema.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);

  <span class="hljs-keyword">this</span>.add({
    name: <span class="hljs-built_in">String</span>,
    createdAt: <span class="hljs-built_in">Date</span>
  });
}
util.inherits(BaseSchema, Schema);

<span class="hljs-keyword">var</span> PersonSchema = <span class="hljs-keyword">new</span> BaseSchema();
<span class="hljs-keyword">var</span> BossSchema = <span class="hljs-keyword">new</span> BaseSchema({ department: <span class="hljs-built_in">String</span> });

<span class="hljs-keyword">var</span> Person = mongoose.model(<span class="hljs-string">'Person'</span>, PersonSchema);
<span class="hljs-keyword">var</span> Boss = Person.discriminator(<span class="hljs-string">'Boss'</span>, BossSchema);
<span class="hljs-keyword">new</span> Boss().__t; <span class="hljs-comment">// "Boss". `__t` is the default `discriminatorKey`</span>

<span class="hljs-keyword">var</span> employeeSchema = <span class="hljs-keyword">new</span> Schema({ boss: ObjectId });
<span class="hljs-keyword">var</span> Employee = Person.discriminator(<span class="hljs-string">'Employee'</span>, employeeSchema, <span class="hljs-string">'staff'</span>);
<span class="hljs-keyword">new</span> Employee().__t; <span class="hljs-comment">// "staff" because of 3rd argument above</span></code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.distinct"><a href="#model_Model.distinct">Model.distinct()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">field
<span class="method-type">&laquo;String&raquo;</span> </li><li class="param">[conditions]
<span class="method-type">&laquo;Object&raquo;</span> optional</li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a Query for a <code>distinct</code> operation.</p>

<p>Passing a <code>callback</code> executes the query.</p>

<h4>Example</h4>

<pre><code>Link.distinct(<span class="hljs-string">'url'</span>, { clicks: {$gt: <span class="hljs-number">100</span>}}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, result</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);

  assert(<span class="hljs-built_in">Array</span>.isArray(result));
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'unique urls with more than 100 clicks'</span>, result);
})

<span class="hljs-keyword">var</span> query = Link.distinct(<span class="hljs-string">'url'</span>);
query.exec(callback);</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.ensureIndexes"><a href="#model_Model.ensureIndexes">Model.ensureIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> internal options</li><li class="param">[cb]
<span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Sends <code>createIndex</code> commands to mongo for each index declared in the schema. The <code>createIndex</code> commands are sent in series.</p>

<h4>Example:</h4>

<pre><code>Event.ensureIndexes(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
});</code></pre>

<p>After completion, an <code>index</code> event is emitted on this <code>Model</code> passing an error if one occurred.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> eventSchema = <span class="hljs-keyword">new</span> Schema({ thing: { type: <span class="hljs-string">'string'</span>, unique: <span class="hljs-literal">true</span> }})
<span class="hljs-keyword">var</span> Event = mongoose.model(<span class="hljs-string">'Event'</span>, eventSchema);

Event.on(<span class="hljs-string">'index'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-built_in">console</span>.error(err); <span class="hljs-comment">// error occurred during index creation</span>
})</code></pre>

<p><em>NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution.</em></p>  </div><hr class="separate-api-elements"><h3 id="model_Model.estimatedDocumentCount"><a href="#model_Model.estimatedDocumentCount">Model.estimatedDocumentCount()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Estimates the number of documents in the MongoDB collection. Faster than using <code>countDocuments()</code> for large collections because <code>estimatedDocumentCount()</code> uses collection metadata rather than scanning the entire collection.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> numAdventures = Adventure.estimatedDocumentCount();</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model-events"><a href="#model_Model-events">Model.events</a></h3><h5>Type:</h5><ul><li><span class="method-type">&laquo;property&raquo;</span></li></ul><div><p>Event emitter that reports any errors that occurred. Useful for global error handling.</p>

<h4>Example:</h4>

<pre><code>MyModel.events.on(<span class="hljs-string">'error'</span>, err =&gt; <span class="hljs-built_in">console</span>.log(err.message));

<span class="hljs-comment">// Prints a 'CastError' because of the above handler</span>
<span class="hljs-keyword">await</span> MyModel.findOne({ _id: <span class="hljs-string">'notanid'</span> }).catch(noop);</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.exists"><a href="#model_Model.exists">Model.exists()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">filter
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Returns true if at least one document exists in the database that matches the given <code>filter</code>, and false otherwise.</p>

<p>Under the hood, <code>MyModel.exists({ answer: 42 })</code> is equivalent to <code>MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean().then(doc => !!doc)</code></p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">await</span> Character.deleteMany({});
<span class="hljs-keyword">await</span> Character.create({ name: <span class="hljs-string">'Jean-Luc Picard'</span> });

<span class="hljs-keyword">await</span> Character.exists({ name: <span class="hljs-regexp">/picard/i</span> }); <span class="hljs-comment">// true</span>
<span class="hljs-keyword">await</span> Character.exists({ name: <span class="hljs-regexp">/riker/i</span> }); <span class="hljs-comment">// false</span></code></pre>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOne()</code></li>
</ul>  </div><hr class="separate-api-elements"><h3 id="model_Model.find"><a href="#model_Model.find">Model.find()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[projection]
<span class="method-type">&laquo;Object|String&raquo;</span> optional fields to return, see <a href="#query_Query-select"><code>Query.prototype.select()</code></a></li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds documents</p>

<p>The <code>conditions</code> are cast to their respective SchemaTypes before the command is sent.</p>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// named john and at least 18</span>
MyModel.find({ name: <span class="hljs-string">'john'</span>, age: { $gte: <span class="hljs-number">18</span> }});

<span class="hljs-comment">// executes, passing results to callback</span>
MyModel.find({ name: <span class="hljs-string">'john'</span>, age: { $gte: <span class="hljs-number">18</span> }}, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// executes, name LIKE john and only selecting the "name" and "friends" fields</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-string">'name friends'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{ })

<span class="hljs-comment">// passing options</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> })

<span class="hljs-comment">// passing options and executes</span>
MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// executing a query explicitly</span>
<span class="hljs-keyword">var</span> query = MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> })
query.exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});

<span class="hljs-comment">// using the promise returned from executing a query</span>
<span class="hljs-keyword">var</span> query = MyModel.find({ name: <span class="hljs-regexp">/john/i</span> }, <span class="hljs-literal">null</span>, { skip: <span class="hljs-number">10</span> });
<span class="hljs-keyword">var</span> promise = query.exec();
promise.addBack(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.findById"><a href="#model_Model.findById">Model.findById()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">id
<span class="method-type">&laquo;Object|String|Number&raquo;</span> value of <code>_id</code> to query by</li><li class="param">[projection]
<span class="method-type">&laquo;Object|String&raquo;</span> optional fields to return, see <a href="#query_Query-select"><code>Query.prototype.select()</code></a></li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds a single document by its _id field. <code>findById(id)</code> is almost* equivalent to <code>findOne({ _id: id })</code>. If you want to query by a document's <code>_id</code>, use <code>findById()</code> instead of <code>findOne()</code>.</p>

<p>The <code>id</code> is cast based on the Schema before sending the command.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOne()</code></li>
</ul>

<p>* Except for how it treats <code>undefined</code>. If you use <code>findOne()</code>, you'll see that <code>findOne(undefined)</code> and <code>findOne({ _id: undefined })</code> are equivalent to <code>findOne({})</code> and return arbitrary documents. However, mongoose translates <code>findById(undefined)</code> into <code>findOne({ _id: null })</code>.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// find adventure by id and execute</span>
Adventure.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id).exec(callback);

<span class="hljs-comment">// select only the adventures name and length</span>
Adventure.findById(id, <span class="hljs-string">'name length'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id, <span class="hljs-string">'name length'</span>).exec(callback);

<span class="hljs-comment">// include all properties except for `length`</span>
Adventure.findById(id, <span class="hljs-string">'-length'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// passing options (in this case return the raw js objects, not mongoose documents by passing `lean`</span>
Adventure.findById(id, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findById(id, <span class="hljs-string">'name'</span>).lean().exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.findByIdAndDelete"><a href="#model_Model.findByIdAndDelete">Model.findByIdAndDelete()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">id
<span class="method-type">&laquo;Object|Number|String&raquo;</span> value of <code>_id</code> to query by</li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a MongoDB <code>findOneAndDelete()</code> command by a document's _id field. In other words, <code>findByIdAndDelete(id)</code> is a shorthand for <code>findOneAndDelete({ _id: id })</code>.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndDelete()</code></li>
</ul>  </div><hr class="separate-api-elements"><h3 id="model_Model.findByIdAndRemove"><a href="#model_Model.findByIdAndRemove">Model.findByIdAndRemove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">id
<span class="method-type">&laquo;Object|Number|String&raquo;</span> value of <code>_id</code> to query by</li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a mongodb findAndModify remove command by a document's _id field. <code>findByIdAndRemove(id, ...)</code> is equivalent to <code>findOneAndRemove({ _id: id }, ...)</code>.</p>

<p>Finds a matching document, removes it, passing the found document (if any) to the callback.</p>

<p>Executes the query if <code>callback</code> is passed.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndRemove()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findByIdAndRemove(id, options, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndRemove(id, options)  <span class="hljs-comment">// return Query</span>
A.findByIdAndRemove(id, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndRemove(id) <span class="hljs-comment">// returns Query</span>
A.findByIdAndRemove()           <span class="hljs-comment">// returns Query</span></code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.findByIdAndUpdate"><a href="#model_Model.findByIdAndUpdate">Model.findByIdAndUpdate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">id
<span class="method-type">&laquo;Object|Number|String&raquo;</span> value of <code>_id</code> to query by</li><li class="param">[update]
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.lean]
<span class="method-type">&laquo;Object&raquo;</span> if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See <a href="/docs/api.html#query_Query-lean"><code>Query.lean()</code></a> and the <a href="/docs/tutorials/lean.html">Mongoose lean tutorial</a>.</li></ul><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><ul style="margin-top: 0.5em"><li>[options.omitUndefined=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, delete any properties whose value is <code>undefined</code> when casting an update. In other words, if this is set, Mongoose will delete <code>baz</code> from the update in <code>Model.updateOne({}, { foo: &#39;bar&#39;, baz: undefined })</code> before sending the update to the server.</li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issues a mongodb findAndModify update command by a document's _id field. <code>findByIdAndUpdate(id, ...)</code> is equivalent to <code>findOneAndUpdate({ _id: id }, ...)</code>.</p>

<p>Finds a matching document, updates it according to the <code>update</code> arg, passing any <code>options</code>, and returns the found document (if any) to the callback. The query executes if <code>callback</code> is passed.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndUpdate()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>new</code>: bool - true to return the modified document rather than the original. defaults to false</li>
<li><code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findByIdAndUpdate(id, update, options, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndUpdate(id, update, options)  <span class="hljs-comment">// returns Query</span>
A.findByIdAndUpdate(id, update, callback) <span class="hljs-comment">// executes</span>
A.findByIdAndUpdate(id, update)           <span class="hljs-comment">// returns Query</span>
A.findByIdAndUpdate()                     <span class="hljs-comment">// returns Query</span></code></pre>

<h4>Note:</h4>

<p>All top level update keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code>Model.findByIdAndUpdate(id, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.findByIdAndUpdate(id, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)</code></pre>

<p>This helps prevent accidentally overwriting your document with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.findOne"><a href="#model_Model.findOne">Model.findOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[conditions]
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[projection]
<span class="method-type">&laquo;Object|String&raquo;</span> optional fields to return, see <a href="#query_Query-select"><code>Query.prototype.select()</code></a></li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Finds one document.</p>

<p>The <code>conditions</code> are cast to their respective SchemaTypes before the command is sent.</p>

<p><em>Note:</em> <code>conditions</code> is optional, and if <code>conditions</code> is null or undefined, mongoose will send an empty <code>findOne</code> command to MongoDB, which will return an arbitrary document. If you're querying by <code>_id</code>, use <code>findById()</code> instead.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// find one iphone adventures - iphone adventures??</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// select only the adventures name</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, adventure</span>) </span>{});

<span class="hljs-comment">// specify options, in this case lean</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }, callback);

<span class="hljs-comment">// same as above</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }, <span class="hljs-string">'name'</span>, { lean: <span class="hljs-literal">true</span> }).exec(callback);

<span class="hljs-comment">// chaining findOne queries (same as above)</span>
Adventure.findOne({ type: <span class="hljs-string">'iphone'</span> }).select(<span class="hljs-string">'name'</span>).lean().exec(callback);</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.findOneAndDelete"><a href="#model_Model.findOneAndDelete">Model.findOneAndDelete()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a MongoDB <code>findOneAndDelete()</code> command.</p>

<p>Finds a matching document, removes it, and passes the found document (if any) to the callback.</p>

<p>Executes the query if <code>callback</code> is passed.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndDelete()</code></li>
</ul>

<p>This function differs slightly from <code>Model.findOneAndRemove()</code> in that <code>findOneAndRemove()</code> becomes a <a href="https://docs.mongodb.com/manual/reference/method/db.collection.findAndModify/">MongoDB <code>findAndModify()</code> command</a>, as opposed to a <code>findOneAndDelete()</code> command. For most mongoose use cases, this distinction is purely pedantic. You should use <code>findOneAndDelete()</code> unless you have a good reason not to.</p>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>projection</code>: like select, it determines which fields to return, ex. <code>{ projection: { _id: 0 } }</code></li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndDelete(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndDelete(conditions, options)  <span class="hljs-comment">// return Query</span>
A.findOneAndDelete(conditions, callback) <span class="hljs-comment">// executes</span>
A.findOneAndDelete(conditions) <span class="hljs-comment">// returns Query</span>
A.findOneAndDelete()           <span class="hljs-comment">// returns Query</span></code></pre>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.findOneAndRemove"><a href="#model_Model.findOneAndRemove">Model.findOneAndRemove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a mongodb findAndModify remove command.</p>

<p>Finds a matching document, removes it, passing the found document (if any) to the callback.</p>

<p>Executes the query if <code>callback</code> is passed.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>findOneAndRemove()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>projection</code>: like select, it determines which fields to return, ex. <code>{ projection: { _id: 0 } }</code></li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndRemove(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndRemove(conditions, options)  <span class="hljs-comment">// return Query</span>
A.findOneAndRemove(conditions, callback) <span class="hljs-comment">// executes</span>
A.findOneAndRemove(conditions) <span class="hljs-comment">// returns Query</span>
A.findOneAndRemove()           <span class="hljs-comment">// returns Query</span></code></pre>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.findOneAndReplace"><a href="#model_Model.findOneAndReplace">Model.findOneAndReplace()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">filter
<span class="method-type">&laquo;Object&raquo;</span> Replace the first document that matches this filter</li><li class="param">[replacement]
<span class="method-type">&laquo;Object&raquo;</span> Replace with this document</li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.lean]
<span class="method-type">&laquo;Object&raquo;</span> if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See <a href="http://mongoosejs.com/docs/api.html#query_Query-lean"><code>Query.lean()</code></a>.</li></ul><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><ul style="margin-top: 0.5em"><li>[options.omitUndefined=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, delete any properties whose value is <code>undefined</code> when casting an update. In other words, if this is set, Mongoose will delete <code>baz</code> from the update in <code>Model.updateOne({}, { foo: &#39;bar&#39;, baz: undefined })</code> before sending the update to the server.</li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issue a MongoDB <code>findOneAndReplace()</code> command.</p>

<p>Finds a matching document, replaces it with the provided doc, and passes the returned doc to the callback.</p>

<p>Executes the query if <code>callback</code> is passed.</p>

<p>This function triggers the following query middleware.</p>

<ul>
<li><code>findOneAndReplace()</code></li>
</ul>

<h4>Options:</h4>

<ul>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>select</code>: sets the document fields to return</li>
<li><code>projection</code>: like select, it determines which fields to return, ex. <code>{ projection: { _id: 0 } }</code></li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndReplace(conditions, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndReplace(conditions, options)  <span class="hljs-comment">// return Query</span>
A.findOneAndReplace(conditions, callback) <span class="hljs-comment">// executes</span>
A.findOneAndReplace(conditions) <span class="hljs-comment">// returns Query</span>
A.findOneAndReplace()           <span class="hljs-comment">// returns Query</span></code></pre>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>  </div><hr class="separate-api-elements"><h3 id="model_Model.findOneAndUpdate"><a href="#model_Model.findOneAndUpdate">Model.findOneAndUpdate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[conditions]
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[update]
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.lean]
<span class="method-type">&laquo;Object&raquo;</span> if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See <a href="/docs/api.html#query_Query-lean"><code>Query.lean()</code></a> and <a href="/docs/tutorials/lean.html">the Mongoose lean tutorial</a>.</li></ul><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><ul style="margin-top: 0.5em"><li>[options.omitUndefined=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, delete any properties whose value is <code>undefined</code> when casting an update. In other words, if this is set, Mongoose will delete <code>baz</code> from the update in <code>Model.updateOne({}, { foo: &#39;bar&#39;, baz: undefined })</code> before sending the update to the server.</li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Issues a mongodb findAndModify update command.</p>

<p>Finds a matching document, updates it according to the <code>update</code> arg, passing any <code>options</code>, and returns the found document (if any) to the callback. The query executes if <code>callback</code> is passed else a Query object is returned.</p>

<h4>Options:</h4>

<ul>
<li><code>new</code>: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)</li>
<li><code>upsert</code>: bool - creates the object if it doesn't exist. defaults to false.</li>
<li><code>fields</code>: {Object|String} - Field selection. Equivalent to <code>.select(fields).findOneAndUpdate()</code></li>
<li><code>maxTimeMS</code>: puts a time limit on the query - requires mongodb >= 2.6.0</li>
<li><code>sort</code>: if multiple docs are found by the conditions, sets the sort order to choose which doc to update</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code>: if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>rawResult</code>: if true, returns the <a href="http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify">raw result from the MongoDB driver</a></li>
<li><code>strict</code>: overwrites the schema's <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a> for this update</li>
</ul>

<h4>Examples:</h4>

<pre><code>A.findOneAndUpdate(conditions, update, options, callback) <span class="hljs-comment">// executes</span>
A.findOneAndUpdate(conditions, update, options)  <span class="hljs-comment">// returns Query</span>
A.findOneAndUpdate(conditions, update, callback) <span class="hljs-comment">// executes</span>
A.findOneAndUpdate(conditions, update)           <span class="hljs-comment">// returns Query</span>
A.findOneAndUpdate()                             <span class="hljs-comment">// returns Query</span></code></pre>

<h4>Note:</h4>

<p>All top level update keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> query = { name: <span class="hljs-string">'borne'</span> };
Model.findOneAndUpdate(query, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback)

<span class="hljs-comment">// is sent as</span>
Model.findOneAndUpdate(query, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, callback)</code></pre>

<p>This helps prevent accidentally overwriting your document with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Values are cast to their appropriate types when using the findAndModify helpers. However, the below are not executed by default.</p>

<ul>
<li>defaults. Use the <code>setDefaultsOnInsert</code> option to override.</li>
</ul>

<p><code>findAndModify</code> helpers support limited validation. You can enable these by setting the <code>runValidators</code> options, respectively.</p>

<p>If you need full-fledged validation, use the traditional approach of first retrieving the document.</p>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.geoSearch"><a href="#model_Model.geoSearch">Model.geoSearch()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions
<span class="method-type">&laquo;Object&raquo;</span> an object that specifies the match condition (required)</li><li class="param">options
<span class="method-type">&laquo;Object&raquo;</span> for the geoSearch, some (near, maxDistance) are required</li><ul style="margin-top: 0.5em"><li>[options.lean]
<span class="method-type">&laquo;Object|Boolean&raquo;</span> if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See <a href="/docs/api.html#query_Query-lean"><code>Query.lean()</code></a> and the <a href="/docs/tutorials/lean.html">Mongoose lean tutorial</a>.</li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Implements <code>$geoSearch</code> functionality for Mongoose</p>

<p>This function does not trigger any middleware</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> options = { near: [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>], maxDistance: <span class="hljs-number">5</span> };
Locations.geoSearch({ type : <span class="hljs-string">"house"</span> }, options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>) </span>{
  <span class="hljs-built_in">console</span>.log(res);
});</code></pre>

<h4>Options:</h4>

<ul>
<li><code>near</code> {Array} x,y point to search for</li>
<li><code>maxDistance</code> {Number} the maximum distance from the point near that a result can be</li>
<li><code>limit</code> {Number} The maximum number of results to return</li>
<li><code>lean</code> {Object|Boolean} return the raw object instead of the Mongoose Model</li>
</ul>  </div><hr class="separate-api-elements"><h3 id="model_Model.hydrate"><a href="#model_Model.hydrate">Model.hydrate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">obj
<span class="method-type">&laquo;Object&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Model&raquo;</span> document instance</li></ul><div><p>Shortcut for creating a new Document from existing raw data, pre-saved in the DB. The document returned has no paths marked as modified initially.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-comment">// hydrate previous data into a Mongoose document</span>
<span class="hljs-keyword">var</span> mongooseCandy = Candy.hydrate({ _id: <span class="hljs-string">'54108337212ffb6d459f854c'</span>, type: <span class="hljs-string">'jelly bean'</span> });</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.init"><a href="#model_Model.init">Model.init()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><div><p>This function is responsible for building <a href="https://docs.mongodb.com/manual/indexes/">indexes</a>, unless <a href="http://mongoosejs.com/docs/guide.html#autoIndex"><code>autoIndex</code></a> is turned off.</p>

<p>Mongoose calls this function automatically when a model is created using <a href="/docs/api.html#mongoose_Mongoose-model"><code>mongoose.model()</code></a> or * <a href="/docs/api.html#connection_Connection-model"><code>connection.model()</code></a>, so you don't need to call it. This function is also idempotent, so you may call it to get back a promise that will resolve when your indexes are finished building as an alternative to <a href="/docs/guide.html#indexes"><code>MyModel.on('index')</code></a></p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> eventSchema = <span class="hljs-keyword">new</span> Schema({ thing: { type: <span class="hljs-string">'string'</span>, unique: <span class="hljs-literal">true</span> }})
<span class="hljs-comment">// This calls `Event.init()` implicitly, so you don't need to call</span>
<span class="hljs-comment">// `Event.init()` on your own.</span>
<span class="hljs-keyword">var</span> Event = mongoose.model(<span class="hljs-string">'Event'</span>, eventSchema);

Event.init().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Event</span>) </span>{
  <span class="hljs-comment">// You can also use `Event.on('index')` if you prefer event emitters</span>
  <span class="hljs-comment">// over promises.</span>
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Indexes are done building!'</span>);
});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.insertMany"><a href="#model_Model.insertMany">Model.insertMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">doc(s)
<span class="method-type">&laquo;Array|Object|*&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> see the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#insertMany">mongodb driver options</a></li><li class="param">[options.ordered
<span class="method-type">&laquo;Boolean&raquo;</span> = true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An <code>insertMany()</code> with <code>ordered = false</code> is called an &quot;unordered&quot; <code>insertMany()</code>.</li><li class="param">[options.rawResult
<span class="method-type">&laquo;Boolean&raquo;</span> = false] if false, the returned promise resolves to the documents that passed mongoose document validation. If <code>true</code>, will return the <a href="http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~insertWriteOpCallback">raw result from the MongoDB driver</a> with a <code>mongoose</code> property that contains <code>validationErrors</code> if this is an unordered <code>insertMany</code>.</li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Shortcut for validating an array of documents and inserting them into MongoDB if they're all valid. This function is faster than <code>.create()</code> because it only sends one operation to the server, rather than one for each document.</p>

<p>Mongoose always validates each document <strong>before</strong> sending <code>insertMany</code> to MongoDB. So if one document has a validation error, no documents will be saved, unless you set <a href="https://docs.mongodb.com/manual/reference/method/db.collection.insertMany/#error-handling">the <code>ordered</code> option to false</a>.</p>

<p>This function does <strong>not</strong> trigger save middleware.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>insertMany()</code></li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> arr = [{ name: <span class="hljs-string">'Star Wars'</span> }, { name: <span class="hljs-string">'The Empire Strikes Back'</span> }];
Movies.insertMany(arr, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error, docs</span>) </span>{});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.listIndexes"><a href="#model_Model.listIndexes">Model.listIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[cb]
<span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise,undefined&raquo;</span> Returns <code>undefined</code> if callback is specified, returns a promise if no callback.</li></ul><div><p>Lists the indexes currently defined in MongoDB. This may or may not be the same as the indexes defined in your schema depending on whether you use the <a href="/docs/guide.html#autoIndex"><code>autoIndex</code> option</a> and if you build indexes manually.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model.mapReduce"><a href="#model_Model.mapReduce">Model.mapReduce()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">o
<span class="method-type">&laquo;Object&raquo;</span> an object specifying map-reduce options</li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Executes a mapReduce command.</p>

<p><code>o</code> is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See <a href="http://mongodb.github.io/node-mongodb-native/api-generated/collection.html#mapreduce">node-mongodb-native mapReduce() documentation</a> for more detail about options.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> o = {};
<span class="hljs-comment">// `map()` and `reduce()` are run on the MongoDB server, not Node.js,</span>
<span class="hljs-comment">// these functions are converted to strings</span>
o.map = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ emit(<span class="hljs-keyword">this</span>.name, <span class="hljs-number">1</span>) };
o.reduce = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">k, vals</span>) </span>{ <span class="hljs-keyword">return</span> vals.length };
User.mapReduce(o, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, results</span>) </span>{
  <span class="hljs-built_in">console</span>.log(results)
})</code></pre>

<h4>Other options:</h4>

<ul>
<li><code>query</code> {Object} query filter object.</li>
<li><code>sort</code> {Object} sort input objects using this key</li>
<li><code>limit</code> {Number} max number of documents</li>
<li><code>keeptemp</code> {Boolean, default:false} keep temporary data</li>
<li><code>finalize</code> {Function} finalize function</li>
<li><code>scope</code> {Object} scope variables exposed to map/reduce/finalize during execution</li>
<li><code>jsMode</code> {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X</li>
<li><code>verbose</code> {Boolean, default:false} provide statistics on job execution time.</li>
<li><code>readPreference</code> {String}</li>
<li><code>out*</code> {Object, default: {inline:1}} sets the output target for the map reduce job.</li>
</ul>

<h4>* out options:</h4>

<ul>
<li><code>{inline:1}</code> the results are returned in an array</li>
<li><code>{replace: 'collectionName'}</code> add the results to collectionName: the results replace the collection</li>
<li><code>{reduce: 'collectionName'}</code> add the results to collectionName: if dups are detected, uses the reducer / finalize functions</li>
<li><code>{merge: 'collectionName'}</code> add the results to collectionName: if dups exist the new docs overwrite the old</li>
</ul>

<p>If <code>options.out</code> is set to <code>replace</code>, <code>merge</code>, or <code>reduce</code>, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the <a href="/docs/tutorials/lean.html"><code>lean</code> option</a>; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> o = {};
<span class="hljs-comment">// You can also define `map()` and `reduce()` as strings if your</span>
<span class="hljs-comment">// linter complains about `emit()` not being defined</span>
o.map = <span class="hljs-string">'function () { emit(this.name, 1) }'</span>;
o.reduce = <span class="hljs-string">'function (k, vals) { return vals.length }'</span>;
o.out = { replace: <span class="hljs-string">'createdCollectionNameForResults'</span> }
o.verbose = <span class="hljs-literal">true</span>;

User.mapReduce(o, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, model, stats</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'map reduce took %d ms'</span>, stats.processtime)
  model.find().where(<span class="hljs-string">'value'</span>).gt(<span class="hljs-number">10</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{
    <span class="hljs-built_in">console</span>.log(docs);
  });
})

<span class="hljs-comment">// `mapReduce()` returns a promise. However, ES6 promises can only</span>
<span class="hljs-comment">// resolve to exactly one value,</span>
o.resolveToObject = <span class="hljs-literal">true</span>;
<span class="hljs-keyword">var</span> promise = User.mapReduce(o);
promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>{
  <span class="hljs-keyword">var</span> model = res.model;
  <span class="hljs-keyword">var</span> stats = res.stats;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'map reduce took %d ms'</span>, stats.processtime)
  <span class="hljs-keyword">return</span> model.find().where(<span class="hljs-string">'value'</span>).gt(<span class="hljs-number">10</span>).exec();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">docs</span>) </span>{
   <span class="hljs-built_in">console</span>.log(docs);
}).then(<span class="hljs-literal">null</span>, handleError).end()</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.populate"><a href="#model_Model.populate">Model.populate()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">docs
<span class="method-type">&laquo;Document|Array&raquo;</span> Either a single document or array of documents to populate.</li><li class="param">options
<span class="method-type">&laquo;Object&raquo;</span> A hash of key/val (path, options) used for population.</li><ul style="margin-top: 0.5em"><li>[options.retainNullValues=false]
<span class="method-type">&laquo;boolean&raquo;</span> by default, Mongoose removes null and undefined values from populated arrays. Use this option to make <code>populate()</code> retain <code>null</code> and <code>undefined</code> array entries.</li></ul><ul style="margin-top: 0.5em"><li>[options.getters=false]
<span class="method-type">&laquo;boolean&raquo;</span> if true, Mongoose will call any getters defined on the <code>localField</code>. By default, Mongoose gets the raw value of <code>localField</code>. For example, you would need to set this option to <code>true</code> if you wanted to <a href="/docs/schematypes.html#schematype-options">add a <code>lowercase</code> getter to your <code>localField</code></a>.</li></ul><ul style="margin-top: 0.5em"><li>[options.clone=false]
<span class="method-type">&laquo;boolean&raquo;</span> When you do <code>BlogPost.find().populate(&#39;author&#39;)</code>, blog posts with the same author will share 1 copy of an <code>author</code> doc. Enable this option to make Mongoose clone populated docs before assigning them.</li></ul><ul style="margin-top: 0.5em"><li>[options.match=null]
<span class="method-type">&laquo;Object|Function&raquo;</span> Add an additional filter to the populate query. Can be a filter object containing <a href="https://docs.mongodb.com/manual/tutorial/query-documents/">MongoDB query syntax</a>, or a function that returns a filter object.</li></ul><ul style="margin-top: 0.5em"><li>[options.skipInvalidIds=false]
<span class="method-type">&laquo;Boolean&raquo;</span> By default, Mongoose throws a cast error if <code>localField</code> and <code>foreignField</code> schemas don&#39;t line up. If you enable this option, Mongoose will instead filter out any <code>localField</code> properties that cannot be casted to <code>foreignField</code>&#39;s schema type.</li></ul><li class="param">[callback(err,doc)]
<span class="method-type">&laquo;Function&raquo;</span> Optional callback, executed upon completion. Receives <code>err</code> and the <code>doc(s)</code>.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> </li></ul><div><p>Populates document references.</p>

<h4>Available top-level options:</h4>

<ul>
<li>path: space delimited path(s) to populate</li>
<li>select: optional fields to select</li>
<li>match: optional query conditions to match</li>
<li>model: optional name of the model to use for population</li>
<li>options: optional query options like sort, limit, etc</li>
<li>justOne: optional boolean, if true Mongoose will always set <code>path</code> to an array. Inferred from schema by default.</li>
</ul>

<h4>Examples:</h4>

<pre><code><span class="hljs-comment">// populates a single object</span>
User.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
  <span class="hljs-keyword">var</span> opts = [
    { path: <span class="hljs-string">'company'</span>, match: { x: <span class="hljs-number">1</span> }, select: <span class="hljs-string">'name'</span> },
    { path: <span class="hljs-string">'notes'</span>, options: { limit: <span class="hljs-number">10</span> }, model: <span class="hljs-string">'override'</span> }
  ];

  User.populate(user, opts, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
    <span class="hljs-built_in">console</span>.log(user);
  });
});

<span class="hljs-comment">// populates an array of objects</span>
User.find(match, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, users</span>) </span>{
  <span class="hljs-keyword">var</span> opts = [{ path: <span class="hljs-string">'company'</span>, match: { x: <span class="hljs-number">1</span> }, select: <span class="hljs-string">'name'</span> }];

  <span class="hljs-keyword">var</span> promise = User.populate(users, opts);
  promise.then(<span class="hljs-built_in">console</span>.log).end();
})

<span class="hljs-comment">// imagine a Weapon model exists with two saved documents:</span>
<span class="hljs-comment">//   { _id: 389, name: 'whip' }</span>
<span class="hljs-comment">//   { _id: 8921, name: 'boomerang' }</span>
<span class="hljs-comment">// and this schema:</span>
<span class="hljs-comment">// new Schema({</span>
<span class="hljs-comment">//   name: String,</span>
<span class="hljs-comment">//   weapon: { type: ObjectId, ref: 'Weapon' }</span>
<span class="hljs-comment">// });</span>

<span class="hljs-keyword">var</span> user = { name: <span class="hljs-string">'Indiana Jones'</span>, weapon: <span class="hljs-number">389</span> };
Weapon.populate(user, { path: <span class="hljs-string">'weapon'</span>, model: <span class="hljs-string">'Weapon'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, user</span>) </span>{
  <span class="hljs-built_in">console</span>.log(user.weapon.name); <span class="hljs-comment">// whip</span>
})

<span class="hljs-comment">// populate many plain objects</span>
<span class="hljs-keyword">var</span> users = [{ name: <span class="hljs-string">'Indiana Jones'</span>, weapon: <span class="hljs-number">389</span> }]
users.push({ name: <span class="hljs-string">'Batman'</span>, weapon: <span class="hljs-number">8921</span> })
Weapon.populate(users, { path: <span class="hljs-string">'weapon'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, users</span>) </span>{
  users.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'%s uses a %s'</span>, users.name, user.weapon.name)
    <span class="hljs-comment">// Indiana Jones uses a whip</span>
    <span class="hljs-comment">// Batman uses a boomerang</span>
  });
});
<span class="hljs-comment">// Note that we didn't need to specify the Weapon model because</span>
<span class="hljs-comment">// it is in the schema's ref</span></code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model-$where"><a href="#model_Model-$where">Model.prototype.$where</a></h3><h5>Type:</h5><ul><li><span class="method-type">&laquo;property&raquo;</span></li></ul><div><p>Additional properties to attach to the query when calling <code>save()</code> and <code>isNew</code> is false.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model-$where"><a href="#model_Model-$where">Model.prototype.$where()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">argument
<span class="method-type">&laquo;String|Function&raquo;</span> is a javascript string or anonymous function</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a <code>Query</code> and specifies a <code>$where</code> condition.</p>

<p>Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via <code>find({ $where: javascript })</code>, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.</p>

<pre><code>Blog.$where(<span class="hljs-string">'this.username.indexOf("val") !== -1'</span>).exec(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, docs</span>) </span>{});</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model-base"><a href="#model_Model-base">Model.prototype.base</a></h3><h5>Type:</h5><ul><li><span class="method-type">&laquo;property&raquo;</span></li></ul><div><p>Base Mongoose instance the model uses.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model-baseModelName"><a href="#model_Model-baseModelName">Model.prototype.baseModelName</a></h3><h5>Type:</h5><ul><li><span class="method-type">&laquo;property&raquo;</span></li></ul><div><p>If this is a discriminator model, <code>baseModelName</code> is the name of the base model.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model-collection"><a href="#model_Model-collection">Model.prototype.collection</a></h3><h5>Type:</h5><ul><li><span class="method-type">&laquo;property&raquo;</span></li></ul><div><p>Collection the model uses.</p>

<p>This property is read-only. Modifying this property is a no-op.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model-db"><a href="#model_Model-db">Model.prototype.db</a></h3><h5>Type:</h5><ul><li><span class="method-type">&laquo;property&raquo;</span></li></ul><div><p>Connection the model uses.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model-delete"><a href="#model_Model-delete">Model.prototype.delete</a></h3><h5>Type:</h5><ul><li><span class="method-type">&laquo;property&raquo;</span></li></ul><div><p>Alias for remove</p>  </div><hr class="separate-api-elements"><h3 id="model_Model-deleteOne"><a href="#model_Model-deleteOne">Model.prototype.deleteOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn]
<span class="method-type">&laquo;function(err|product)&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> Promise</li></ul><div><p>Removes this document from the db. Equivalent to <code>.remove()</code>.</p>

<h4>Example:</h4>

<pre><code>product = <span class="hljs-keyword">await</span> product.deleteOne();
<span class="hljs-keyword">await</span> Product.findById(product._id); <span class="hljs-comment">// null</span></code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model-discriminators"><a href="#model_Model-discriminators">Model.prototype.discriminators</a></h3><h5>Type:</h5><ul><li><span class="method-type">&laquo;property&raquo;</span></li></ul><div><p>Registered discriminators for this model.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model-increment"><a href="#model_Model-increment">Model.prototype.increment()</a></h3><div><p>Signal that we desire an increment of this documents version.</p>

<h4>Example:</h4>

<pre><code>Model.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  doc.increment();
  doc.save(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{ .. })
})</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model-model"><a href="#model_Model-model">Model.prototype.model()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">name
<span class="method-type">&laquo;String&raquo;</span> model name</li></ul><div><p>Returns another Model instance.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> doc = <span class="hljs-keyword">new</span> Tank;
doc.model(<span class="hljs-string">'User'</span>).findById(id, callback);</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model-modelName"><a href="#model_Model-modelName">Model.prototype.modelName</a></h3><h5>Type:</h5><ul><li><span class="method-type">&laquo;property&raquo;</span></li></ul><div><p>The name of the model</p>  </div><hr class="separate-api-elements"><h3 id="model_Model-remove"><a href="#model_Model-remove">Model.prototype.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[fn]
<span class="method-type">&laquo;function(err|product)&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&raquo;</span> Promise</li></ul><div><p>Removes this document from the db.</p>

<h4>Example:</h4>

<pre><code>product.remove(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
  <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> handleError(err);
  Product.findById(product._id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, product</span>) </span>{
    <span class="hljs-built_in">console</span>.log(product) <span class="hljs-comment">// null</span>
  })
})</code></pre>

<p>As an extra measure of flow control, remove will return a Promise (bound to <code>fn</code> if passed) so it could be chained, or hooked to recieve errors</p>

<h4>Example:</h4>

<pre><code>product.remove().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">product</span>) </span>{
   ...
}).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>{
   assert.ok(err)
})</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model-save"><a href="#model_Model-save">Model.prototype.save()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> options optional options</li><ul style="margin-top: 0.5em"><li>[options.session=null]
<span class="method-type">&laquo;Session&raquo;</span> the <a href="https://docs.mongodb.com/manual/reference/server-sessions/">session</a> associated with this save operation. If not specified, defaults to the <a href="api.html#document_Document-$session">document&#39;s associated session</a>.</li></ul><ul style="margin-top: 0.5em"><li>[options.safe]
<span class="method-type">&laquo;Object&raquo;</span> (DEPRECATED) overrides <a href="http://mongoosejs.com//docs/guide.html#safe">schema&#39;s safe option</a>. Use the <code>w</code> option instead.</li></ul><ul style="margin-top: 0.5em"><li>[options.validateBeforeSave]
<span class="method-type">&laquo;Boolean&raquo;</span> set to false to save without validating.</li></ul><ul style="margin-top: 0.5em"><li>[options.w]
<span class="method-type">&laquo;Number|String&raquo;</span> set the <a href="https://docs.mongodb.com/manual/reference/write-concern/#w-option">write concern</a>. Overrides the <a href="/docs/guide.html#writeConcern">schema-level <code>writeConcern</code> option</a></li></ul><ul style="margin-top: 0.5em"><li>[options.j]
<span class="method-type">&laquo;Boolean&raquo;</span> set to true for MongoDB to wait until this <code>save()</code> has been <a href="https://docs.mongodb.com/manual/reference/write-concern/#j-option">journaled before resolving the returned promise</a>. Overrides the <a href="/docs/guide.html#writeConcern">schema-level <code>writeConcern</code> option</a></li></ul><ul style="margin-top: 0.5em"><li>[options.wtimeout]
<span class="method-type">&laquo;Number&raquo;</span> sets a <a href="https://docs.mongodb.com/manual/reference/write-concern/#wtimeout">timeout for the write concern</a>. Overrides the <a href="/docs/guide.html#writeConcern">schema-level <code>writeConcern</code> option</a>.</li></ul><ul style="margin-top: 0.5em"><li>[options.checkKeys=true]
<span class="method-type">&laquo;Boolean&raquo;</span> the MongoDB driver prevents you from saving keys that start with &#39;$&#39; or contain &#39;.&#39; by default. Set this option to <code>false</code> to skip that check. See <a href="https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names">restrictions on field names</a></li></ul><ul style="margin-top: 0.5em"><li>[options.timestamps=true]
<span class="method-type">&laquo;Boolean&raquo;</span> if <code>false</code> and <a href="./guide.html#timestamps">timestamps</a> are enabled, skip timestamps for this <code>save()</code>.</li></ul><li class="param">[fn]
<span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise,undefined&raquo;</span> Returns undefined if used with callback or a Promise otherwise.</li></ul><div><p>Saves this document.</p>

<h4>Example:</h4>

<pre><code>product.sold = <span class="hljs-built_in">Date</span>.now();
product = <span class="hljs-keyword">await</span> product.save();</code></pre>

<p>If save is successful, the returned promise will fulfill with the document saved.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> newProduct = <span class="hljs-keyword">await</span> product.save();
newProduct === product; <span class="hljs-comment">// true</span></code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model-schema"><a href="#model_Model-schema">Model.prototype.schema</a></h3><h5>Type:</h5><ul><li><span class="method-type">&laquo;property&raquo;</span></li></ul><div><p>Schema the model uses.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model.remove"><a href="#model_Model.remove">Model.remove()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">conditions
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Removes all documents that match <code>conditions</code> from the collection. To remove just the first document that matches <code>conditions</code>, set the <code>single</code> option to true.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Character.remove({ name: <span class="hljs-string">'Eddard Stark'</span> });
res.deletedCount; <span class="hljs-comment">// Number of documents removed</span></code></pre>

<h4>Note:</h4>

<p>This method sends a remove command directly to MongoDB, no Mongoose documents are involved. Because no Mongoose documents are involved, Mongoose does not execute <a href="/docs/middleware.html#types-of-middleware">document middleware</a>.</p>  </div><hr class="separate-api-elements"><h3 id="model_Model.replaceOne"><a href="#model_Model.replaceOne">Model.replaceOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">filter
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">doc
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><ul style="margin-top: 0.5em"><li>[options.upsert=false]
<span class="method-type">&laquo;Boolean&raquo;</span> if true, and no documents found, insert a new document</li></ul><ul style="margin-top: 0.5em"><li>[options.writeConcern=null]
<span class="method-type">&laquo;Object&raquo;</span> sets the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a> for replica sets. Overrides the <a href="/docs/guide.html#writeConcern">schema-level write concern</a></li></ul><ul style="margin-top: 0.5em"><li>[options.omitUndefined=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, delete any properties whose value is <code>undefined</code> when casting an update. In other words, if this is set, Mongoose will delete <code>baz</code> from the update in <code>Model.updateOne({}, { foo: &#39;bar&#39;, baz: undefined })</code> before sending the update to the server.</li></ul><ul style="margin-top: 0.5em"><li>[options.timestamps=null]
<span class="method-type">&laquo;Boolean&raquo;</span> If set to <code>false</code> and <a href="/docs/guide.html#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.</li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> <code>function(error, res) {}</code> where <code>res</code> has 3 properties: <code>n</code>, <code>nModified</code>, <code>ok</code>.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB replace the existing document with the given document (no atomic operators like <code>$set</code>).</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Person.replaceOne({ _id: <span class="hljs-number">24601</span> }, { name: <span class="hljs-string">'Jean Valjean'</span> });
res.n; <span class="hljs-comment">// Number of documents matched</span>
res.nModified; <span class="hljs-comment">// Number of documents modified</span></code></pre>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>replaceOne()</code></li>
</ul>  </div><hr class="separate-api-elements"><h3 id="model_Model.startSession"><a href="#model_Model.startSession">Model.startSession()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> see the <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html#startSession">mongodb driver options</a></li><ul style="margin-top: 0.5em"><li>[options.causalConsistency=true]
<span class="method-type">&laquo;Boolean&raquo;</span> set to false to disable causal consistency</li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise&lt;ClientSession&gt;&raquo;</span> promise that resolves to a MongoDB driver <code>ClientSession</code></li></ul><div><p><em>Requires MongoDB >= 3.6.0.</em> Starts a <a href="https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions">MongoDB session</a> for benefits like causal consistency, <a href="https://docs.mongodb.com/manual/core/retryable-writes/">retryable writes</a>, and <a href="http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html">transactions</a>.</p>

<p>Calling <code>MyModel.startSession()</code> is equivalent to calling <code>MyModel.db.startSession()</code>.</p>

<p>This function does not trigger any middleware.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> session = <span class="hljs-keyword">await</span> Person.startSession();
<span class="hljs-keyword">let</span> doc = <span class="hljs-keyword">await</span> Person.findOne({ name: <span class="hljs-string">'Ned Stark'</span> }, <span class="hljs-literal">null</span>, { session });
<span class="hljs-keyword">await</span> doc.remove();
<span class="hljs-comment">// `doc` will always be null, even if reading from a replica set</span>
<span class="hljs-comment">// secondary. Without causal consistency, it is possible to</span>
<span class="hljs-comment">// get a doc back from the below query if the query reads from a</span>
<span class="hljs-comment">// secondary that is experiencing replication lag.</span>
doc = <span class="hljs-keyword">await</span> Person.findOne({ name: <span class="hljs-string">'Ned Stark'</span> }, <span class="hljs-literal">null</span>, { session, readPreference: <span class="hljs-string">'secondary'</span> });</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.syncIndexes"><a href="#model_Model.syncIndexes">Model.syncIndexes()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> options to pass to <code>ensureIndexes()</code></li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> optional callback</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Promise,undefined&raquo;</span> Returns <code>undefined</code> if callback is specified, returns a promise if no callback.</li></ul><div><p>Makes the indexes in MongoDB match the indexes defined in this model's schema. This function will drop any indexes that are not defined in the model's schema except the <code>_id</code> index, and build any indexes that are in your schema but not in MongoDB.</p>

<p>See the <a href="http://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes">introductory blog post</a> for more information.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> Schema({ name: { type: <span class="hljs-built_in">String</span>, unique: <span class="hljs-literal">true</span> } });
<span class="hljs-keyword">const</span> Customer = mongoose.model(<span class="hljs-string">'Customer'</span>, schema);
<span class="hljs-keyword">await</span> Customer.createIndex({ age: <span class="hljs-number">1</span> }); <span class="hljs-comment">// Index is not in schema</span>
<span class="hljs-comment">// Will drop the 'age' index and create an index on `name`</span>
<span class="hljs-keyword">await</span> Customer.syncIndexes();</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.translateAliases"><a href="#model_Model.translateAliases">Model.translateAliases()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">raw
<span class="method-type">&laquo;Object&raquo;</span> fields/conditions that may contain aliased keys</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Object&raquo;</span> the translated &#39;pure&#39; fields/conditions</li></ul><div><p>Translate any aliases fields/conditions so the final query or document object is pure</p>

<h4>Example:</h4>

<pre><code>Character
  .find(Character.translateAliases({
    <span class="hljs-string">'å'</span>: <span class="hljs-string">'Eddard Stark'</span> <span class="hljs-comment">// Alias for 'name'</span>
  })
  .exec(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, characters</span>) </span>{})</code></pre>

<h4>Note:</h4>

<p>Only translate arguments of object type anything else is returned raw</p>  </div><hr class="separate-api-elements"><h3 id="model_Model.update"><a href="#model_Model.update">Model.update()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">filter
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">doc
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><ul style="margin-top: 0.5em"><li>[options.upsert=false]
<span class="method-type">&laquo;Boolean&raquo;</span> if true, and no documents found, insert a new document</li></ul><ul style="margin-top: 0.5em"><li>[options.writeConcern=null]
<span class="method-type">&laquo;Object&raquo;</span> sets the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a> for replica sets. Overrides the <a href="/docs/guide.html#writeConcern">schema-level write concern</a></li></ul><ul style="margin-top: 0.5em"><li>[options.omitUndefined=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, delete any properties whose value is <code>undefined</code> when casting an update. In other words, if this is set, Mongoose will delete <code>baz</code> from the update in <code>Model.updateOne({}, { foo: &#39;bar&#39;, baz: undefined })</code> before sending the update to the server.</li></ul><ul style="margin-top: 0.5em"><li>[options.multi=false]
<span class="method-type">&laquo;Boolean&raquo;</span> whether multiple documents should be updated or just the first one that matches <code>filter</code>.</li></ul><ul style="margin-top: 0.5em"><li>[options.runValidators=false]
<span class="method-type">&laquo;Boolean&raquo;</span> if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model&#39;s schema.</li></ul><ul style="margin-top: 0.5em"><li>[options.setDefaultsOnInsert=false]
<span class="method-type">&laquo;Boolean&raquo;</span> if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model&#39;s schema if a new document is created. This option only works on MongoDB &gt;= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB&#39;s <code>$setOnInsert</code> operator</a>.</li></ul><ul style="margin-top: 0.5em"><li>[options.timestamps=null]
<span class="method-type">&laquo;Boolean&raquo;</span> If set to <code>false</code> and <a href="/docs/guide.html#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.</li></ul><ul style="margin-top: 0.5em"><li>[options.overwrite=false]
<span class="method-type">&laquo;Boolean&raquo;</span> By default, if you don&#39;t include any <a href="https://docs.mongodb.com/manual/reference/operator/update/">update operators</a> in <code>doc</code>, Mongoose will wrap <code>doc</code> in <code>$set</code> for you. This prevents you from accidentally overwriting the document. This option tells Mongoose to skip adding <code>$set</code>.</li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> params are (error, writeOpResult)</li><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> </li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Updates one document in the database without returning it.</p>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>update()</code></li>
</ul>

<h4>Examples:</h4>

<pre><code>MyModel.update({ age: { $gt: <span class="hljs-number">18</span> } }, { oldEnough: <span class="hljs-literal">true</span> }, fn);

<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> MyModel.update({ name: <span class="hljs-string">'Tobi'</span> }, { ferret: <span class="hljs-literal">true</span> });
res.n; <span class="hljs-comment">// Number of documents that matched `{ name: 'Tobi' }`</span>
<span class="hljs-comment">// Number of documents that were changed. If every doc matched already</span>
<span class="hljs-comment">// had `ferret` set to `true`, `nModified` will be 0.</span>
res.nModified;</code></pre>

<h4>Valid options:</h4>

<ul>
<li><code>strict</code> (boolean): overrides the <a href="/docs/guide.html#strict">schema-level <code>strict</code> option</a> for this update</li>
<li><code>upsert</code> (boolean): whether to create the doc if it doesn't match (false)</li>
<li><code>writeConcern</code> (object): sets the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a> for replica sets. Overrides the <a href="/docs/guide.html#writeConcern">schema-level write concern</a></li>
<li><code>omitUndefined</code> (boolean): If true, delete any properties whose value is <code>undefined</code> when casting an update. In other words, if this is set, Mongoose will delete <code>baz</code> from the update in <code>Model.updateOne({}, { foo: 'bar', baz: undefined })</code> before sending the update to the server.</li>
<li><code>multi</code> (boolean): whether multiple documents should be updated (false)</li>
<li><code>runValidators</code>: if true, runs <a href="/docs/validation.html#update-validators">update validators</a> on this command. Update validators validate the update operation against the model's schema.</li>
<li><code>setDefaultsOnInsert</code> (boolean): if this and <code>upsert</code> are true, mongoose will apply the <a href="http://mongoosejs.com/docs/defaults.html">defaults</a> specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on <a href="https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/">MongoDB's <code>$setOnInsert</code> operator</a>.</li>
<li><code>timestamps</code> (boolean): If set to <code>false</code> and <a href="/docs/guide.html#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.</li>
<li><code>overwrite</code> (boolean): disables update-only mode, allowing you to overwrite the doc (false)</li>
</ul>

<p>All <code>update</code> values are cast to their appropriate SchemaTypes before being sent.</p>

<p>The <code>callback</code> function receives <code>(err, rawResponse)</code>.</p>

<ul>
<li><code>err</code> is the error if any occurred</li>
<li><code>rawResponse</code> is the full response from Mongo</li>
</ul>

<h4>Note:</h4>

<p>All top level keys which are not <code>atomic</code> operation names are treated as set operations:</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">var</span> query = { name: <span class="hljs-string">'borne'</span> };
Model.update(query, { name: <span class="hljs-string">'jason bourne'</span> }, options, callback);

<span class="hljs-comment">// is sent as</span>
Model.update(query, { $set: { name: <span class="hljs-string">'jason bourne'</span> }}, options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, res</span>));
// <span class="hljs-title">if</span> <span class="hljs-title">overwrite</span> <span class="hljs-title">option</span> <span class="hljs-title">is</span> <span class="hljs-title">false</span>. <span class="hljs-title">If</span> <span class="hljs-title">overwrite</span> <span class="hljs-title">is</span> <span class="hljs-title">true</span>, <span class="hljs-title">sent</span> <span class="hljs-title">without</span> <span class="hljs-title">the</span> <span class="hljs-title">$set</span> <span class="hljs-title">wrapper</span>.
</span></code></pre>

<p>This helps prevent accidentally overwriting all documents in your collection with <code>{ name: 'jason bourne' }</code>.</p>

<h4>Note:</h4>

<p>Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a "Mod on _id not allowed" error.</p>

<h4>Note:</h4>

<p>Mongoose casts values and runs setters when using update. The following features are <strong>not</strong> applied by default.</p>

<ul>
<li><a href="/docs/defaults.html#the-setdefaultsoninsert-option">defaults</a></li>
<li><a href="/docs/validation.html#update-validators">validators</a></li>
<li>middleware</li>
</ul>

<p>If you need document middleware and fully-featured validation, load the document first and then use <a href="/docs/api.html#model_Model-save"><code>save()</code></a>.</p>

<pre><code>Model.findOne({ name: <span class="hljs-string">'borne'</span> }, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, doc</span>) </span>{
  <span class="hljs-keyword">if</span> (err) ..
  doc.name = <span class="hljs-string">'jason bourne'</span>;
  doc.save(callback);
})</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.updateMany"><a href="#model_Model.updateMany">Model.updateMany()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">filter
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">doc
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><ul style="margin-top: 0.5em"><li>[options.upsert=false]
<span class="method-type">&laquo;Boolean&raquo;</span> if true, and no documents found, insert a new document</li></ul><ul style="margin-top: 0.5em"><li>[options.writeConcern=null]
<span class="method-type">&laquo;Object&raquo;</span> sets the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a> for replica sets. Overrides the <a href="/docs/guide.html#writeConcern">schema-level write concern</a></li></ul><ul style="margin-top: 0.5em"><li>[options.omitUndefined=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, delete any properties whose value is <code>undefined</code> when casting an update. In other words, if this is set, Mongoose will delete <code>baz</code> from the update in <code>Model.updateOne({}, { foo: &#39;bar&#39;, baz: undefined })</code> before sending the update to the server.</li></ul><ul style="margin-top: 0.5em"><li>[options.timestamps=null]
<span class="method-type">&laquo;Boolean&raquo;</span> If set to <code>false</code> and <a href="/docs/guide.html#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.</li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> <code>function(error, res) {}</code> where <code>res</code> has 3 properties: <code>n</code>, <code>nModified</code>, <code>ok</code>.</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except MongoDB will update <em>all</em> documents that match <code>filter</code> (as opposed to just the first one) regardless of the value of the <code>multi</code> option.</p>

<p><strong>Note</strong> updateMany will <em>not</em> fire update middleware. Use <code>pre('updateMany')</code> and <code>post('updateMany')</code> instead.</p>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Person.updateMany({ name: <span class="hljs-regexp">/Stark$/</span> }, { isDeleted: <span class="hljs-literal">true</span> });
res.n; <span class="hljs-comment">// Number of documents matched</span>
res.nModified; <span class="hljs-comment">// Number of documents modified</span></code></pre>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>updateMany()</code></li>
</ul>  </div><hr class="separate-api-elements"><h3 id="model_Model.updateOne"><a href="#model_Model.updateOne">Model.updateOne()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">filter
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">doc
<span class="method-type">&laquo;Object&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> optional see <a href="http://mongoosejs.com/docs/api.html#query_Query-setOptions"><code>Query.prototype.setOptions()</code></a></li><ul style="margin-top: 0.5em"><li>[options.strict]
<span class="method-type">&laquo;Boolean|String&raquo;</span> overwrites the schema&#39;s <a href="http://mongoosejs.com/docs/guide.html#strict">strict mode option</a></li></ul><ul style="margin-top: 0.5em"><li>[options.upsert=false]
<span class="method-type">&laquo;Boolean&raquo;</span> if true, and no documents found, insert a new document</li></ul><ul style="margin-top: 0.5em"><li>[options.writeConcern=null]
<span class="method-type">&laquo;Object&raquo;</span> sets the <a href="https://docs.mongodb.com/manual/reference/write-concern/">write concern</a> for replica sets. Overrides the <a href="/docs/guide.html#writeConcern">schema-level write concern</a></li></ul><ul style="margin-top: 0.5em"><li>[options.omitUndefined=false]
<span class="method-type">&laquo;Boolean&raquo;</span> If true, delete any properties whose value is <code>undefined</code> when casting an update. In other words, if this is set, Mongoose will delete <code>baz</code> from the update in <code>Model.updateOne({}, { foo: &#39;bar&#39;, baz: undefined })</code> before sending the update to the server.</li></ul><ul style="margin-top: 0.5em"><li>[options.timestamps=null]
<span class="method-type">&laquo;Boolean&raquo;</span> If set to <code>false</code> and <a href="/docs/guide.html#timestamps">schema-level timestamps</a> are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.</li></ul><li class="param">[callback]
<span class="method-type">&laquo;Function&raquo;</span> params are (error, writeOpResult)</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Same as <code>update()</code>, except it does not support the <code>multi</code> or <code>overwrite</code> options.</p>

<ul>
<li>MongoDB will update <em>only</em> the first document that matches <code>filter</code> regardless of the value of the <code>multi</code> option.</li>
<li>Use <code>replaceOne()</code> if you want to overwrite an entire document rather than using atomic operators like <code>$set</code>.</li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> Person.updateOne({ name: <span class="hljs-string">'Jean-Luc Picard'</span> }, { ship: <span class="hljs-string">'USS Enterprise'</span> });
res.n; <span class="hljs-comment">// Number of documents matched</span>
res.nModified; <span class="hljs-comment">// Number of documents modified</span></code></pre>

<p>This function triggers the following middleware.</p>

<ul>
<li><code>updateOne()</code></li>
</ul>  </div><hr class="separate-api-elements"><h3 id="model_Model.watch"><a href="#model_Model.watch">Model.watch()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">[pipeline]
<span class="method-type">&laquo;Array&raquo;</span> </li><li class="param">[options]
<span class="method-type">&laquo;Object&raquo;</span> see the <a href="http://mongodb.github.io/node-mongodb-native/3.0/api/Collection.html#watch">mongodb driver options</a></li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;ChangeStream&raquo;</span> mongoose-specific change stream wrapper, inherits from EventEmitter</li></ul><div><p><em>Requires a replica set running MongoDB >= 3.6.0.</em> Watches the underlying collection for changes using <a href="https://docs.mongodb.com/manual/changeStreams/">MongoDB change streams</a>.</p>

<p>This function does <strong>not</strong> trigger any middleware. In particular, it does <strong>not</strong> trigger aggregate middleware.</p>

<h2>The ChangeStream object is an event emitter that emits the following events</h2>

<ul>
<li>'change': A change occurred, see below example</li>
<li>'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow <a href="https://github.com/Automattic/mongoose/issues/6799">this GitHub issue</a> for updates.</li>
<li>'end': Emitted if the underlying stream is closed</li>
<li>'close': Emitted if the underlying stream is closed</li>
</ul>

<h4>Example:</h4>

<pre><code><span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> Person.create({ name: <span class="hljs-string">'Ned Stark'</span> });
<span class="hljs-keyword">const</span> changeStream = Person.watch().on(<span class="hljs-string">'change'</span>, change =&gt; <span class="hljs-built_in">console</span>.log(change));
<span class="hljs-comment">// Will print from the above `console.log()`:</span>
<span class="hljs-comment">// { _id: { _data: ... },</span>
<span class="hljs-comment">//   operationType: 'delete',</span>
<span class="hljs-comment">//   ns: { db: 'mydb', coll: 'Person' },</span>
<span class="hljs-comment">//   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }</span>
<span class="hljs-keyword">await</span> doc.remove();</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.where"><a href="#model_Model.where">Model.where()</a></h3><h5>Parameters</h5><ul class="params"><li class="param">path
<span class="method-type">&laquo;String&raquo;</span> </li><li class="param">[val]
<span class="method-type">&laquo;Object&raquo;</span> optional value</li></ul><h5>Returns:</h5><ul><li><span class="method-type">&laquo;Query&raquo;</span> </li></ul><div><p>Creates a Query, applies the passed conditions, and returns the Query.</p>

<p>For example, instead of writing:</p>

<pre><code>User.find({age: {$gte: <span class="hljs-number">21</span>, $lte: <span class="hljs-number">65</span>}}, callback);</code></pre>

<p>we can instead write:</p>

<pre><code>User.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>).exec(callback);</code></pre>

<p>Since the Query class also supports <code>where</code> you can continue chaining</p>

<pre><code>User
.where(<span class="hljs-string">'age'</span>).gte(<span class="hljs-number">21</span>).lte(<span class="hljs-number">65</span>)
.where(<span class="hljs-string">'name'</span>, <span class="hljs-regexp">/^b/i</span>)
... etc</code></pre>  </div><hr class="separate-api-elements"><h3 id="model_Model.inspect"><a href="#model_Model.inspect">function Object() { [native code] }.prototype.inspect()</a></h3><div><p>Helper for console.log</p>  </div></div><script>_native.init("CK7DT53U",{
  targetClass: 'native-inline'
});</script></div></div><script type="text/javascript">var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://g0a3nbw0xa.execute-api.us-east-1.amazonaws.com/prod/track', true);
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.onreadystatechange = function() {};
xhr.send(JSON.stringify({
  path: window.location.pathname,
  hostname: window.location.hostname,
  hash: window.location.hash
}));</script><script type="text/javascript" src="/docs/js/navbar-search.js"></script><script type="text/javascript">(function (window, document) {
  var layout   = document.getElementById('layout'),
      menu     = document.getElementById('menu'),
      menuLink = document.getElementById('menuLink'),
      content  = document.getElementById('content');

  function toggleClass(element, className) {
      var classes = element.className.split(/\s+/),
          length = classes.length,
          i = 0;

      for(; i < length; i++) {
        if (classes[i] === className) {
          classes.splice(i, 1);
          break;
        }
      }
      // The className is not found
      if (length === classes.length) {
          classes.push(className);
      }

      element.className = classes.join(' ');
  }

  function toggleAll(e) {
      var active = 'active';

      e.preventDefault();
      toggleClass(layout, active);
      toggleClass(menu, active);
      toggleClass(menuLink, active);
  }

  menuLink.onclick = function (e) {
      toggleAll(e);
  };

  content.onclick = function(e) {
      if (menu.className.indexOf('active') !== -1) {
          toggleAll(e);
      }
  };

}(this, this.document));</script></div></body></html>