<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Mongoose v7.1.0: Migrating to Mongoose 6</title><link rel="apple-touch-icon" sizes="57x57" href="/docs/images/favicon/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/docs/images/favicon/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/docs/images/favicon/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/docs/images/favicon/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/docs/images/favicon/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/docs/images/favicon/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/docs/images/favicon/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/docs/images/favicon/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/docs/images/favicon/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/docs/images/favicon/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/docs/images/favicon/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/docs/images/favicon/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/docs/images/favicon/favicon-16x16.png"><link rel="manifest" href="/docs/images/favicon/manifest.json"><link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"><link rel="stylesheet" href="/docs/css/github.css"><link rel="stylesheet" href="/docs/css/mongoose5.css"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/docs/images/favicon/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/docs/css/inlinecpc.css"><script type="text/javascript" src="/docs/js/native.js"></script><style>p { line-height: 1.5em }
</style></head><body><div id="layout"><div id="mobile-menu"><a class="menu-link" id="menuLink" href="#menu"><svg width="100%" height="100%" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></a><div id="mobile-logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div></div><div id="menu"><nav class="pure-menu"><div class="pure-menu-heading" id="logo-container"><a href="/"><img id="logo" src="/docs/images/mongoose5_62x30_transparent.png"><span class="logo-text">mongoose</span></a></div><ul class="pure-menu-list" id="navbar"><li class="pure-menu-horizontal pure-menu-item pure-menu-has-children pure-menu-allow-hover version"><a class="pure-menu-link" href="/docs/index.html">Version 7.1.0</a><ul class="pure-menu-children"><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/6.x/index.html">Version 6.10.5</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/5.x/index.html">Version 5.13.17</a></li></ul></li><li class="pure-menu-item search"><input id="search-input-nav" type="text" placeholder="Search"><button id="search-button-nav"><img src="/docs/images/search.svg"></button></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/index.html">Quick Start</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/guides.html">Guides</a><ul class="pure-menu-list"><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/guide.html">Schemas</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/schematypes.html">SchemaTypes</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/connections.html">Connections</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/models.html">Models</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/documents.html">Documents</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/subdocs.html">Subdocuments</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/queries.html">Queries</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/validation.html">Validation</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/middleware.html">Middleware</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/populate.html">Populate</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/discriminators.html">Discriminators</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/plugins.html">Plugins</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/timestamps.html">Timestamps</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/transactions.html">Transactions</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/typescript.html">TypeScript</a></li></ul></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/api/mongoose.html">API</a><ul class="pure-menu-list"><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/mongoose.html">Mongoose</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/schema.html">Schema</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/connection.html">Connection</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/document.html">Document</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/model.html">Model</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/query.html">Query</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/aggregate.html">Aggregate</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/schematype.html">SchemaType</a></li><li class="pure-menu-item sub-item"><a class="pure-menu-link" href="/docs/api/virtualtype.html">VirtualType</a></li></ul></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/migrating_to_7.html">Migration Guide</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/compatibility.html">Version Compatibility</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/version-support.html">Version Support</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/faq.html">FAQ</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/further_reading.html">Further Reading</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/enterprise.html">For Enterprise</a></li><li class="pure-menu-item"><a class="pure-menu-link" href="/docs/sponsors.html" >Sponsors</a></li></ul><div class="cpc-ad"><script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CKYIL27I&placement=mongoosejscom" id="_carbonads_js"></script></div></nav></div><div class="container"><div id="content"><a class="edit-docs-link" href="https://github.com/Automattic/mongoose/blob/master/docs/migrating_to_6.md" target="_blank">
<img src="/docs/images/pencil.svg" />
</a><h1 id="migrating-from-5x-to-6x">
      <a href="#migrating-from-5x-to-6x">
        Migrating from 5.x to 6.x
      </a>
    </h1>
<script>
  _native.init("CK7DT53U",{
    targetClass: 'native-inline'
  });
</script>

<div class="native-inline">
  <a href="#native_link#"><span class="sponsor">Sponsor</span> #native_company# â€” #native_desc#</a>
</div>

<style>
  ul > li {
    padding: 4px 0px;
  }
</style>

<p>Please note: we plan to discontinue Mongoose 5 support on March 1, 2024.
Please see our <a href="./version-support.html">version support guide</a>.</p>
<p>There are several <a href="https://github.com/Automattic/mongoose/blob/master/CHANGELOG.md">backwards-breaking changes</a>
you should be aware of when migrating from Mongoose 5.x to Mongoose 6.x.</p>
<p>If you&#39;re still on Mongoose 4.x, please read the <a href="migrating_to_5.html">Mongoose 4.x to 5.x migration guide</a> and upgrade to Mongoose 5.x first.</p>
<ul>
<li><a href="#version-requirements">Version Requirements</a></li>
<li><a href="#mongodb-driver-40">MongoDB Driver 4.0</a></li>
<li><a href="#no-more-deprecation-warning-options">No More Deprecation Warning Options</a></li>
<li><a href="#the-aspromise-method-for-connections">The <code>asPromise()</code> Method for Connections</a></li>
<li><a href="#mongoose-connect-returns-a-promise"><code>mongoose.connect()</code> Returns a Promise</a></li>
<li><a href="#duplicate-query-execution">Duplicate Query Execution</a></li>
<li><a href="#model-exists-returns-a-lean-document-instead-of-boolean"><code>Model.exists()</code> Returns a lean document instead of Boolean</a></li>
<li><a href="#strictquery-is-removed-and-replaced-by-strict"><code>strictQuery</code> is now equal to <code>strict</code> by default</a></li>
<li><a href="#mongoerror-is-now-mongoservererror">MongoError is now MongoServerError</a></li>
<li><a href="#simplified-isvalidobjectid-and-separate-isobjectidorhexstring">Simplified <code>isValidObjectId()</code> and separate <code>isObjectIdOrHexString()</code></a></li>
<li><a href="#clone-discriminator-schemas-by-default">Clone Discriminator Schemas By Default</a></li>
<li><a href="#schema-defined-document-key-order">Schema Defined Document Key Order</a></li>
<li><a href="#sanitizefilter-and-trusted"><code>sanitizeFilter</code> and <code>trusted()</code></a></li>
<li><a href="#removed-omitundefined">Removed <code>omitUndefined</code>: Mongoose now removes <code>undefined</code> keys in updates instead of setting them to <code>null</code></a></li>
<li><a href="#document-parameter-to-default-functions">Document Parameter to Default Functions</a></li>
<li><a href="#arrays-are-proxies">Arrays are Proxies</a></li>
<li><a href="#typepojotomixed"><code>typePojoToMixed</code></a></li>
<li><a href="#strictpopulate"><code>strictPopulate()</code></a></li>
<li><a href="#subdocument-ref-function-context">Subdocument <code>ref</code> Function Context</a></li>
<li><a href="#schema-reserved-names-warning">Schema Reserved Names Warning</a></li>
<li><a href="#subdocument-paths">Subdocument Paths</a></li>
<li><a href="#creating-aggregation-cursors">Creating Aggregation Cursors</a></li>
<li><a href="#autocreate-defaults-to-true"><code>autoCreate</code> Defaults to <code>true</code></a></li>
<li><a href="#no-more-context-query">No More <code>context: &#39;query&#39;</code></a></li>
<li><a href="#custom-validators-with-populated-paths">Custom Validators with Populated Paths</a></li>
<li><a href="#disconnected-event-with-replica-sets">Disconnected Event with Replica Sets</a></li>
<li><a href="#removed-execpopulate">Removed <code>execPopulate()</code></a></li>
<li><a href="#create-with-empty-array"><code>create()</code> with Empty Array</a></li>
<li><a href="#removed-nested-path-merging">Removed Nested Path Merging</a></li>
<li><a href="#objectid-valueof">ObjectId <code>valueOf()</code></a></li>
<li><a href="#immutable-createdat">Immutable <code>createdAt</code></a></li>
<li><a href="#removed-validator-isasync">Removed Validator <code>isAsync</code></a></li>
<li><a href="#removed-safe">Removed <code>safe</code></a></li>
<li><a href="#schematype-set-parameters">SchemaType <code>set</code> parameters now use <code>priorValue</code> as the second parameter instead of <code>self</code></a></li>
<li><a href="#no-default-model-for-query-prototype-populate">No default model for <code>Query.prototype.populate()</code></a></li>
<li><a href="#toobject-and-tojson-use-nested-schema-minimize"><code>toObject()</code> and <code>toJSON()</code> Use Nested Schema <code>minimize</code></a></li>
<li><a href="#typescript-changes">TypeScript changes</a></li>
<li><a href="#removed-reconnecttries-and-reconnectinterval-options">Removed <code>reconnectTries</code> and <code>reconnectInterval</code> options</a></li>
</ul>
<h2 id="version-requirements"><a href="#version-requirements">Version Requirements</a></h2>

<p>Mongoose now requires Node.js &gt;= 12.0.0. Mongoose still supports MongoDB server versions back to 3.0.0.</p>
<h2 id="mongodb-driver-40"><a href="#mongodb-driver-40">MongoDB Driver 4.0</a></h2>

<p>Mongoose now uses v4.x of the <a href="https://www.npmjs.com/package/mongodb">MongoDB Node driver</a>.
See <a href="https://github.com/mongodb/node-mongodb-native/blob/4.0/docs/CHANGES_4.0.0.md">the MongoDB Node drivers&#39; migration guide</a> for detailed info.
Below are some of the most noteworthy changes:</p>
<ul>
<li>MongoDB Driver 4.x is written in TypeScript and has its own TypeScript type definitions. These may conflict with <code>@types/mongodb</code>, so if you have TypeScript compiler errors please make sure you upgrade to the <a href="https://www.npmjs.com/package/@types/mongodb">latest version of <code>@types/mongodb</code></a>, which is an empty stub.</li>
<li>The <code>poolSize</code> option for connections has been <a href="https://github.com/mongodb/node-mongodb-native/blob/4.1/docs/CHANGES_4.0.0.md#connection-pool-options">replaced with <code>minPoolSize</code> and <code>maxPoolSize</code></a>. The Mongoose 5.x <code>poolSize</code> option is equivalent to the Mongoose 6 <code>maxPoolSize</code> option. The default value of <code>maxPoolSize</code> has been increased to 100.</li>
<li>The result of <code>updateOne()</code> and <code>updateMany()</code> is now different.</li>
<li>The result of <code>deleteOne()</code> and <code>deleteMany()</code> no longer has an <code>n</code> property.</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title class_">TestModel</span>.<span class="hljs-title function_">updateMany</span>({}, { <span class="hljs-attr">someProperty</span>: <span class="hljs-string">&#x27;someValue&#x27;</span> });

res.<span class="hljs-property">matchedCount</span>; <span class="hljs-comment">// Number of documents that were found that match the filter. Replaces `res.n`</span>
res.<span class="hljs-property">modifiedCount</span>; <span class="hljs-comment">// Number of documents modified. Replaces `res.nModified`</span>
res.<span class="hljs-property">upsertedCount</span>; <span class="hljs-comment">// Number of documents upserted. Replaces `res.upserted`</span>
</code></pre>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title class_">TestModel</span>.<span class="hljs-title function_">deleteMany</span>({});

<span class="hljs-comment">// In Mongoose 6: `{ acknowledged: true, deletedCount: 2 }`</span>
<span class="hljs-comment">// In Mongoose 5: `{ n: 2, ok: 1, deletedCount: 2 }`</span>
res;

res.<span class="hljs-property">deletedCount</span>; <span class="hljs-comment">// Number of documents that were deleted. Replaces `res.n`</span>
</code></pre>
<h2 id="no-more-deprecation-warning-options"><a href="#no-more-deprecation-warning-options">No More Deprecation Warning Options</a></h2>

<p><code>useNewUrlParser</code>, <code>useUnifiedTopology</code>, <code>useFindAndModify</code>, and <code>useCreateIndex</code> are no longer supported options. Mongoose 6 always behaves as if <code>useNewUrlParser</code>, <code>useUnifiedTopology</code>, and <code>useCreateIndex</code> are <code>true</code>, and <code>useFindAndModify</code> is <code>false</code>. Please remove these options from your code.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// No longer necessary:</span>
mongoose.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;useFindAndModify&#x27;</span>, <span class="hljs-literal">false</span>);

<span class="hljs-keyword">await</span> mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">&#x27;mongodb://127.0.0.1:27017/test&#x27;</span>, {
  <span class="hljs-attr">useNewUrlParser</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// &lt;-- no longer necessary</span>
  <span class="hljs-attr">useUnifiedTopology</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// &lt;-- no longer necessary</span>
});
</code></pre>
<h2 id="the-aspromise-method-for-connections"><a href="#the-aspromise-method-for-connections">The <code>asPromise()</code> Method for Connections</a></h2>

<p>Mongoose connections are no longer <a href="https://masteringjs.io/tutorials/fundamentals/thenable">thenable</a>. This means that <code>await mongoose.createConnection(uri)</code> <strong>no longer waits for Mongoose to connect</strong>. Use <code>mongoose.createConnection(uri).asPromise()</code> instead. See <a href="https://github.com/Automattic/mongoose/issues/8810">#8810</a>.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// The below no longer works in Mongoose 6</span>
<span class="hljs-keyword">await</span> mongoose.<span class="hljs-title function_">createConnection</span>(uri);

<span class="hljs-comment">// Do this instead</span>
<span class="hljs-keyword">await</span> mongoose.<span class="hljs-title function_">createConnection</span>(uri).<span class="hljs-title function_">asPromise</span>();
</code></pre>
<h2 id="mongoose-connect-returns-a-promise"><a href="#mongoose-connect-returns-a-promise"><code>mongoose.connect()</code> Returns a Promise</a></h2>

<p>The <code>mongoose.connect()</code> function now always returns a promise, <strong>not</strong> a Mongoose instance.</p>
<h2 id="duplicate-query-execution"><a href="#duplicate-query-execution">Duplicate Query Execution</a></h2>

<p>Mongoose no longer allows executing the same query object twice. If you do, you&#39;ll get a <code>Query was already executed</code> error. Executing the same query instance twice is typically indicative of mixing callbacks and promises, but if you need to execute the same query twice, you can call <code>Query#clone()</code> to clone the query and re-execute it. See <a href="https://github.com/Automattic/mongoose/issues/7398">gh-7398</a></p>
<pre><code class="language-javascript"><span class="hljs-comment">// Results in &#x27;Query was already executed&#x27; error, because technically this `find()` query executes twice.</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Model</span>.<span class="hljs-title function_">find</span>({}, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, result</span>) {});

<span class="hljs-keyword">const</span> q = <span class="hljs-title class_">Model</span>.<span class="hljs-title function_">find</span>();
<span class="hljs-keyword">await</span> q;
<span class="hljs-keyword">await</span> q.<span class="hljs-title function_">clone</span>(); <span class="hljs-comment">// Can `clone()` the query to allow executing the query again</span>
</code></pre>
<h2 id="model-exists-returns-a-lean-document-instead-of-boolean"><a href="#model-exists-returns-a-lean-document-instead-of-boolean">Model.exists(...) now returns a lean document instead of boolean</a></h2>

<pre><code class="language-js"><span class="hljs-comment">// in Mongoose 5.x, `existingUser` used to be a boolean</span>
<span class="hljs-comment">// now `existingUser` will be either `{ _id: ObjectId(...) }` or `null`.</span>
<span class="hljs-keyword">const</span> existingUser = <span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">exists</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span> });
<span class="hljs-keyword">if</span> (existingUser) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(existingUser.<span class="hljs-property">_id</span>);
}
</code></pre>
<h2 id="strictquery-is-removed-and-replaced-by-strict"><a href="#strictquery-is-removed-and-replaced-by-strict"><code>strictQuery</code> is now equal to <code>strict</code> by default</a></h2>

<p><del>Mongoose no longer supports a <code>strictQuery</code> option. You must now use <code>strict</code>.</del>
As of Mongoose 6.0.10, we brought back the <code>strictQuery</code> option.
However, <code>strictQuery</code> is tied to <code>strict</code> by default.
This means that, by default, Mongoose will filter out query filter properties that are not in the schema.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> });
<span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema);

<span class="hljs-comment">// By default, this is equivalent to `User.find()` because Mongoose filters out `notInSchema`</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>({ <span class="hljs-attr">notInSchema</span>: <span class="hljs-number">1</span> });

<span class="hljs-comment">// Set `strictQuery: false` to opt in to filtering by properties that aren&#x27;t in the schema</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>({ <span class="hljs-attr">notInSchema</span>: <span class="hljs-number">1</span> }, <span class="hljs-literal">null</span>, { <span class="hljs-attr">strictQuery</span>: <span class="hljs-literal">false</span> });
<span class="hljs-comment">// equivalent:</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.<span class="hljs-title function_">find</span>({ <span class="hljs-attr">notInSchema</span>: <span class="hljs-number">1</span> }).<span class="hljs-title function_">setOptions</span>({ <span class="hljs-attr">strictQuery</span>: <span class="hljs-literal">false</span> });
</code></pre>
<p>You can also disable <code>strictQuery</code> globally to override:</p>
<pre><code class="language-javascript">mongoose.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;strictQuery&#x27;</span>, <span class="hljs-literal">false</span>);
</code></pre>
<h2 id="mongoerror-is-now-mongoservererror"><a href="#mongoerror-is-now-mongoservererror">MongoError is now MongoServerError</a></h2>

<p>In MongoDB Node.js Driver v4.x, &#39;MongoError&#39; is now &#39;MongoServerError&#39;. Please change any code that depends on the hardcoded string &#39;MongoError&#39;.</p>
<h2 id="clone-discriminator-schemas-by-default"><a href="#clone-discriminator-schemas-by-default">Clone Discriminator Schemas By Default</a></h2>

<p>Mongoose now clones discriminator schemas by default. This means you need to pass <code>{ clone: false }</code> to <code>discriminator()</code> if you&#39;re using recursive embedded discriminators.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// In Mongoose 6, these two are equivalent:</span>
<span class="hljs-title class_">User</span>.<span class="hljs-title function_">discriminator</span>(<span class="hljs-string">&#x27;author&#x27;</span>, authorSchema);
<span class="hljs-title class_">User</span>.<span class="hljs-title function_">discriminator</span>(<span class="hljs-string">&#x27;author&#x27;</span>, authorSchema.<span class="hljs-title function_">clone</span>());

<span class="hljs-comment">// To opt out if `clone()` is causing issues, pass `clone: false`</span>
<span class="hljs-title class_">User</span>.<span class="hljs-title function_">discriminator</span>(<span class="hljs-string">&#x27;author&#x27;</span>, authorSchema, { <span class="hljs-attr">clone</span>: <span class="hljs-literal">false</span> });
</code></pre>
<h2 id="simplified-isvalidobjectid-and-separate-isobjectidorhexstring"><a href="#simplified-isvalidobjectid-and-separate-isobjectidorhexstring">Simplified <code>isValidObjectId()</code> and separate <code>isObjectIdOrHexString()</code></a></h2>

<p>In Mongoose 5, <code>mongoose.isValidObjectId()</code> returned <code>false</code> for values like numbers, which was inconsistent with the MongoDB driver&#39;s <code>ObjectId.isValid()</code> function.
Technically, any JavaScript number can be converted to a MongoDB ObjectId.</p>
<p>In Mongoose 6, <code>mongoose.isValidObjectId()</code> is just a wrapper for <code>mongoose.Types.ObjectId.isValid()</code> for consistency.</p>
<p>Mongoose 6.2.5 now includes a <code>mongoose.isObjectIdOrHexString()</code> function, which does a better job of capturing the more common use case for <code>isValidObjectId()</code>: is the given value an <code>ObjectId</code> instance or a 24 character hex string representing an <code>ObjectId</code>?</p>
<pre><code class="language-javascript"><span class="hljs-comment">// `isValidObjectId()` returns `true` for some surprising values, because these</span>
<span class="hljs-comment">// values are _technically_ ObjectId representations</span>
mongoose.<span class="hljs-title function_">isValidObjectId</span>(<span class="hljs-keyword">new</span> mongoose.<span class="hljs-property">Types</span>.<span class="hljs-title class_">ObjectId</span>()); <span class="hljs-comment">// true</span>
mongoose.<span class="hljs-title function_">isValidObjectId</span>(<span class="hljs-string">&#x27;0123456789ab&#x27;</span>); <span class="hljs-comment">// true</span>
mongoose.<span class="hljs-title function_">isValidObjectId</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// true</span>
mongoose.<span class="hljs-title function_">isValidObjectId</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;test&#x27;</span> })); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// `isObjectIdOrHexString()` instead only returns `true` for ObjectIds and 24</span>
<span class="hljs-comment">// character hex strings.</span>
mongoose.<span class="hljs-title function_">isObjectIdOrHexString</span>(<span class="hljs-keyword">new</span> mongoose.<span class="hljs-property">Types</span>.<span class="hljs-title class_">ObjectId</span>()); <span class="hljs-comment">// true</span>
mongoose.<span class="hljs-title function_">isObjectIdOrHexString</span>(<span class="hljs-string">&#x27;62261a65d66c6be0a63c051f&#x27;</span>); <span class="hljs-comment">// true</span>
mongoose.<span class="hljs-title function_">isObjectIdOrHexString</span>(<span class="hljs-string">&#x27;0123456789ab&#x27;</span>); <span class="hljs-comment">// false</span>
mongoose.<span class="hljs-title function_">isObjectIdOrHexString</span>(<span class="hljs-number">6</span>); <span class="hljs-comment">// false</span>
</code></pre>
<h2 id="schema-defined-document-key-order"><a href="#schema-defined-document-key-order">Schema Defined Document Key Order</a></h2>

<p>Mongoose now saves objects with keys in the order the keys are specified in the schema, not in the user-defined object. So whether <code>Object.keys(new User({ name: String, email: String }).toObject()</code> is <code>[&#39;name&#39;, &#39;email&#39;]</code> or <code>[&#39;email&#39;, &#39;name&#39;]</code> depends on the order <code>name</code> and <code>email</code> are defined in your schema.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">profile</span>: {
    <span class="hljs-attr">name</span>: {
      <span class="hljs-attr">first</span>: <span class="hljs-title class_">String</span>,
      <span class="hljs-attr">last</span>: <span class="hljs-title class_">String</span>
    }
  }
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Test</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;Test&#x27;</span>, schema);

<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>({
  <span class="hljs-attr">profile</span>: { <span class="hljs-attr">name</span>: { <span class="hljs-attr">last</span>: <span class="hljs-string">&#x27;Musashi&#x27;</span>, <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;Miyamoto&#x27;</span> } }
});

<span class="hljs-comment">// Note that &#x27;first&#x27; comes before &#x27;last&#x27;, even though the argument to `new Test()` flips the key order.</span>
<span class="hljs-comment">// Mongoose uses the schema&#x27;s key order, not the provided objects&#x27; key order.</span>
assert.<span class="hljs-title function_">deepEqual</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(doc.<span class="hljs-title function_">toObject</span>().<span class="hljs-property">profile</span>.<span class="hljs-property">name</span>), [<span class="hljs-string">&#x27;first&#x27;</span>, <span class="hljs-string">&#x27;last&#x27;</span>]);
</code></pre>
<h2 id="sanitizefilter-and-trusted"><a href="#sanitizefilter-and-trusted"><code>sanitizeFilter</code> and <code>trusted()</code></a></h2>

<p>Mongoose 6 introduces a new <code>sanitizeFilter</code> option to globals and queries that defends against <a href="https://thecodebarbarian.com/2014/09/04/defending-against-query-selector-injection-attacks.html">query selector injection attacks</a>. If you enable <code>sanitizeFilter</code>, Mongoose will wrap any object in the query filter in a <code>$eq</code>:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// Mongoose will convert this filter into `{ username: &#x27;val&#x27;, pwd: { $eq: { $ne: null } } }`, preventing</span>
<span class="hljs-comment">// a query selector injection.</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">find</span>({ <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;val&#x27;</span>, <span class="hljs-attr">pwd</span>: { <span class="hljs-attr">$ne</span>: <span class="hljs-literal">null</span> } }).<span class="hljs-title function_">setOptions</span>({ <span class="hljs-attr">sanitizeFilter</span>: <span class="hljs-literal">true</span> });
</code></pre>
<p>To explicitly allow a query selector, use <code>mongoose.trusted()</code>:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// `mongoose.trusted()` allows query selectors through</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">find</span>({ <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;val&#x27;</span>, <span class="hljs-attr">pwd</span>: mongoose.<span class="hljs-title function_">trusted</span>({ <span class="hljs-attr">$ne</span>: <span class="hljs-literal">null</span> }) }).<span class="hljs-title function_">setOptions</span>({ <span class="hljs-attr">sanitizeFilter</span>: <span class="hljs-literal">true</span> });
</code></pre>
<h2 id="removed-omitundefined"><a href="#removed-omitundefined">Removed <code>omitUndefined</code>: Mongoose now removes <code>undefined</code> keys in updates instead of setting them to <code>null</code></a></h2>

<p>In Mongoose 5.x, setting a key to <code>undefined</code> in an update operation was equivalent to setting it to <code>null</code>.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">findOneAndUpdate</span>({}, { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span> } }, { <span class="hljs-attr">new</span>: <span class="hljs-literal">true</span> });

res.<span class="hljs-property">name</span>; <span class="hljs-comment">// `null` in Mongoose 5.x</span>

<span class="hljs-comment">// Equivalent to `findOneAndUpdate({}, {}, { new: true })` because `omitUndefined` will</span>
<span class="hljs-comment">// remove `name: undefined`</span>
res = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">findOneAndUpdate</span>({}, { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span> } }, { <span class="hljs-attr">new</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">omitUndefined</span>: <span class="hljs-literal">true</span> });
</code></pre>
<p>Mongoose 5.x supported an <code>omitUndefined</code> option to strip out <code>undefined</code> keys.
In Mongoose 6.x, the <code>omitUndefined</code> option has been removed, and Mongoose will always strip out undefined keys.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// In Mongoose 6, equivalent to `findOneAndUpdate({}, {}, { new: true })` because Mongoose will</span>
<span class="hljs-comment">// remove `name: undefined`</span>
<span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">findOneAndUpdate</span>({}, { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span> } }, { <span class="hljs-attr">new</span>: <span class="hljs-literal">true</span> });
</code></pre>
<p>The only workaround is to explicitly set properties to <code>null</code> in your updates:</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">findOneAndUpdate</span>({}, { <span class="hljs-attr">$set</span>: { <span class="hljs-attr">name</span>: <span class="hljs-literal">null</span> } }, { <span class="hljs-attr">new</span>: <span class="hljs-literal">true</span> });
</code></pre>
<h2 id="document-parameter-to-default-functions"><a href="#document-parameter-to-default-functions">Document Parameter to Default Functions</a></h2>

<p>Mongoose now passes the document as the first parameter to <code>default</code> functions, which is helpful for using <a href="https://masteringjs.io/tutorials/fundamentals/arrow">arrow functions</a> with defaults.</p>
<p>This may affect you if you pass a function that expects different parameters to <code>default</code>, like <code>default: mongoose.Types.ObjectId</code>. See <a href="https://github.com/Automattic/mongoose/issues/9633">gh-9633</a>. If you&#39;re passing a default function that does <strong>not</strong> utilize the document, change <code>default: myFunction</code> to <code>default: () =&gt; myFunction()</code> to avoid accidentally passing parameters that potentially change the behavior.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-title class_">Number</span>,
  <span class="hljs-attr">canVote</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Boolean</span>,
    <span class="hljs-comment">// Default functions now receive a `doc` parameter, helpful for arrow functions</span>
    <span class="hljs-attr">default</span>: <span class="hljs-function"><span class="hljs-params">doc</span> =&gt;</span> doc.<span class="hljs-property">age</span> &gt;= <span class="hljs-number">18</span>
  }
});
</code></pre>
<h2 id="arrays-are-proxies"><a href="#arrays-are-proxies">Arrays are Proxies</a></h2>

<p>Mongoose arrays are now ES6 proxies. You no longer need to <code>markModified()</code> after setting an array index directly.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> post = <span class="hljs-keyword">await</span> <span class="hljs-title class_">BlogPost</span>.<span class="hljs-title function_">findOne</span>();

post.<span class="hljs-property">tags</span>[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;javascript&#x27;</span>;
<span class="hljs-keyword">await</span> post.<span class="hljs-title function_">save</span>(); <span class="hljs-comment">// Works, no need for `markModified()`!</span>
</code></pre>
<h2 id="typepojotomixed"><a href="#typepojotomixed"><code>typePojoToMixed</code></a></h2>

<p>Schema paths declared with <code>type: { name: String }</code> become single nested subdocs in Mongoose 6, as opposed to Mixed in Mongoose 5. This removes the need for the <code>typePojoToMixed</code> option. See <a href="https://github.com/Automattic/mongoose/issues/7181">gh-7181</a>.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// In Mongoose 6, the below makes `foo` into a subdocument with a `name` property.</span>
<span class="hljs-comment">// In Mongoose 5, the below would make `foo` a `Mixed` type, _unless_ you set `typePojoToMixed: true`.</span>
<span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">foo</span>: { <span class="hljs-attr">type</span>: { <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> } }
});
</code></pre>
<h2 id="strictpopulate"><a href="#strictpopulate"><code>strictPopulate()</code></a></h2>

<p>Mongoose now throws an error if you <code>populate()</code> a path that isn&#39;t defined in your schema. This is only for cases when we can infer the local schema, like when you use <code>Query#populate()</code>, <strong>not</strong> when you call <code>Model.populate()</code> on a POJO. See <a href="https://github.com/Automattic/mongoose/issues/5124">gh-5124</a>.</p>
<h2 id="subdocument-ref-function-context"><a href="#subdocument-ref-function-context">Subdocument <code>ref</code> Function Context</a></h2>

<p>When populating a subdocument with a function <code>ref</code> or <code>refPath</code>, <code>this</code> is now the subdocument being populated, not the top-level document. See <a href="https://github.com/Automattic/mongoose/issues/8469">#8469</a>.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">works</span>: [{
    <span class="hljs-attr">modelId</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">data</span>: {
      <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">ObjectId</span>,
      <span class="hljs-attr">ref</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) {
        <span class="hljs-comment">// In Mongoose 6, `doc` is the array element, so you can access `modelId`.</span>
        <span class="hljs-comment">// In Mongoose 5, `doc` was the top-level document.</span>
        <span class="hljs-keyword">return</span> doc.<span class="hljs-property">modelId</span>;
      }
    }
  }]
});
</code></pre>
<h2 id="schema-reserved-names-warning"><a href="#schema-reserved-names-warning">Schema Reserved Names Warning</a></h2>

<p>Using <code>save</code>, <code>isNew</code>, and other Mongoose reserved names as schema path names now triggers a warning, not an error. You can suppress the warning by setting the <code>suppressReservedKeysWarning</code> in your schema options: <code>new Schema({ save: String }, { suppressReservedKeysWarning: true })</code>. Keep in mind that this may break plugins that rely on these reserved names.</p>
<h2 id="subdocument-paths"><a href="#subdocument-paths">Subdocument Paths</a></h2>

<p>Single nested subdocs have been renamed to &quot;subdocument paths&quot;. So <code>SchemaSingleNestedOptions</code> is now <code>SchemaSubdocumentOptions</code> and <code>mongoose.Schema.Types.Embedded</code> is now <code>mongoose.Schema.Types.Subdocument</code>. See <a href="https://github.com/Automattic/mongoose/issues/10419">gh-10419</a></p>
<h2 id="creating-aggregation-cursors"><a href="#creating-aggregation-cursors">Creating Aggregation Cursors</a></h2>

<p><code>Aggregate#cursor()</code> now returns an AggregationCursor instance to be consistent with <code>Query#cursor()</code>. You no longer need to do <code>Model.aggregate(pipeline).cursor().exec()</code> to get an aggregation cursor, just <code>Model.aggregate(pipeline).cursor()</code>.</p>
<h2 id="autocreate-defaults-to-true"><a href="#autocreate-defaults-to-true"><code>autoCreate</code> Defaults to <code>true</code></a></h2>

<p><code>autoCreate</code> is <code>true</code> by default <strong>unless</strong> readPreference is secondary or secondaryPreferred, which means Mongoose will attempt to create every model&#39;s underlying collection before creating indexes. If readPreference is secondary or secondaryPreferred, Mongoose will default to <code>false</code> for both <code>autoCreate</code> and <code>autoIndex</code> because both <code>createCollection()</code> and <code>createIndex()</code> will fail when connected to a secondary.</p>
<h2 id="no-more-context-query"><a href="#no-more-context-query">No More <code>context: 'query'</code></a></h2>

<p>The <code>context</code> option for queries has been removed. Now Mongoose always uses <code>context = &#39;query&#39;</code>.</p>
<h2 id="custom-validators-with-populated-paths"><a href="#custom-validators-with-populated-paths">Custom Validators with Populated Paths</a></h2>

<p>Mongoose 6 always calls validators with depopulated paths (that is, with the id rather than the document itself). In Mongoose 5, Mongoose would call validators with the populated doc if the path was populated. See <a href="https://github.com/Automattic/mongoose/issues/8042">#8042</a></p>
<h2 id="disconnected-event-with-replica-sets"><a href="#disconnected-event-with-replica-sets">Disconnected Event with Replica Sets</a></h2>

<p>When connected to a replica set, connections now emit &#39;disconnected&#39; when connection to the primary is lost. In Mongoose 5, connections only emitted &#39;disconnected&#39; when losing connection to all members of the replica set.</p>
<p>However, Mongoose 6 does <strong>not</strong> buffer commands while a connection is disconnected. So you can still successfully execute commands like queries with <code>readPreference = &#39;secondary&#39;</code>, even if the Mongoose connection is in the disconnected state.</p>
<h2 id="removed-execpopulate"><a href="#removed-execpopulate">Removed <code>execPopulate()</code></a></h2>

<p><code>Document#populate()</code> now returns a promise and is now no longer chainable.</p>
<ul>
<li>Replace <code>await doc.populate(&#39;path1&#39;).populate(&#39;path2&#39;).execPopulate();</code> with <code>await doc.populate([&#39;path1&#39;, &#39;path2&#39;]);</code></li>
<li>Replace <code>await doc.populate(&#39;path1&#39;, &#39;select1&#39;).populate(&#39;path2&#39;, &#39;select2&#39;).execPopulate();</code> with<pre><code><span class="hljs-keyword">await</span> doc.<span class="hljs-title function_">populate</span>([{<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;path1&#x27;</span>, <span class="hljs-attr">select</span>: <span class="hljs-string">&#x27;select1&#x27;</span>}, {<span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;path2&#x27;</span>, <span class="hljs-attr">select</span>: <span class="hljs-string">&#x27;select2&#x27;</span>}]);
</code></pre>
</li>
</ul>
<h2 id="create-with-empty-array"><a href="#create-with-empty-array"><code>create()</code> with Empty Array</a></h2>

<p><code>await Model.create([])</code> in v6.0 returns an empty array when provided an empty array, in v5.0 it used to return <code>undefined</code>. If any of your code is checking whether the output is <code>undefined</code> or not, you need to modify it with the assumption that <code>await Model.create(...)</code> will always return an array if provided an array.</p>
<h2 id="removed-nested-path-merging"><a href="#removed-nested-path-merging">Removed Nested Path Merging</a></h2>

<p><code>doc.set({ child: { age: 21 } })</code> now works the same whether <code>child</code> is a nested path or a subdocument: Mongoose will overwrite the value of <code>child</code>. In Mongoose 5, this operation would merge <code>child</code> if <code>child</code> was a nested path.</p>
<h2 id="objectid-valueof"><a href="#objectid-valueof">ObjectId <code>valueOf()</code></a></h2>

<p>Mongoose now adds a <code>valueOf()</code> function to ObjectIds. This means you can now use <code>==</code> to compare an ObjectId against a string.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-title class_">ObjectId</span>(<span class="hljs-string">&#x27;6143b55ac9a762738b15d4f0&#x27;</span>);

a == <span class="hljs-string">&#x27;6143b55ac9a762738b15d4f0&#x27;</span>; <span class="hljs-comment">// true</span>
</code></pre>
<h2 id="immutable-createdat"><a href="#immutable-createdat">Immutable <code>createdAt</code></a></h2>

<p>If you set <code>timestamps: true</code>, Mongoose will now make the <code>createdAt</code> property <code>immutable</code>. See <a href="https://github.com/Automattic/mongoose/issues/10139">gh-10139</a></p>
<h2 id="removed-validator-isasync"><a href="#removed-validator-isasync">Removed Validator <code>isAsync</code></a></h2>

<p><code>isAsync</code> is no longer an option for <code>validate</code>. Use an <code>async function</code> instead.</p>
<h2 id="removed-safe"><a href="#removed-safe">Removed <code>safe</code></a></h2>

<p><code>safe</code> is no longer an option for schemas, queries, or <code>save()</code>. Use <code>writeConcern</code> instead.</p>
<h2 id="schematype-set-parameters"><a href="#schematype-set-parameters">SchemaType <code>set</code> parameters</a></h2>

<p>Mongoose now calls setter functions with <code>priorValue</code> as the 2nd parameter, rather than <code>schemaType</code> in Mongoose 5.</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">trimStart</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">set</span>: trimStartSetter
  }
});

<span class="hljs-comment">// in v5.x the parameters were (value, schemaType), in v6.x the parameters are (value, priorValue, schemaType).</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">trimStartSetter</span>(<span class="hljs-params">val, priorValue, schemaType</span>) {
  <span class="hljs-keyword">if</span> (schemaType.<span class="hljs-property">options</span>.<span class="hljs-property">trimStart</span> &amp;&amp; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;string&#x27;</span>) {
    <span class="hljs-keyword">return</span> val.<span class="hljs-title function_">trimStart</span>();
  }
  <span class="hljs-keyword">return</span> val;
}

<span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;User&#x27;</span>, userSchema);

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Robert Martin&#x27;</span> });
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;robert martin&#x27;</span>
</code></pre>
<h2 id="toobject-and-tojson-use-nested-schema-minimize"><a href="#toobject-and-tojson-use-nested-schema-minimize"><code>toObject()</code> and <code>toJSON()</code> Use Nested Schema <code>minimize</code></a></h2>

<p>This change was technically released with 5.10.5, but <a href="https://github.com/Automattic/mongoose/issues/10827">caused issues for users migrating from 5.9.x to 6.x</a>.
In Mongoose <code>&lt; 5.10.5</code>, <code>toObject()</code> and <code>toJSON()</code> would use the top-level schema&#39;s <code>minimize</code> option by default.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> child = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">thing</span>: <span class="hljs-title class_">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">Mixed</span> });
<span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ child }, { <span class="hljs-attr">minimize</span>: <span class="hljs-literal">false</span> });
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Parent</span> = <span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;Parent&#x27;</span>, parent);
<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>({ <span class="hljs-attr">child</span>: { <span class="hljs-attr">thing</span>: {} } });

<span class="hljs-comment">// In v5.10.4, would contain `child.thing` because `toObject()` uses `parent` schema&#x27;s `minimize` option</span>
<span class="hljs-comment">// In `&gt;= 5.10.5`, `child.thing` is omitted because `child` schema has `minimize: true`</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">toObject</span>());
</code></pre>
<p>As a workaround, you can either explicitly pass <code>minimize</code> to <code>toObject()</code> or <code>toJSON()</code>:</p>
<pre><code class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">toObject</span>({ <span class="hljs-attr">minimize</span>: <span class="hljs-literal">false</span> }));
</code></pre>
<p>Or define the <code>child</code> schema inline (Mongoose 6 only) to inherit the parent&#39;s <code>minimize</code> option.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> parent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-comment">// Implicitly creates a new schema with the top-level schema&#x27;s `minimize` option.</span>
  <span class="hljs-attr">child</span>: { <span class="hljs-attr">type</span>: { <span class="hljs-attr">thing</span>: <span class="hljs-title class_">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">Mixed</span> } }
}, { <span class="hljs-attr">minimize</span>: <span class="hljs-literal">false</span> });
</code></pre>
<h2 id="no-default-model-for-query-prototype-populate"><a href="#no-default-model-for-query-prototype-populate">No default model for <code>Query.prototype.populate()</code></a></h2>

<p>In Mongoose 5, calling <code>populate()</code> on a mixed type or other path with no <code>ref</code> would fall back to using the query&#39;s model.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> testSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">data</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">parents</span>: <span class="hljs-title class_">Array</span> <span class="hljs-comment">// Array of mixed</span>
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Test</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;Test&#x27;</span>, testSchema);

<span class="hljs-comment">// The below `populate()`...</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">findOne</span>().<span class="hljs-title function_">populate</span>(<span class="hljs-string">&#x27;parents&#x27;</span>);
<span class="hljs-comment">// Is a shorthand for the following populate in Mongoose 5</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">findOne</span>().<span class="hljs-title function_">populate</span>({ <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;parents&#x27;</span>, <span class="hljs-attr">model</span>: <span class="hljs-title class_">Test</span> });
</code></pre>
<p>In Mongoose 6, populating a path with no <code>ref</code>, <code>refPath</code>, or <code>model</code> is a no-op.</p>
<pre><code class="language-javascript"><span class="hljs-comment">// The below `populate()` does nothing.</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">findOne</span>().<span class="hljs-title function_">populate</span>(<span class="hljs-string">&#x27;parents&#x27;</span>);
</code></pre>
<h2 id="typescript-changes">
      <a href="#typescript-changes">
        TypeScript changes
      </a>
    </h2>
<p>The <code>Schema</code> class now takes 3 generic params instead of 4. The 3rd generic param, <code>SchemaDefinitionType</code>, is now the same as the 1st generic param <code>DocType</code>. Replace <code>new Schema&lt;UserDocument, UserModel, User&gt;(schemaDefinition)</code> with <code>new Schema&lt;UserDocument, UserModel&gt;(schemaDefinition)</code></p>
<p><code>Types.ObjectId</code> is now a class, which means you can no longer omit <code>new</code> when creating a new ObjectId using <code>new mongoose.Types.ObjectId()</code>.
Currently, you can still omit <code>new</code> in JavaScript, but you <strong>must</strong> put <code>new</code> in TypeScript.</p>
<p>The following legacy types have been removed:</p>
<ul>
<li><code>ModelUpdateOptions</code></li>
<li><code>DocumentQuery</code></li>
<li><code>HookSyncCallback</code></li>
<li><code>HookAsyncCallback</code></li>
<li><code>HookErrorCallback</code></li>
<li><code>HookNextFunction</code></li>
<li><code>HookDoneFunction</code></li>
<li><code>SchemaTypeOpts</code></li>
<li><code>ConnectionOptions</code></li>
</ul>
<p>Mongoose 6 infers the document&#39;s type for <code>this</code> in virtual getters and setters.
In Mongoose 5.x, <code>this</code> would be <code>any</code> in the following code.</p>
<pre><code class="language-ts">schema.<span class="hljs-title function_">virtual</span>(<span class="hljs-string">&#x27;myVirtual&#x27;</span>).<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>; <span class="hljs-comment">// any in Mongoose 5.x</span>
});
</code></pre>
<p>In Mongoose 6, <code>this</code> will be set to the document type.</p>
<pre><code class="language-ts"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> });

schema.<span class="hljs-title function_">virtual</span>(<span class="hljs-string">&#x27;myVirtual&#x27;</span>).<span class="hljs-title function_">get</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">// string</span>
});
</code></pre>
<h2 id="removed-reconnecttries-and-reconnectinterval-options"><a href="#removed-reconnecttries-and-reconnectinterval-options">Removed <code>reconnectTries</code> and <code>reconnectInterval</code> options</a></h2>

<p>The <code>reconnectTries</code> and <code>reconnectInterval</code> options have been removed since they are no longer necessary.</p>
<p>The MongoDB node driver will always attempt to retry any operation for up to <code>serverSelectionTimeoutMS</code>, even if MongoDB is down for a long period of time.
So, it will never run out of retries or try to reconnect to MongoDB.</p>
</div></div><div id="jobs"><div class="job-listing"><a href="/docs/jobs.html#61f0b0402d893554bc3a247f"><div class="company-logo"><img src="//images.ctfassets.net/3ouphkrynjol/3mfb7HH2YowrPxX9C6ik6H/723034bcb4e99349663c4bc8223fb8b6/localizejs.com.png"></div><div class="description"><div class="company">Localize</div><div class="title">Full Stack Engineer</div><div class="location">Anywhere</div></div></a></div><div class="job-listing"><a href="/docs/jobs.html#62c288992e788eb5404ba57d"><div class="company-logo"><img src="https://static.devitjobs.uk/logo-images/devit-logo-square.png"></div><div class="description"><div class="company">DevITjobs.us</div><div class="title">Lead Backend Developer [110'000 - 150'000 USD]</div><div class="location">100% Remote</div></div></a></div><div class="job-listing"><a href="/docs/jobs.html#62c288992e788eb5404ba57e"><div class="company-logo"><img src="https://static.devitjobs.uk/logo-images/devit-logo-square.png"></div><div class="description"><div class="company">DevITjobs.us</div><div class="title">Senior Full Stack Engineer [100'000 - 115'000 CHF]</div><div class="location">100% Remote</div></div></a></div><div class="button jobs-view-more"><a href="/docs/jobs.html">View more jobs!</a></div></div><script type="text/javascript" src="/docs/js/navbar-search.js"></script><script type="text/javascript" src="/docs/js/mobile-navbar-toggle.js"></script></div></body></html>